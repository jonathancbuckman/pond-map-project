<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Layflat Hydraulic Modeler</title>
  <link rel="stylesheet" href="css/style.css"/>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <!-- Leaflet CSS for map preview -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    /* Page-local styles for the modeler (kept minimal; reuses global font) */
    .modeler-wrap {
      max-width: 1000px;
      margin: 0 auto;
      padding: 12px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
    }
    .site-header {
      padding: 10px;
      border-bottom: 1px solid #e5e5e5;
      background: #fff;
      font-family: 'ISOCPEUR', Arial, sans-serif;
    }
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .field label {
      font-size: 13px;
    }
    .field input[type="number"], .field select, .field input[type="file"] {
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      background: #fff;
      color: #222;
    }
    .radio-row {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      font-size: 14px;
    }
    .section-card {
      background: #fff;
      border: 1px solid #e5e5e5;
      border-radius: 10px;
      padding: 14px;
      margin-top: 14px;
    }
    .section-card h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
    }
    .btn {
      display: inline-block;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #0b5fff;
      color: #fff;
      text-decoration: none;
      cursor: pointer;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      font-size: 14px;
      border-color: #084bd1;
    }
    .btn[disabled] {
      opacity: 0.65;
      cursor: not-allowed;
    }
    .btn.secondary {
      background: #f9f9f9;
      color: #333;
      border-color: #ddd;
    }
    .inline-help {
      font-size: 12px;
      color: #666;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .results-table th, .results-table td {
      border: 1px solid #e5e5e5;
      padding: 6px 8px;
    }
    .results-table th {
      background: #f8f8f8;
      text-align: left;
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      color: #fff;
    }
    .badge.good { background: #198754; }
    .badge.bad { background: #dc3545; }
    .warnings {
      margin: 8px 0 0 18px;
      color: #b58900;
    }
    .chart-box {
      position: relative;
      height: 320px;
      width: 100%;
    }
    /* Map preview box */
    #busy-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.75);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(1px);
    }
    .busy-card {
      background: #ffffff;
      border: 1px solid #e5e5e5;
      border-radius: 10px;
      padding: 14px 16px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
      font-family: 'ISOCPEUR', Arial, sans-serif;
      color: #333;
      min-width: 260px;
      text-align: center;
    }
    .spinner {
      width: 22px;
      height: 22px;
      border: 3px solid #cfd8ff;
      border-top-color: #0b5fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 10px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #modeler-map {
      height: 350px;
      width: 100%;
      border: 1px solid #e5e5e5;
      border-radius: 10px;
    }
  </style>
</head>
<body class="modeler-page">
  <header class="site-header" role="banner">
    <strong>Layflat Hydraulic Modeler</strong>
  </header>

  <main class="modeler-wrap" role="main">
    <!-- Introductory guidance -->
    <section class="section-card" style="background:#fcfcff;">
      <h3>How to use this tool</h3>
      <p class="inline-help" style="max-width:880px;">
        This calculator estimates pressure along a layflat hose route and places midline pumps automatically to respect a minimum suction pressure.
        KML only: upload a .kml file that contains a single simple LineString path. KMZ is not supported.
        To get started:
      </p>
      <ol class="inline-help" style="max-width:880px; margin-top:6px; padding-left:18px;">
        <li>Create a KML file containing one LineString that follows your hose path on the ground. You can draw this in Google Earth or other GIS tools.</li>
        <li>Upload the KML below. Choose the drawing direction so the path begins at your Source pump and ends at the Destination (or reverse if needed).</li>
        <li>Set your hydraulic inputs (flow, hose diameter, pressure limits). Choose how friction loss is determined (lookup vs manual).</li>
        <li>Click "Run Calculation". You'll see:
          <ul style="margin:6px 0 0 18px;">
            <li>Map preview of the path and any automatically placed midline pumps.</li>
            <li>A pressure profile chart with your minimum suction requirement.</li>
            <li>A results summary including total path distance, final outlet pressure, and pump count.</li>
          </ul>
        </li>
      </ol>
      <p class="inline-help" style="max-width:880px; margin-top:8px;">
        Notes: Elevations are sampled from public terrain data and may be approximate.
      </p>
    </section>

    <!-- 1) Path first: user uploads KML up front -->
    <section class="section-card">
      <h3>Path (KML only)</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Upload a .kml file containing one LineString. If the route was drawn from Destination back to Source, use the "Reverse" option so the simulation starts at the Source pump.
      </p>
      <div class="form-grid">
        <div class="field">
          <label for="kml-file">Upload KML (LineString path)</label>
          <input id="kml-file" type="file" accept=".kml">
          <div class="inline-help">Up to ~2,000 points are used (downsampling applied if needed). Direction can be reversed below.</div>
        </div>
        <div class="field">
          <label>Path Drawing Direction</label>
          <div class="radio-row">
            <label><input type="radio" name="path-dir" value="source_to_dest" checked> Source → Destination</label>
            <label><input type="radio" name="path-dir" value="dest_to_source"> Destination → Source (Reverse)</label>
          </div>
          <div class="inline-help">Pick the direction that matches how your LineString was drawn so the "Source" end is simulated first.</div>
        </div>
      </div>
      <div class="inline-help" id="path-status" style="margin-top:8px;display:none;"></div>
    </section>

    <!-- 2) Core hydraulics inputs -->
    <section class="section-card">
      <h3>Hydraulic Inputs</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Set operating parameters for your system. The simulation starts at the Source discharge pressure and accounts for friction and terrain elevation changes along the uploaded path. When pressure is predicted to fall below the minimum suction threshold ahead, a midline pump is placed to boost pressure.
      </p>
      <div class="form-grid">
        <div class="field">
          <label for="flow-bpm">Flow Rate (Barrels per minute)</label>
          <input id="flow-bpm" type="number" step="0.1" min="0" value="50">
        </div>

        <div class="field">
          <label for="hose-size">Hose Diameter</label>
          <select id="hose-size">
            <option value="12">12 inches</option>
            <option value="14">14 inches</option>
            <option value="16" selected>16 inches</option>
          </select>
        </div>

        <div class="field">
          <label for="source-psi">Source Pump Discharge (PSI)</label>
          <input id="source-psi" type="number" step="0.1" min="0.1" value="100">
          <div class="inline-help">Starting pressure at the source (e.g., water source or first pump).</div>
        </div>

        <div class="field">
          <label for="midline-psi">Midline Pump Discharge (PSI)</label>
          <input id="midline-psi" type="number" step="0.1" min="0.1" value="80">
          <div class="inline-help">Discharge setpoint used for automatically placed midline pumps.</div>
        </div>

        <div class="field">
          <label for="min-suction-psi">Min Midline Pump Inlet (PSI)</label>
          <input id="min-suction-psi" type="number" step="0.1" min="0" value="20">
          <div class="inline-help">Minimum suction requirement. The planner places a pump before sections where pressure would dip below this value.</div>
        </div>

        <div class="field">
          <label for="max-hose-psi">Max Allowable Hose Pressure (PSI)</label>
          <input id="max-hose-psi" type="number" step="1" min="1" value="150">
          <div class="inline-help">Upper limit for the hose rating. The results warn if the profile exceeds this anywhere.</div>
        </div>

        <div class="field">
          <label for="req-outlet-psi">Desired Min Outlet Pressure (PSI)</label>
          <input id="req-outlet-psi" type="number" step="1" min="0" value="20">
          <div class="inline-help">Target pressure at the destination end of the path.</div>
        </div>

        <div class="field">
          <label for="placement-strategy">Pump Placement Strategy</label>
          <select id="placement-strategy">
            <option value="reactive">Reactive</option>
            <option value="optimized">Optimized Look-ahead</option>
            <option value="minimized" selected>Minimum Pump Count (default)</option>
          </select>
          <div class="inline-help">Choose algorithm for automatic midline pump placement.</div>
        </div>
      </div>

      <div class="section-card" style="margin-top:12px;">
        <div class="field">
          <label>Friction Loss Method</label>
          <div class="radio-row">
            <label><input type="radio" name="loss-method" value="lookup" checked> Calculate from Flow & Hose Size</label>
            <label><input type="radio" name="loss-method" value="manual"> Enter PSI Loss Manually</label>
          </div>
          <div class="inline-help">
            Lookup mode converts BPM → GPM, interpolates a 12″ hose loss table, then scales to your diameter (~D<sup>-4.87</sup>) and converts to PSI per 100 ft.
            Manual mode lets you input PSI/100 ft directly (e.g., from vendor data or field testing).
          </div>
        </div>
        <div id="manual-loss-wrap" class="field" style="display:none; margin-top:8px;">
          <label for="manual-loss-psi100">Manual PSI Loss per 100 ft</label>
          <input id="manual-loss-psi100" type="number" step="0.01" min="0" value="0">
          <div class="inline-help">Only used when "Enter PSI Loss Manually" is selected. Units: PSI per 100 ft.</div>
        </div>
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;">
        <button id="run-calc" class="btn">Run Calculation</button>
        <button id="reset-form" class="btn secondary">Reset</button>
        <button id="generate-report" class="btn secondary" title="Open printable report in a new tab" disabled>Generate Report</button>
      </div>
    </section>

    <section class="section-card" id="map-section" style="display:none;">
      <h3>Map Preview</h3>
      <p class="inline-help" style="margin-top:-6px;">
        The polyline shows your uploaded path. Pump markers are placed automatically where the inlet pressure would otherwise dip below the minimum suction threshold.
        Click markers for details.
      </p>
      <div id="modeler-map"></div>
      <div class="inline-help" id="map-hint" style="margin-top:6px;">Path and pump markers will display here after KML processing.</div>
    </section>

    <section class="section-card" id="results-section" style="display:none;">
      <h3>Results Summary</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Total distance is derived from your path after downsampling (if applied). "Outlet met?" compares the calculated final pressure to your desired minimum outlet pressure.
      </p>
      <table class="results-table">
        <tbody>
          <tr><th>Total Distance (ft)</th><td id="out-total-dist">—</td></tr>
          <tr><th>Used PSI Loss / 100 ft</th><td id="out-used-loss">—</td></tr>
          <tr><th>Final Outlet Pressure (PSI)</th><td id="out-final-psi">—</td></tr>
          <tr><th>Outlet Pressure Met?</th><td id="out-outlet-met">—</td></tr>
          <tr><th>Midline Pumps Placed</th><td id="out-pump-count">—</td></tr>
        </tbody>
      </table>
      <div id="warnings-wrap" style="margin-top:8px; display:none;">
        <strong>Warnings</strong>
        <ul class="warnings" id="warnings-list"></ul>
      </div>
    </section>

    <section class="section-card" id="chart-section" style="display:none;">
      <h3>Pressure Profile</h3>
      <p class="inline-help" style="margin-top:-6px;">
        The blue line is pressure along the path (includes elevation changes and friction). The dashed line is your minimum suction threshold. Vertical jumps indicate pump boosts.
      </p>
      <div class="chart-box">
        <canvas id="pressureChart"></canvas>
      </div>
    </section>
  </main>

  <footer class="site-footer" role="contentinfo">
    <nav class="footer-nav" aria-label="Footer">
      <a class="footer-link" href="index.html">Home</a>
      <a class="footer-link" href="layflat-modeler.html" aria-current="page">Layflat Hydraulic Modeler</a>
    </nav>
  </footer>

  <!-- Leaflet JS for map preview -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Chart.js for pressure plot -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script>
    // --- Constants and data ---
    const BARRELS_TO_GALLONS = 42.0;
    const PSI_PER_FOOT_WATER = 0.433;
    const OPENTOPODATA_ENDPOINT = 'https://api.opentopodata.org/v1/ned10m';
    // CORS-safe JSON proxies to bypass missing CORS headers from third-party services.
    // Try in order; some may block or rate-limit.
    const CORS_JSON_PROXIES = [
      // Use CORS proxies that accept a full absolute URL (no double protocol)
      // Each entry is an object with: { mode: 'prefix' | 'param', value: string }
      { mode: 'prefix', value: 'https://r.jina.ai/' },               // fetches target URL as text/json with permissive CORS
      { mode: 'param',  value: 'https://api.allorigins.win/raw?url=' }, // AllOrigins RAW passthrough
      { mode: 'prefix', value: 'https://cors.isomorphic-git.org/' }  // isomorphic-git CORS proxy
    ];
    const MAX_POINTS = 2000;          // hard cap for safety
    const BATCH_SIZE = 100;           // OpenTopoData batch chunk
    // 12" reference table: [GPM, head loss (ft) per 100 ft]
    const HOSE_DATA_12_INCH = [
      [0,0.0],[300,0.03],[350,0.04],[400,0.04],[450,0.05],
      [500,0.06],[550,0.07],[600,0.09],[650,0.11],[700,0.13],
      [750,0.15],[800,0.17],[850,0.19],[900,0.21],[950,0.23],
      [1000,0.26],[1100,0.30],[1200,0.35],[1300,0.40],[1400,0.46],
      [1500,0.53],[1600,0.60],[1700,0.67],[1800,0.75],[1900,0.83],
      [2000,0.92],[2500,1.45],[3000,2.05],[3500,2.75],[4000,3.57],
      [4500,4.31],[5000,5.01]
    ];

    function bpmToGpm(bpm) { return bpm * BARRELS_TO_GALLONS; }

    function lookupHeadLoss12in(gpm) {
      if (gpm < 0) return null;
      if (gpm === 0) return 0.0;
      let lower = null, upper = null;
      for (let i=0;i<HOSE_DATA_12_INCH.length;i++) {
        const [x, y] = HOSE_DATA_12_INCH[i];
        if (x === gpm) return y;
        if (x < gpm) lower = [x,y];
        if (x > gpm) { upper = [x,y]; break; }
      }
      if (!lower && upper) return null;
      if (lower && !upper) return null;
      if (!lower || !upper) return null;
      const [x1,y1] = lower, [x2,y2] = upper;
      if (x2 === x1) return y1;
      return y1 + (y2 - y1) * (gpm - x1) / (x2 - x1);
    }

    function scaleHeadLossByDiameter(headLoss12, targetInches) {
      const d = Number(targetInches);
      if (!d || d <= 0) return headLoss12;
      if (d === 12) return headLoss12;
      const factor = Math.pow(12.0 / d, 4.87);
      return headLoss12 * factor;
    }

    function headLossFtToPsi(headLossFt) {
      return headLossFt * PSI_PER_FOOT_WATER;
    }

    // Downsample coordinates to at most maxPoints using even index sampling
    function downsampleLatLngs(latlngs, maxPoints) {
      if (!latlngs || latlngs.length <= maxPoints) return latlngs || [];
      const result = [];
      const step = (latlngs.length - 1) / (maxPoints - 1);
      for (let i = 0; i < maxPoints; i++) {
        const idx = Math.round(i * step);
        result.push(latlngs[idx]);
      }
      return result;
    }

    // Parse KML text to extract first LineString coordinates as [lat, lng]
    function parseKmlLineStringToLatLngs(kmlText) {
      const parser = new DOMParser();
      const xml = parser.parseFromString(kmlText, 'text/xml');
      const coords = xml.getElementsByTagName('coordinates');
      if (!coords || !coords.length) return [];
      const text = coords[0].textContent || '';
      const parts = text.trim().split(/\s+/);
      const latlngs = [];
      for (const p of parts) {
        const [lonStr, latStr] = p.split(',');
        const lat = parseFloat(latStr), lon = parseFloat(lonStr);
        if (isFinite(lat) && isFinite(lon)) latlngs.push([lat, lon]);
      }
      return latlngs;
    }

    // KMZ parsing intentionally unsupported to simplify client-side; KML only.
    async function extractKmlFromKmz(file) {
      throw new Error('KMZ is not supported. Please upload a .kml file.');
    }

    // Fetch elevations for latlngs via OpenTopoData in batches; returns meters array
    async function fetchElevationsOpenTopo(latlngs) {
      // Strategy (more robust):
      // 1) Try multiple permissive CORS proxies (works on localhost).
      // 2) Try direct fetch (works if API provides CORS).
      // 3) Try JSONP via AllOrigins (last resort).
      // 4) If all fail, return zeros for the batch to keep UI functioning.
      const elevations = [];
  
      async function fetchJson(url) {
        const resp = await fetch(url, { headers: { 'Accept': 'application/json' } });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        // Some proxies (e.g., r.jina.ai) may downconvert; try JSON, fallback to text->JSON
        try {
          return await resp.json();
        } catch {
          const txt = await resp.text();
          try {
            return JSON.parse(txt);
          } catch {
            // For AllOrigins raw endpoint, the response is the upstream JSON already
            // If it wasn't valid JSON, surface an error
            throw new Error('Non-JSON response');
          }
        }
      }
  
      // JSONP fallback using allorigins JSONP (stable callback delivery)
      async function fetchViaJsonp(url) {
        return new Promise((resolve, reject) => {
          const cbName = 'otd_cb_' + Math.random().toString(36).slice(2);
          let finished = false;
          let script = null;
          const cleanup = () => {
            try { delete window[cbName]; } catch {}
            if (script && script.parentNode) script.parentNode.removeChild(script);
          };
          const finish = (fn, val) => {
            if (finished) return;
            finished = true;
            cleanup();
            fn(val);
          };
          window[cbName] = (payload) => {
            try {
              // allorigins wraps response in { contents: "<raw text>", status: {...} }
              const txt = typeof payload === 'string' ? payload : (payload && payload.contents) || '';
              const data = JSON.parse(txt);
              finish(resolve, data);
            } catch (e) {
              finish(reject, new Error('JSONP decode error'));
            }
          };
          // Use allorigins JSONP to fetch target and return raw text
          const jsonpUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}&callback=${cbName}`;
          script = document.createElement('script');
          script.src = jsonpUrl;
          script.onerror = () => finish(reject, new Error('JSONP script load error'));
          document.head.appendChild(script);
          // Safety timeout (10s)
          setTimeout(() => finish(reject, new Error('JSONP timeout')), 10000);
        });
      }
  
      for (let i = 0; i < latlngs.length; i += BATCH_SIZE) {
        const batch = latlngs.slice(i, i + BATCH_SIZE);
        const locations = batch.map(([lat, lon]) => `${lat.toFixed(6)},${lon.toFixed(6)}`).join('|');
        // Do not duplicate dataset param; base endpoint already includes dataset path.
        const directUrl = `${OPENTOPODATA_ENDPOINT}?locations=${encodeURIComponent(locations)}`;
  
        let got = null;
        try {
          // 1) Try via multiple proxies first to bypass CORS locally
          let lastProxyErr = null;
          for (const proxy of CORS_JSON_PROXIES) {
            try {
              const proxiedUrl = proxy.mode === 'param'
                ? (proxy.value + encodeURIComponent(directUrl))
                : (proxy.value + directUrl); // prefix mode
              const data = await fetchJson(proxiedUrl);
              if (data && data.status === 'OK' && Array.isArray(data.results)) {
                got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
                break;
              }
              lastProxyErr = new Error('Proxy returned invalid payload');
            } catch (e) {
              lastProxyErr = e;
            }
          }
          if (!got) throw lastProxyErr || new Error('All proxies failed');
        } catch (proxyErr) {
          try {
            // 2) Try direct without proxy
            const data = await fetchJson(directUrl);
            if (!data || data.status !== 'OK' || !Array.isArray(data.results)) throw new Error('Invalid payload');
            got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
          } catch (directErr) {
            try {
              // 3) JSONP last resort
              const data = await fetchViaJsonp(directUrl);
              if (!data || data.status !== 'OK' || !Array.isArray(data.results)) throw new Error('JSONP invalid payload');
              got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
            } catch (jsonpErr) {
              console.warn('Elevation fetch failed via proxies, direct, and JSONP. Using flat elevation for this batch.', proxyErr, directErr, jsonpErr);
              got = batch.map(() => 0);
            }
          }
        }
        elevations.push(...got);
      }
      return elevations;
    }

    // Compute cumulative distance in feet along polyline of [lat, lon] using simple haversine
    function cumulativeDistancesFt(latlngs) {
      const R = 6371000; // meters
      const toRad = d => d * Math.PI / 180;
      const dists = [0];
      let cum = 0;
      for (let i = 1; i < latlngs.length; i++) {
        const [lat1, lon1] = latlngs[i-1];
        const [lat2, lon2] = latlngs[i];
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const meters = R * c;
        const feet = meters * 3.28084;
        cum += feet;
        dists.push(cum);
      }
      return dists;
    }

    // Automatic midline pump placement (reactive baseline)
    function placeMidlinePumps(distFt, elevFt, sourcePsi, midlinePsi, minSuctionPsi, psiLossPer100) {
      const lossPerFt = psiLossPer100 / 100.0;
      const pumps = [];
      let currentPressure = sourcePsi;
      const HORIZON = 10;

      for (let i = 0; i < distFt.length - 1; i++) {
        let lookAheadPressure = currentPressure;
        let needsPump = false;

        for (let j = i + 1; j < Math.min(i + 1 + HORIZON, distFt.length); j++) {
          const segLenLA = distFt[j] - distFt[j - 1];
          const dhFtLA = elevFt[j] - elevFt[j - 1];
          const elevDeltaPsiLA = -dhFtLA * PSI_PER_FOOT_WATER;
          const frictionPsiLA = lossPerFt * segLenLA;
          lookAheadPressure = lookAheadPressure + elevDeltaPsiLA - frictionPsiLA;

          if (lookAheadPressure < minSuctionPsi) { needsPump = true; break; }
          if (lookAheadPressure > (minSuctionPsi + 20)) { break; }
        }

        if (needsPump && (i > 0 || currentPressure < minSuctionPsi)) {
          pumps.push({ index: i, distanceFt: distFt[i], pressureBefore: currentPressure, discharge: midlinePsi });
          currentPressure = midlinePsi;
        }

        const segLen = distFt[i + 1] - distFt[i];
        const dhFt = elevFt[i + 1] - elevFt[i];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        currentPressure = currentPressure + elevDeltaPsi - frictionPsi;
      }

      return { pumps, finalPressure: currentPressure };
    }

    // Improved automatic midline pump placement algorithm (optimization-based, with anti-clustering)
    function placeMidlinePumpsOptimized(distFt, elevFt, sourcePsi, midlinePsi, minSuctionPsi, psiLossPer100) {
      const lossPerFt = psiLossPer100 / 100.0;
      const pumps = [];
      const MIN_PUMP_SPACING_FT = 1200; // enforce minimum spacing to avoid clusters
      const MAX_PUMPS_SAFETY = Math.max(3, Math.ceil((distFt[distFt.length-1] || 0) / 6000)); // ~1 per 6k ft cap
      const MAX_DISCHARGE = 120;

      // Dynamic discharge considering both upcoming climbs and nearby valleys
      function calculateOptimalDischarge(startIdx, distFt, elevFt, midlinePsi) {
        const lookAheadDist = 15840; // 3 miles
        const currentDist = distFt[startIdx];
        let maxElevationAhead = elevFt[startIdx];
        let minElevationAhead = elevFt[startIdx];

        for (let i = startIdx; i < distFt.length && (distFt[i] - currentDist) < lookAheadDist; i++) {
          maxElevationAhead = Math.max(maxElevationAhead, elevFt[i]);
          minElevationAhead = Math.min(minElevationAhead, elevFt[i]);
        }

        const uphillBoost = Math.max(0, (maxElevationAhead - elevFt[startIdx]) * PSI_PER_FOOT_WATER);
        const downhillRelief = Math.max(0, (elevFt[startIdx] - minElevationAhead) * PSI_PER_FOOT_WATER);
        const elevationBoostNeeded = Math.max(0, uphillBoost - 0.5 * downhillRelief);

        const baseDischarge = midlinePsi;
        const dynamicDischarge = Math.max(baseDischarge, baseDischarge + elevationBoostNeeded + 8);
        return Math.min(dynamicDischarge, MAX_DISCHARGE);
      }

      // Longer-horizon placement search with spacing-aware scoring
      function findOptimalPumpDistance(startIdx, startPressure, distFt, elevFt, minSuctionPsi, lossPerFt) {
        const EXTENDED_HORIZON = Math.min(300, distFt.length - startIdx - 1);
        const COMFORT_MARGIN = 6;

        let pressure = startPressure;
        let bestPlacement = null;
        let lowestPressure = startPressure;
        let lowestPressureIdx = startIdx;

        for (let i = startIdx + 1; i < Math.min(startIdx + EXTENDED_HORIZON, distFt.length); i++) {
          const segLen = distFt[i] - distFt[i - 1];
          const dhFt = elevFt[i] - elevFt[i - 1];
          const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
          const frictionPsi = lossPerFt * segLen;

          pressure = pressure + elevDeltaPsi - frictionPsi;

          if (pressure < lowestPressure) { lowestPressure = pressure; lowestPressureIdx = i; }

          if (pressure < (minSuctionPsi + COMFORT_MARGIN)) {
            const slopeHere = i > 0 ? (elevFt[i] - elevFt[i-1]) / Math.max(1,(distFt[i] - distFt[i-1])) : 0;
            const slopeAhead = i < elevFt.length - 1 ? (elevFt[i+1] - elevFt[i]) / Math.max(1,(distFt[i+1] - distFt[i])) : 0;

            // spacing penalty if too close to the last selected pump
            const spacingPenalty =
              pumps.length ? Math.max(0, (MIN_PUMP_SPACING_FT - (distFt[i] - pumps[pumps.length-1].distanceFt))) / MIN_PUMP_SPACING_FT : 0;

            // prefer bottoms/flat, penalize upcoming uphill and spacing violation
            const locationScore = -Math.abs(slopeHere) - Math.max(0, slopeAhead * 120) - spacingPenalty * 2;

            if (!bestPlacement || locationScore > bestPlacement.score) {
              bestPlacement = { index: i, pressure: pressure, score: locationScore, distance: distFt[i] };
            }
          }

          if (pressure < minSuctionPsi) { break; }
        }

        return bestPlacement || { index: lowestPressureIdx, pressure: lowestPressure, distance: distFt[lowestPressureIdx] };
      }

      let currentPressure = sourcePsi;
      let currentIdx = 0;

      let guard = 0, GUARD_MAX = distFt.length * 3;

      while (currentIdx < distFt.length - 1 && guard++ < GUARD_MAX) {
        if (pumps.length >= MAX_PUMPS_SAFETY) break;

        const placement = findOptimalPumpDistance(currentIdx, currentPressure, distFt, elevFt, minSuctionPsi, lossPerFt);

        // If placement ends up too close to the last pump, advance without adding a new pump to avoid clustering
        if (pumps.length > 0) {
          const last = pumps[pumps.length - 1];
          const placementDist = placement.distance ?? distFt[placement.index];
          if ((placementDist - last.distanceFt) < MIN_PUMP_SPACING_FT) {
            currentIdx = Math.max(placement.index, currentIdx + 1);
            currentPressure = placement.pressure;
            continue;
          }
        }

        if (placement.index <= currentIdx + 1) {
          const idx = Math.min(currentIdx + 1, distFt.length - 1);
          const discharge = calculateOptimalDischarge(idx, distFt, elevFt, midlinePsi);
          pumps.push({ index: idx, distanceFt: distFt[idx], pressureBefore: currentPressure, discharge });
          currentPressure = discharge;
          currentIdx = idx;
          continue;
        }

        if (placement.pressure < minSuctionPsi + 2) {
          // compute pressure at proposed location
          let pressureAtPump = currentPressure;
          for (let i = currentIdx + 1; i <= placement.index; i++) {
            const segLen = distFt[i] - distFt[i - 1];
            const dhFt = elevFt[i] - elevFt[i - 1];
            const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
            const frictionPsi = lossPerFt * segLen;
            pressureAtPump = pressureAtPump + elevDeltaPsi - frictionPsi;
          }

          // adjust placement forward if spacing would be violated
          let placeIdx = placement.index;
          if (pumps.length > 0) {
            const last = pumps[pumps.length - 1];
            while (placeIdx < distFt.length - 1 && (distFt[placeIdx] - last.distanceFt) < MIN_PUMP_SPACING_FT) {
              placeIdx++;
            }
          }

          const discharge = calculateOptimalDischarge(placeIdx, distFt, elevFt, midlinePsi);

          pumps.push({ index: placeIdx, distanceFt: distFt[placeIdx], pressureBefore: pressureAtPump, discharge });
          currentPressure = discharge;
          currentIdx = placeIdx;
        } else {
          currentIdx = placement.index;
          currentPressure = placement.pressure;
        }
      }

      let finalPressure = currentPressure;
      for (let i = currentIdx + 1; i < distFt.length; i++) {
        const segLen = distFt[i] - distFt[i - 1];
        const dhFt = elevFt[i] - elevFt[i - 1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        finalPressure = finalPressure + elevDeltaPsi - frictionPsi;
      }

      return { pumps, finalPressure };
    }

    // Alternative approach: Minimum pump count optimization
    function placeMidlinePumpsMinimized(distFt, elevFt, sourcePsi, midlinePsi, minSuctionPsi, psiLossPer100) {
      const lossPerFt = psiLossPer100 / 100.0;

      function canReachEnd(startIdx, startPressure, targetIdx) {
        let pressure = startPressure;
        for (let i = startIdx + 1; i <= targetIdx; i++) {
          const segLen = distFt[i] - distFt[i - 1];
          const dhFt = elevFt[i] - elevFt[i - 1];
          const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
          const frictionPsi = lossPerFt * segLen;
          pressure = pressure + elevDeltaPsi - frictionPsi;
          if (pressure < minSuctionPsi) {
            return { canReach: false, failIndex: i, pressure: pressure };
          }
        }
        return { canReach: true, finalPressure: pressure };
      }

      const professionalDischarge = Math.min(120, midlinePsi * 1.1);

      const pumps = [];
      let currentIdx = 0;
      let currentPressure = sourcePsi;

      let guard = 0, GUARD_MAX = distFt.length * 3;

      while (currentIdx < distFt.length - 1 && guard++ < GUARD_MAX) {
        const result = canReachEnd(currentIdx, currentPressure, distFt.length - 1);

        if (result.canReach) {
          return { pumps, finalPressure: result.finalPressure };
        }

        let pumpIndex = Math.max(1, result.failIndex - 1);

        const searchStart = Math.max(currentIdx + 1, pumpIndex - 10);
        const searchEnd = Math.min(distFt.length - 1, pumpIndex + 5);

        let bestPumpIndex = pumpIndex;
        let bestScore = -Infinity;

        for (let testIdx = searchStart; testIdx <= searchEnd; testIdx++) {
          const testResult = canReachEnd(currentIdx, currentPressure, testIdx);
          if (testResult.canReach && testResult.finalPressure >= minSuctionPsi) {
            const distanceCovered = distFt[testIdx] - distFt[currentIdx];
            const pressureMargin = testResult.finalPressure - minSuctionPsi;
            const score = distanceCovered + pressureMargin * 100;
            if (score > bestScore) { bestScore = score; bestPumpIndex = testIdx; }
          }
        }

        let pressureAtPump = currentPressure;
        for (let i = currentIdx + 1; i <= bestPumpIndex; i++) {
          const segLen = distFt[i] - distFt[i - 1];
          const dhFt = elevFt[i] - elevFt[i - 1];
          const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
          const frictionPsi = lossPerFt * segLen;
          pressureAtPump = pressureAtPump + elevDeltaPsi - frictionPsi;
        }

        pumps.push({
          index: bestPumpIndex,
          distanceFt: distFt[bestPumpIndex],
          pressureBefore: pressureAtPump,
          discharge: professionalDischarge
        });

        currentPressure = professionalDischarge;
        currentIdx = bestPumpIndex;
      }

      let finalPressure = currentPressure;
      for (let i = currentIdx + 1; i < distFt.length; i++) {
        const segLen = distFt[i] - distFt[i - 1];
        const dhFt = elevFt[i] - elevFt[i - 1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        finalPressure = finalPressure + elevDeltaPsi - frictionPsi;
      }

      return { pumps, finalPressure };
    }

    // Build pressure profile including placed pumps (clear boost visualization)
    // Returns an object with distances and pressures arrays aligned 1:1 for Chart.js
    function buildProfileWithPumps(distFt, elevFt, sourcePsi, pumps, psiLossPer100) {
      const lossPerFt = psiLossPer100 / 100.0;
      const outDistances = [];
      const outPressures = [];
      let p = sourcePsi;
      let pumpIdx = 0;

      // Seed first point
      outDistances.push(distFt[0]);
      outPressures.push(p);

      for (let i = 1; i < distFt.length; i++) {
        // Check if a pump exists exactly at index i
        if (pumpIdx < pumps.length && pumps[pumpIdx].index === i) {
          // Add point just before pump (current pressure at this location)
          outDistances.push(distFt[i]);
          outPressures.push(p);
          
          // Add point just after pump (boosted pressure at same location)
          p = pumps[pumpIdx].discharge;
          outDistances.push(distFt[i]);
          outPressures.push(p);
          pumpIdx++;
        }

        // Calculate pressure change through current segment
        const segLen = distFt[i] - distFt[i - 1];
        const dhFt = elevFt[i] - elevFt[i - 1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        p = p + elevDeltaPsi - frictionPsi;

        // Add end point of segment
        outDistances.push(distFt[i]);
        outPressures.push(p);
      }
      
      return { distances: outDistances, pressures: outPressures };
    }

    // --- DOM refs ---
    const elFlowBpm = document.getElementById('flow-bpm');
    const elHoseSize = document.getElementById('hose-size');
    const elSourcePsi = document.getElementById('source-psi');
    const elMidlinePsi = document.getElementById('midline-psi');
    const elMinSuction = document.getElementById('min-suction-psi');
    const elMaxHose = document.getElementById('max-hose-psi');
    const elReqOutlet = document.getElementById('req-outlet-psi');
    const elPlacementStrategy = document.getElementById('placement-strategy');

    const lossRadios = document.querySelectorAll('input[name="loss-method"]');
    const elManualWrap = document.getElementById('manual-loss-wrap');
    const elManualPsi100 = document.getElementById('manual-loss-psi100');

    const elKmlFile = document.getElementById('kml-file');
    const pathDirRadios = document.querySelectorAll('input[name="path-dir"]');

    const elRun = document.getElementById('run-calc');
    const elReset = document.getElementById('reset-form');

    const elMapSection = document.getElementById('map-section');
    const elResults = document.getElementById('results-section');
    const elOutDist = document.getElementById('out-total-dist');
    const elOutUsedLoss = document.getElementById('out-used-loss');
    const elOutFinalPsi = document.getElementById('out-final-psi');
    const elOutOutletMet = document.getElementById('out-outlet-met');
    const elOutPumpCount = document.getElementById('out-pump-count');
    const elWarningsWrap = document.getElementById('warnings-wrap');
    const elWarningsList = document.getElementById('warnings-list');

    const elChartSection = document.getElementById('chart-section');
    const chartCanvas = document.getElementById('pressureChart');

    let chartInstance = null;
    let mapInstance = null;
    let pathLayer = null;
    let pumpLayer = null;

    function currentLossMethod() {
      for (const r of lossRadios) if (r.checked) return r.value;
      return 'lookup';
    }
    function currentPathDir() {
      for (const r of pathDirRadios) if (r.checked) return r.value;
      return 'source_to_dest';
    }
    function updateManualVisibility() {
      elManualWrap.style.display = currentLossMethod() === 'manual' ? 'block' : 'none';
    }
    lossRadios.forEach(r => r.addEventListener('change', updateManualVisibility));
    updateManualVisibility();

    function resetForm() {
      elFlowBpm.value = '50';
      elHoseSize.value = '16';
      elSourcePsi.value = '100';
      elMidlinePsi.value = '80';
      elMinSuction.value = '20';
      elMaxHose.value = '150';
      elReqOutlet.value = '20';
      document.querySelector('input[name="loss-method"][value="lookup"]').checked = true;
      elManualPsi100.value = '0';
      updateManualVisibility();
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';
      elMapSection.style.display = 'none';
      if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
      if (mapInstance) {
        try { mapInstance.remove(); } catch{}
        mapInstance = null; pathLayer = null; pumpLayer = null;
      }
      elKmlFile.value = '';
    }
    elReset.addEventListener('click', resetForm);

    function ensureMap() {
      if (mapInstance) return mapInstance;
      elMapSection.style.display = 'block';
      mapInstance = L.map('modeler-map', { zoomControl: true }).setView([35.5, -98.5], 6);

      // Base layers
      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap contributors'
      });

      // Esri World Imagery (satellite)
      const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Tiles © Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
      });

      // Esri World Boundaries and Places (labels) to create a hybrid overlay
      const esriLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Labels © Esri'
      });

      // Create a hybrid group (satellite + labels)
      const hybrid = L.layerGroup([esriSat, esriLabels]);

      // Add default base (OSM)
      osm.addTo(mapInstance);

      // Pump layer lives above basemap(s)
      pumpLayer = L.layerGroup().addTo(mapInstance);

      // Layer control to switch between basemaps
      const baseMaps = {
        'Streets (OSM)': osm,
        'Satellite (Esri World Imagery)': esriSat,
        'Hybrid (Satellite + Labels)': hybrid
      };
      L.control.layers(baseMaps, null, { collapsed: true }).addTo(mapInstance);

      return mapInstance;
    }

    // Small status helper to report path length and points
    function updatePathStatus(latlngs, totalFt) {
      const el = document.getElementById('path-status');
      if (!el) return;
      if (!latlngs || !latlngs.length) { el.style.display = 'none'; return; }
      el.style.display = 'block';
      el.textContent = `Loaded ${latlngs.length} points • Total distance ~ ${totalFt.toFixed(0)} ft`;
    }

    function renderPathOnMap(latlngs, pumps) {
      const map = ensureMap();
      if (pathLayer) { map.removeLayer(pathLayer); pathLayer = null; }
      pumpLayer.clearLayers();

      if (latlngs && latlngs.length > 1) {
        pathLayer = L.polyline(latlngs, { color: 'red', weight: 5 }).addTo(map);
        map.fitBounds(pathLayer.getBounds().pad(0.1));
      }
      if (Array.isArray(pumps)) {
        pumps.forEach((p, idx) => {
          const i = p.index;
          if (i != null && i >= 0 && i < latlngs.length) {
            const [lat, lon] = latlngs[i];
            const marker = L.marker([lat, lon]).bindPopup(
              `<b>Midline Pump #${idx+1}</b><br>Distance: ${p.distanceFt.toFixed(0)} ft<br>` +
              `Inlet: ${p.pressureBefore.toFixed(1)} PSI<br>` +
              `Discharge: ${p.discharge.toFixed(1)} PSI`
            );
            pumpLayer.addLayer(marker);
          }
        });
      }
    }

    function renderChart(distances, pressures, minSuction) {
      if (chartInstance) { 
        chartInstance.destroy(); 
        chartInstance = null; 
      }
      
      // Ensure we have valid data arrays
      if (!Array.isArray(distances) || !Array.isArray(pressures) || distances.length === 0 || pressures.length === 0) {
        console.warn('Invalid chart data:', { distances, pressures });
        return;
      }
      
      // Ensure arrays are same length
      const minLength = Math.min(distances.length, pressures.length);
      const chartDistances = distances.slice(0, minLength);
      const chartPressures = pressures.slice(0, minLength);
      
      // Create labels and min suction line
      const labels = chartDistances.map(d => Number(d).toFixed(0));
      const minSuctionLine = new Array(chartDistances.length).fill(Number(minSuction));
      
      console.log('Chart data:', { 
        labels: labels.length, 
        pressures: chartPressures.length, 
        minSuction: minSuctionLine.length 
      });
      
      chartInstance = new Chart(chartCanvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Pressure (PSI)',
              data: chartPressures,
              borderColor: '#0b5fff',
              backgroundColor: 'rgba(11,95,255,0.10)',
              pointRadius: 1.5,
              tension: 0,
              fill: false
            },
            {
              label: 'Min Inlet (PSI)',
              data: minSuctionLine,
              borderColor: '#ffc107',
              borderDash: [6,6],
              pointRadius: 0,
              tension: 0,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          scales: {
            x: { 
              title: { display: true, text: 'Distance (ft)' },
              type: 'category'
            },
            y: { 
              title: { display: true, text: 'Pressure (PSI)' }, 
              beginAtZero: true 
            }
          },
          plugins: {
            legend: {
              display: true
            }
          }
        }
      });
    }

    async function readKmlOrKmz(file) {
      const name = (file?.name || '').toLowerCase();
      if (name.endsWith('.kml')) {
        const text = await file.text();
        return text;
      } else if (name.endsWith('.kmz')) {
        throw new Error('Unsupported file type: KMZ is not supported. Please upload a .kml file.');
      } else {
        throw new Error('Unsupported file type. Please upload a .kml file.');
      }
    }

    function collectWarningsInto(list, msg) {
      list.push(msg);
    }

    function determinePsiLossPer100(flowBpm, hoseIn, lossMethod, manualVal, warnings) {
      let usedPsiLossPer100 = 0;
      if (lossMethod === 'manual') {
        if (!(manualVal >= 0)) {
          collectWarningsInto(warnings, 'Manual PSI loss per 100 ft must be >= 0.');
          usedPsiLossPer100 = 0;
        } else {
          usedPsiLossPer100 = manualVal;
        }
      } else {
        const gpm = bpmToGpm(flowBpm);
        const headLoss12 = lookupHeadLoss12in(gpm);
        if (headLoss12 == null) {
          collectWarningsInto(warnings, 'Flow is outside the 12" lookup table range; cannot interpolate.');
          usedPsiLossPer100 = 0;
        } else {
          const scaledHeadLoss = scaleHeadLossByDiameter(headLoss12, hoseIn);
          usedPsiLossPer100 = headLossFtToPsi(scaledHeadLoss);
        }
      }
      return usedPsiLossPer100;
    }

    function renderResults(totalFt, usedPsiLossPer100, finalPressure, reqOutlet, pumpCount, warnings, distances, pressures, minSuction) {
      elResults.style.display = 'block';
      elOutDist.textContent = totalFt.toFixed(1);
      elOutUsedLoss.textContent = usedPsiLossPer100.toFixed(4) + ' PSI/100ft';
      elOutFinalPsi.textContent = finalPressure.toFixed(1);
      // Ensure we only count midline pumps, not the source pump (source is not included in auto.pumps)
      const midlineCount = Math.max(0, Number(pumpCount) || 0);
      elOutPumpCount.textContent = String(midlineCount);
      const met = finalPressure >= reqOutlet;
      elOutOutletMet.innerHTML = met
        ? '<span class="badge good">Yes</span>'
        : '<span class="badge bad">No</span>';

      if (warnings.length) {
        elWarningsWrap.style.display = 'block';
        elWarningsList.innerHTML = '';
        warnings.forEach(w => {
          const li = document.createElement('li');
          li.textContent = w;
          elWarningsList.appendChild(li);
        });
      } else {
        elWarningsWrap.style.display = 'none';
        elWarningsList.innerHTML = '';
      }

      elChartSection.style.display = 'block';
      renderChart(distances, pressures, minSuction);

      // Enable report button now that we have a successful run
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = false;

      // Store the latest run dataset on window for report generation
      window.__modelerLastRun = {
        flowBpm: Number(elFlowBpm.value),
        hoseIn: Number(elHoseSize.value),
        sourcePsi: Number(elSourcePsi.value),
        midlinePsi: Number(elMidlinePsi.value),
        minSuction: Number(elMinSuction.value),
        maxHose: Number(elMaxHose.value),
        reqOutlet: Number(elReqOutlet.value),
        lossMethod: currentLossMethod(),
        manualPsi100: Number(elManualPsi100.value),
        placementStrategy: elPlacementStrategy?.value || 'reactive',
        pathDir: currentPathDir(),
        results: {
          totalFt,
          usedPsiLossPer100,
          finalPressure,
          pumpCount,
          warnings: [...warnings]
        },
        profile: { distances, pressures },
        pumpsSummary: (window.__lastPumps || [])
      };
    }

    async function runCalc() {
      const flowBpm = Number(elFlowBpm.value);
      const hoseIn = Number(elHoseSize.value);
      const sourcePsi = Number(elSourcePsi.value);
      const midlinePsi = Number(elMidlinePsi.value);
      const minSuction = Number(elMinSuction.value);
      const maxHose = Number(elMaxHose.value);
      const reqOutlet = Number(elReqOutlet.value);
      const lossMethod = currentLossMethod();
      const manualPsi100 = Number(elManualPsi100.value);
      const pathDir = currentPathDir();
      const placementStrategy = (elPlacementStrategy?.value) || 'reactive';

      const warnings = [];
      if (!(flowBpm >= 0)) warnings.push('Flow rate (BPM) must be >= 0.');
      if (!(sourcePsi > 0)) warnings.push('Source discharge PSI must be > 0.');
      if (!(maxHose > 0)) warnings.push('Max allowable hose PSI must be > 0.');
      if (sourcePsi > maxHose) warnings.push(`Source discharge (${sourcePsi.toFixed(1)} PSI) exceeds hose max (${maxHose.toFixed(1)} PSI).`);

      // Determine friction loss
      const usedPsiLossPer100 = determinePsiLossPer100(flowBpm, hoseIn, lossMethod, manualPsi100, warnings);

      // Path handling
      let latlngs = [];
      let usingKml = false;
      const file = elKmlFile.files && elKmlFile.files[0] ? elKmlFile.files[0] : null;
      if (file) {
        usingKml = true;
        let kmlText = '';
        try {
          kmlText = await readKmlOrKmz(file);
        } catch (e) {
          warnings.push(`KML/KMZ error: ${e.message}`);
        }
        if (kmlText) {
          const parsed = parseKmlLineStringToLatLngs(kmlText);
          if (!parsed.length) warnings.push('No LineString coordinates found in KML.');
          latlngs = parsed;
        }
      }

      // If no KML path provided, block calculation silently and prompt user in path section
      if (!latlngs.length) {
        const reportBtn = document.getElementById('generate-report');
        if (reportBtn) reportBtn.disabled = true;
        delete window.__modelerLastRun;

        elMapSection.style.display = 'none';
        elResults.style.display = 'none';
        elChartSection.style.display = 'none';
        elWarningsWrap.style.display = 'none';
        elWarningsList.innerHTML = '';

        const pathStatus = document.getElementById('path-status');
        if (pathStatus) {
          pathStatus.style.display = 'block';
          pathStatus.textContent = 'No path loaded. Upload a KML to run.';
        }
        return;
      }

      // If we have KML path, optionally reverse
      if (pathDir === 'dest_to_source') latlngs.reverse();

      // Downsample if needed
      const dsLatLngs = downsampleLatLngs(latlngs, MAX_POINTS);

      // Elevations
      let elevationsM = [];
      try {
        elevationsM = await fetchElevationsOpenTopo(dsLatLngs);
      } catch (e) {
        warnings.push(`Elevation fetch failed: ${e.message}. Proceeding with flat elevation.`);
        elevationsM = dsLatLngs.map(() => 0);
      }
      const elevationsFt = elevationsM.map(m => m * 3.28084);

      // Distances
      const distFt = cumulativeDistancesFt(dsLatLngs);
      const totalFt = distFt[distFt.length - 1] || 0;

      // Auto midline pump placement (strategy switch)
      let auto;
      if (placementStrategy === 'optimized') {
        auto = placeMidlinePumpsOptimized(distFt, elevationsFt, sourcePsi, midlinePsi, minSuction, usedPsiLossPer100);
      } else if (placementStrategy === 'minimized') {
        auto = placeMidlinePumpsMinimized(distFt, elevationsFt, sourcePsi, midlinePsi, minSuction, usedPsiLossPer100);
      } else {
        auto = placeMidlinePumps(distFt, elevationsFt, sourcePsi, midlinePsi, minSuction, usedPsiLossPer100);
      }

      // Path status line
      updatePathStatus(dsLatLngs, distFt[distFt.length - 1] || 0);

      // Build final pressure profile with placed pumps
      const prof = buildProfileWithPumps(distFt, elevationsFt, sourcePsi, auto.pumps, usedPsiLossPer100);

      const distancesForChart = prof.distances || [];
      const pressures = prof.pressures || [];

      // Checks
      if (auto.finalPressure < reqOutlet) {
        warnings.push(`Final outlet pressure (${auto.finalPressure.toFixed(1)} PSI) is below required minimum (${reqOutlet.toFixed(1)} PSI).`);
      }
      if (pressures.some(p => p > maxHose)) {
        warnings.push('Calculated pressure exceeds the maximum hose rating somewhere along the line.');
      }

      // Map render
      renderPathOnMap(dsLatLngs, auto.pumps);
      // Keep pumps for report details
      window.__lastPumps = Array.isArray(auto.pumps) ? auto.pumps.map(p => ({...p})) : [];

      // Results + chart
      renderResults(totalFt, usedPsiLossPer100, auto.finalPressure, reqOutlet, auto.pumps.length, warnings, distancesForChart, pressures, minSuction);
    }

    document.getElementById('run-calc').addEventListener('click', runCalc);

    // --- Printable Report (new tab) ---
    function milesFromFeet(ft) { return (Number(ft||0) / 5280); }
    function fmt(n, digits=1) { return isFinite(n) ? Number(n).toFixed(digits) : '—'; }

    function buildReportHtml(state) {
      const dt = new Date();
      const dateStr = dt.toLocaleDateString() + ' ' + dt.toLocaleTimeString();
      const totalMi = milesFromFeet(state.results.totalFt);
      const usedLoss = state.results.usedPsiLossPer100;

      // Build per-pump rows
      const pumpRows = (state.pumpsSummary || []).map((p, i) => {
        const distMi = milesFromFeet(p.distanceFt);
        return `
          <tr>
            <td>#${i+1}</td>
            <td>${fmt(distMi, 2)} mi</td>
            <td>${fmt(p.pressureBefore, 1)} PSI</td>
            <td>${fmt(p.discharge, 1)} PSI</td>
          </tr>`;
      }).join('') || `<tr><td colspan="4">No midline pumps placed</td></tr>`;

      // Inline CSS for print
      const styles = `
        <style>
          @page { size: Letter; margin: 0.6in; }
          body { font-family: 'ISOCPEUR', Arial, sans-serif; color:#222; }
          .hdr { text-align:center; margin-bottom:8px; }
          .title { font-size:22px; font-weight:700; margin:8px 0 2px; }
          .subtitle { font-size:12px; color:#666; }
          .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 6px 18px; margin: 14px 0; }
          .kv { display:flex; gap:6px; font-size:13px; }
          .kv .k { width: 56%; color:#444; }
          .kv .v { flex:1; text-align:right; }
          .section-h { font-size:16px; margin: 12px 0 6px; border-bottom:1px solid #e5e5e5; padding-bottom:4px; }
          table { width:100%; border-collapse: collapse; font-size:13px; }
          th, td { border: 1px solid #e5e5e5; padding:6px 8px; text-align:left; }
          th { background:#f8f8ff; }
          .center { text-align:center; }
          .chart { width:100%; height:300px; margin-top:8px; border:1px solid #eee; }
          .footer { text-align:center; font-size:11px; color:#777; margin-top:10px; }
          .badge { display:inline-block; padding:2px 8px; border-radius:12px; color:#fff; font-size:11px; }
          .good { background:#198754; }
          .bad { background:#dc3545; }
        </style>
      `;

      // We embed profile arrays to render a simple SVG chart (no external libs)
      const distances = state.profile.distances || [];
      const pressures = state.profile.pressures || [];
      const svg = buildSimplePressureSvg(distances, pressures, state.minSuction);

      const outletMet = state.results.finalPressure >= state.reqOutlet;
      return `
        <!doctype html>
        <html>
          <head><meta charset="utf-8">${styles}<title>Layflat Line Report</title></head>
          <body>
            <div class="hdr">
              <div class="title">Line Profile Report</div>
              <div class="subtitle">Generated ${dateStr}</div>
            </div>

            <div class="grid">
              <div class="kv"><div class="k">Desired Rate</div><div class="v">${fmt(state.flowBpm,0)} BPM</div></div>
              <div class="kv"><div class="k">Distance</div><div class="v">${fmt(totalMi,2)} miles</div></div>

              <div class="kv"><div class="k">Hose</div><div class="v">${fmt(state.hoseIn,0)} in</div></div>
              <div class="kv"><div class="k">Friction Loss</div><div class="v">${fmt(usedLoss,4)} PSI/100 ft</div></div>

              <div class="kv"><div class="k">Max Hose PSI</div><div class="v">${fmt(state.maxHose,0)} PSI</div></div>
              <div class="kv"><div class="k">Placement Strategy</div><div class="v">${state.placementStrategy}</div></div>

              <div class="kv"><div class="k">Source Discharge</div><div class="v">${fmt(state.sourcePsi,1)} PSI</div></div>
              <div class="kv"><div class="k">Midline Discharge Setpoint</div><div class="v">${fmt(state.midlinePsi,1)} PSI</div></div>

              <div class="kv"><div class="k">Min Inlet (Suction)</div><div class="v">${fmt(state.minSuction,1)} PSI</div></div>
              <div class="kv"><div class="k">Desired Min Outlet</div><div class="v">${fmt(state.reqOutlet,1)} PSI</div></div>

              <div class="kv"><div class="k">Final Outlet Pressure</div><div class="v">${fmt(state.results.finalPressure,1)} PSI</div></div>
              <div class="kv"><div class="k">Outlet Met?</div><div class="v"><span class="badge ${outletMet?'good':'bad'}">${outletMet?'Yes':'No'}</span></div></div>

              <div class="kv"><div class="k">Midline Pumps Placed</div><div class="v">${(state.pumpsSummary||[]).length}</div></div>
              <div class="kv"><div class="k">Loss Method</div><div class="v">${state.lossMethod}</div></div>
            </div>

            <div class="section-h">Midline Pumps</div>
            <table>
              <thead><tr><th>#</th><th>Distance</th><th>Inlet PSI</th><th>Discharge PSI</th></tr></thead>
              <tbody>${pumpRows}</tbody>
            </table>

            <div class="section-h">Pressure Profile</div>
            <div class="chart">${svg}</div>

            ${state.results.warnings && state.results.warnings.length ? `
              <div class="section-h">Warnings</div>
              <ul>${state.results.warnings.map(w => `<li>${w}</li>`).join('')}</ul>
            ` : ''}

            <div class="footer">Print or Save as PDF using your browser</div>
          </body>
        </html>
      `;
    }

    // Render a basic SVG pressure chart without external libraries
    function buildSimplePressureSvg(distances, pressures, minLine) {
      if (!Array.isArray(distances) || !Array.isArray(pressures) || distances.length < 2) {
        return '<div class="center" style="padding:20px;color:#666;">No chart data</div>';
      }
      const width = 900, height = 300, padL = 50, padR = 10, padT = 10, padB = 30;
      const minX = distances[0], maxX = distances[distances.length-1];
      let minY = Math.min(...pressures);
      let maxY = Math.max(...pressures, minLine||0);
      if (!isFinite(minY) || !isFinite(maxY) || minY === maxY) { minY = 0; maxY = 1; }
      const sx = x => padL + (x - minX) * (width - padL - padR) / (maxX - minX || 1);
      const sy = y => height - padB - (y - minY) * (height - padT - padB) / (maxY - minY || 1);

      // Build polyline points
      const pts = distances.map((d,i) => `${sx(d)},${sy(pressures[i])}`).join(' ');

      // Min suction line
      const minYLine = isFinite(minLine) ? `
        <line x1="${sx(minX)}" y1="${sy(minLine)}" x2="${sx(maxX)}" y2="${sy(minLine)}"
              stroke="#ffc107" stroke-width="2" stroke-dasharray="6,6" />
      ` : '';

      return `
        <svg viewBox="0 0 ${width} ${height}" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
          <rect x="0" y="0" width="${width}" height="${height}" fill="white" />
          <!-- Axes -->
          <line x1="${padL}" y1="${padT}" x2="${padL}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <line x1="${padL}" y1="${height-padB}" x2="${width-padR}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <!-- Data -->
          ${minYLine}
          <polyline fill="none" stroke="#0b5fff" stroke-width="2" points="${pts}" />
        </svg>
      `;
    }

    function openReport() {
      const state = window.__modelerLastRun;
      if (!state) {
        alert('Run a calculation with a valid path before generating a report.');
        return;
      }
      const html = buildReportHtml(state);
      const w = window.open('', '_blank');
      if (!w) { alert('Popup blocked. Allow popups to view the report.'); return; }
      w.document.open();
      w.document.write(html);
      w.document.close();
      // Try to trigger print preview after load for convenience
      w.onload = () => { try { w.focus(); } catch {} };
    }

    const reportBtn = document.getElementById('generate-report');
    if (reportBtn) {
      reportBtn.addEventListener('click', openReport);
    }

    // --- Input-change mechanics: no auto-run; require explicit Run Calculation ---

    // Clear derived UI when inputs change to prevent reading stale values
    function clearDerivedUI() {
      // Hide previous results/chart until the next run completes
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';
      // Keep map section visible but clear pumps so user sees path without stale boosts
      if (pumpLayer) { try { pumpLayer.clearLayers(); } catch {} }
      // Disable report and clear last run to avoid stale report generation
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = true;
      delete window.__modelerLastRun;
    }

    // Whenever a user changes inputs that affect hydraulics, just clear derived UI (no auto run)
    const hydraulicInputs = [
      elFlowBpm, elHoseSize, elSourcePsi, elMidlinePsi,
      elMinSuction, elMaxHose, elReqOutlet, elManualPsi100, elPlacementStrategy
    ];
    hydraulicInputs.forEach(inp => {
      if (!inp) return;
      inp.addEventListener('input', () => { clearDerivedUI(); });
      inp.addEventListener('change', () => { clearDerivedUI(); });
    });

    // Friction loss method radios
    lossRadios.forEach(r => {
      r.addEventListener('change', () => { updateManualVisibility(); clearDerivedUI(); });
    });

    // Path direction radios (reverse path)
    pathDirRadios.forEach(r => {
      r.addEventListener('change', () => { clearDerivedUI(); });
    });

    // When a new KML/KMZ is selected, clear outputs; user must press Run Calculation
    elKmlFile.addEventListener('change', () => {
      // Clear everything visual so a new file doesn't mix with old output
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = true;
      delete window.__modelerLastRun;

      if (chartInstance) { try { chartInstance.destroy(); } catch {} chartInstance = null; }
      if (mapInstance) {
        // Remove old layers/instance to ensure a clean start
        try { mapInstance.remove(); } catch {}
        mapInstance = null; pathLayer = null; pumpLayer = null;
      }
    });

    // Remove previous auto-run blur handler: no-op now
  </script>
</body>
</html>