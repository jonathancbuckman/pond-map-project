<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Layflat Hydraulic Modeler</title>
  <link rel="stylesheet" href="css/style.css"/>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <!-- Leaflet CSS for map preview -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    /* Page-local styles for the modeler (kept minimal; reuses global font) */
    .modeler-wrap {
      max-width: 1000px;
      margin: 0 auto;
      padding: 12px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
    }
    .site-header {
      padding: 10px;
      border-bottom: 1px solid #e5e5e5;
      background: #fff;
      font-family: 'ISOCPEUR', Arial, sans-serif;
    }
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .field label {
      font-size: 13px;
    }
    .field input[type="number"], .field select, .field input[type="file"] {
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      background: #fff;
      color: #222;
    }
    .radio-row {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      font-size: 14px;
    }
    .section-card {
      background: #fff;
      border: 1px solid #e5e5e5;
      border-radius: 10px;
      padding: 14px;
      margin-top: 14px;
    }
    .section-card h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
    }
    .btn {
      display: inline-block;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #0b5fff;
      color: #fff;
      text-decoration: none;
      cursor: pointer;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      font-size: 14px;
      border-color: #084bd1;
    }
    .btn[disabled] {
      opacity: 0.65;
      cursor: not-allowed;
    }
    .btn.secondary {
      background: #f9f9f9;
      color: #333;
      border-color: #ddd;
    }
    .inline-help {
      font-size: 12px;
      color: #666;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .results-table th, .results-table td {
      border: 1px solid #e5e5e5;
      padding: 6px 8px;
    }
    .results-table th {
      background: #f8f8f8;
      text-align: left;
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      color: #fff;
    }
    .badge.good { background: #198754; }
    .badge.bad { background: #dc3545; }
    .warnings {
      margin: 8px 0 0 18px;
      color: #b58900;
    }
    .chart-box {
      position: relative;
      height: 320px;
      width: 100%;
    }
    /* Map preview box */
    #busy-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.75);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(1px);
    }
    .busy-card {
      background: #ffffff;
      border: 1px solid #e5e5e5;
      border-radius: 10px;
      padding: 14px 16px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
      font-family: 'ISOCPEUR', Arial, sans-serif;
      color: #333;
      min-width: 260px;
      text-align: center;
    }
    .spinner {
      width: 22px;
      height: 22px;
      border: 3px solid #cfd8ff;
      border-top-color: #0b5fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 10px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #modeler-map {
      height: 350px;
      width: 100%;
      border: 1px solid #e5e5e5;
      border-radius: 10px;
    }

    /* Manual Pump List layout */
    .manual-pump-list {
      display: grid;
      gap: 10px;
    }
    .manual-pump-row {
      display: grid;
      grid-template-columns: 1fr 1fr 280px auto;
      gap: 10px 12px;
      align-items: end;
      margin-bottom: 4px;
    }
    .mp-col--id,
    .mp-col--inlet {
      font-size: 14px;
      line-height: 1.3;
    }
    .mp-col--disch {
      display: grid;
      grid-template-columns: 110px 1fr;
      align-items: center;
      gap: 8px;
    }
    .mp-label {
      font-size: 12px;
      color: #666;
      margin: 0;
      text-align: right;
    }
    .mp-input {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      background: #fff;
      color: #222;
    }
    .mp-col--actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
    }

    /* Stack nicely on narrow screens */
    @media (max-width: 640px) {
      .manual-pump-row {
        grid-template-columns: 1fr 1fr;
      }
      .mp-col--actions {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body class="modeler-page">
  <header class="site-header" role="banner">
    <strong>Layflat Hydraulic Modeler</strong>
  </header>

  <main class="modeler-wrap" role="main">
    <!-- Introductory guidance -->
    <section class="section-card" style="background:#fcfcff;">
      <h3>How to use this tool</h3>
      <p class="inline-help" style="max-width:880px;">
        This calculator estimates pressure along a layflat hose route. You manually place midline booster pumps on the map and adjust their discharge setpoints to shape the pressure profile. KML only: upload a .kml file that contains a single simple LineString path. KMZ is not supported.
      </p>
      <ol class="inline-help" style="max-width:880px; margin-top:6px; padding-left:18px;">
        <li>Create a KML file containing one LineString that follows your hose path on the ground. You can draw this in Google Earth or other GIS tools.</li>
        <li>Upload the KML below. Choose the drawing direction so the path begins at your Source pump and ends at the Destination (or reverse if needed).</li>
        <li>Set your hydraulic inputs (flow, hose diameter, pressure limits). Choose how friction loss is determined (lookup vs manual).</li>
        <li>Click "Run Calculation". The map will display your path, and “Manual Pumps” mode will be enabled.</li>
        <li>Place manual midline pumps:
          <ul style="margin:6px 0 0 18px;">
            <li>Click along the red path to add a booster pump at that location.</li>
            <li>Drag a pump marker to move it along the path.</li>
            <li>Click a marker to delete it.</li>
            <li>Edit each pump’s “Discharge PSI” in the Manual Pumps panel; the profile updates immediately.</li>
          </ul>
        </li>
        <li>Review outputs:
          <ul style="margin:6px 0 0 18px;">
            <li>Map preview of your path and manually placed pumps.</li>
            <li>Pressure profile chart showing the impact of pump placement and discharge settings.</li>
            <li>Results summary including total distance, used friction loss, final outlet pressure, and pump count.</li>
          </ul>
        </li>
        <li>When satisfied, click “Generate Report” to open a printable summary of inputs, pump list, and the pressure profile.</li>
      </ol>
      <p class="inline-help" style="max-width:880px; margin-top:8px;">
        Notes: Elevations are sampled from public terrain data and may be approximate. Suction minimum is not enforced automatically in manual mode; verify realistic inlets when choosing pump locations and setpoints.
      </p>
    </section>

    <!-- 1) Path first: user uploads KML up front -->
    <section class="section-card">
      <h3>Path (KML only)</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Upload a .kml file containing one LineString. If the route was drawn from Destination back to Source, use the "Reverse" option so the simulation starts at the Source pump.
      </p>
      <div class="form-grid">
        <div class="field">
          <label for="kml-file">Upload KML (LineString path)</label>
          <input id="kml-file" type="file" accept=".kml">
          <div class="inline-help">Up to ~2,000 points are used (downsampling applied if needed). Direction can be reversed below.</div>
        </div>
        <div class="field">
          <label>Path Drawing Direction</label>
          <div class="radio-row">
            <label><input type="radio" name="path-dir" value="source_to_dest" checked> Source → Destination</label>
            <label><input type="radio" name="path-dir" value="dest_to_source"> Destination → Source (Reverse)</label>
          </div>
          <div class="inline-help">Pick the direction that matches how your LineString was drawn so the "Source" end is simulated first.</div>
        </div>
      </div>
      <div class="inline-help" id="path-status" style="margin-top:8px;display:none;"></div>
    </section>

    <!-- 2) Core hydraulics inputs -->
    <section class="section-card">
      <h3>Hydraulic Inputs</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Set operating parameters for your system. After you click Run Calculation, give it a second to process.      </p>
      <div class="form-grid">
        <div class="field">
          <label for="flow-bpm">Flow Rate (Barrels per minute)</label>
          <input id="flow-bpm" type="number" step="0.1" min="0" value="75">
        </div>

        <div class="field">
          <label for="hose-size">Hose Diameter</label>
          <select id="hose-size">
            <option value="12">12 inches</option>
            <option value="14">14 inches</option>
            <option value="16" selected>16 inches</option>
          </select>
        </div>

        <div class="field">
          <label for="source-psi">Source Pump Discharge (PSI)</label>
          <input id="source-psi" type="number" step="0.1" min="0.1" value="100">
          <div class="inline-help">Starting pressure at the source.</div>
        </div>

        <div class="field">
          <label for="midline-psi">Default Booster Discharge (PSI)</label>
          <input id="midline-psi" type="number" step="0.1" min="0" value="100">
          <div class="inline-help">Default discharge applied when adding a manual booster. You can change per-pump in the panel.</div>
        </div>

        <div class="field">
          <label for="max-hose-psi">Max Allowable Hose Pressure (PSI)</label>
          <input id="max-hose-psi" type="number" step="1" min="1" value="150">
        </div>


        <div class="field">
          <label for="hose-runs">Hose Runs</label>
          <select id="hose-runs">
            <option value="1" selected>Single</option>
            <option value="2">Dual (parallel)</option>
          </select>
          <div class="inline-help">Dual run uses two parallel hoses. Friction loss is reduced accordingly for the same total flow.</div>
        </div>
      </div>

      <div class="section-card" style="margin-top:12px;">
        <div class="field">
          <label>Friction Loss</label>
          <div class="radio-row">
            <label><input type="radio" name="loss-method" value="lookup" checked> Calculate from Flow & Hose Size</label>
            <label><input type="radio" name="loss-method" value="manual"> Enter PSI Loss Manually</label>
          </div>
          <div class="inline-help">Used to compute pressure drop between pumps.</div>
        </div>
        <div id="manual-loss-wrap" class="field" style="display:none; margin-top:8px;">
          <label for="manual-loss-psi100">Manual PSI Loss per 100 ft</label>
          <input id="manual-loss-psi100" type="number" step="0.01" min="0" value="0">
        </div>
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;">
        <button id="run-calc" class="btn">Run Calculation</button>
        <button id="reset-form" class="btn secondary">Reset</button>
        <button id="generate-report" class="btn secondary" title="Open printable report in a new tab" disabled>Generate Report</button>
      </div>
    </section>

    <section class="section-card" id="map-section" style="display:none;">
      <h3>Map Preview</h3>
      <p class="inline-help" style="margin-top:-6px;">
        The polyline shows your uploaded path.
        Click markers for details.
      </p>
      <div id="modeler-map"></div>
      <div class="inline-help" id="map-hint" style="margin-top:6px;">Path and pump markers will display here after KML processing.</div>
      <div id="manual-panel" class="section-card" style="margin-top:10px; display:none;">
        <h3 style="margin-top:0;">Manual Pumps</h3>
        <div class="inline-help" style="margin-top:-6px;">
          Click on the red polyline to add a booster pump. Drag markers to move along the line. Click a marker to delete. Edit discharge setpoints below.
        </div>
        <div id="manual-pump-list" class="manual-pump-list" style="margin-top:8px;"></div>
      </div>
    </section>

    <section class="section-card" id="results-section" style="display:none;">
      <h3>Results Summary</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Total distance is derived from your path after downsampling (if applied).
      </p>
      <table class="results-table">
        <tbody>
          <tr><th>Total Distance (ft)</th><td id="out-total-dist">—</td></tr>
          <tr><th>Used PSI Loss / 100 ft</th><td id="out-used-loss">—</td></tr>
          <tr><th>Final Outlet Pressure (PSI)</th><td id="out-final-psi">—</td></tr>
          <tr><th>Midline Pumps Placed</th><td id="out-pump-count">—</td></tr>
        </tbody>
      </table>
      <div id="warnings-wrap" style="margin-top:8px; display:none;">
        <strong>Warnings</strong>
        <ul class="warnings" id="warnings-list"></ul>
      </div>
    </section>

    <section class="section-card" id="chart-section" style="display:none;">
      <h3>Pressure Profile</h3>
      <p class="inline-help" style="margin-top:-6px;">
        The blue line is pressure along the path (includes elevation changes and friction). Vertical jumps indicate pump boosts.
      </p>
      <div class="chart-box">
        <canvas id="pressureChart"></canvas>
      </div>
    </section>
  </main>

  <footer class="site-footer" role="contentinfo">
    <nav class="footer-nav" aria-label="Footer">
      <a class="footer-link" href="index.html">Home</a>
      <a class="footer-link" href="layflat-modeler.html" aria-current="page">Layflat Hydraulic Modeler</a>
    </nav>
  </footer>

  <!-- Leaflet JS for map preview -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Chart.js for pressure plot -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <script>
    // --- Constants and data ---
    const BARRELS_TO_GALLONS = 42.0;
    const PSI_PER_FOOT_WATER = 0.433;
    const OPENTOPODATA_ENDPOINT = 'https://api.opentopodata.org/v1/ned10m';
    // CORS-safe JSON proxies to bypass missing CORS headers from third-party services.
    // Try in order; some may block or rate-limit.
    const CORS_JSON_PROXIES = [
      // Use CORS proxies that accept a full absolute URL (no double protocol)
      // Each entry is an object with: { mode: 'prefix' | 'param', value: string }
      { mode: 'prefix', value: 'https://r.jina.ai/' },               // fetches target URL as text/json with permissive CORS
      { mode: 'param',  value: 'https://api.allorigins.win/raw?url=' }, // AllOrigins RAW passthrough
      { mode: 'prefix', value: 'https://cors.isomorphic-git.org/' }  // isomorphic-git CORS proxy
    ];
    const MAX_POINTS = 2000;          // hard cap for safety
    const BATCH_SIZE = 100;           // OpenTopoData batch chunk
    // 12" reference table: [GPM, head loss (ft) per 100 ft]
    const HOSE_DATA_12_INCH = [
      [0,0.0],[300,0.03],[350,0.04],[400,0.04],[450,0.05],
      [500,0.06],[550,0.07],[600,0.09],[650,0.11],[700,0.13],
      [750,0.15],[800,0.17],[850,0.19],[900,0.21],[950,0.23],
      [1000,0.26],[1100,0.30],[1200,0.35],[1300,0.40],[1400,0.46],
      [1500,0.53],[1600,0.60],[1700,0.67],[1800,0.75],[1900,0.83],
      [2000,0.92],[2500,1.45],[3000,2.05],[3500,2.75],[4000,3.57],
      [4500,4.31],[5000,5.01]
    ];

    function bpmToGpm(bpm) { return bpm * BARRELS_TO_GALLONS; }

    function lookupHeadLoss12in(gpm) {
      if (gpm < 0) return null;
      if (gpm === 0) return 0.0;
      let lower = null, upper = null;
      for (let i=0;i<HOSE_DATA_12_INCH.length;i++) {
        const [x, y] = HOSE_DATA_12_INCH[i];
        if (x === gpm) return y;
        if (x < gpm) lower = [x,y];
        if (x > gpm) { upper = [x,y]; break; }
      }
      if (!lower && upper) return null;
      if (lower && !upper) return null;
      if (!lower || !upper) return null;
      const [x1,y1] = lower, [x2,y2] = upper;
      if (x2 === x1) return y1;
      return y1 + (y2 - y1) * (gpm - x1) / (x2 - x1);
    }

    function scaleHeadLossByDiameter(headLoss12, targetInches) {
      const d = Number(targetInches);
      if (!d || d <= 0) return headLoss12;
      if (d === 12) return headLoss12;
      const factor = Math.pow(12.0 / d, 4.87);
      return headLoss12 * factor;
    }

    function headLossFtToPsi(headLossFt) {
      return headLossFt * PSI_PER_FOOT_WATER;
    }

    // Downsample coordinates to at most maxPoints using even index sampling
    function downsampleLatLngs(latlngs, maxPoints) {
      if (!latlngs || latlngs.length <= maxPoints) return latlngs || [];
      const result = [];
      const step = (latlngs.length - 1) / (maxPoints - 1);
      for (let i = 0; i < maxPoints; i++) {
        const idx = Math.round(i * step);
        result.push(latlngs[idx]);
      }
      return result;
    }

    // Parse KML text to extract first LineString coordinates as [lat, lng]
    function parseKmlLineStringToLatLngs(kmlText) {
      const parser = new DOMParser();
      const xml = parser.parseFromString(kmlText, 'text/xml');
      const coords = xml.getElementsByTagName('coordinates');
      if (!coords || !coords.length) return [];
      const text = coords[0].textContent || '';
      const parts = text.trim().split(/\s+/);
      const latlngs = [];
      for (const p of parts) {
        const [lonStr, latStr] = p.split(',');
        const lat = parseFloat(latStr), lon = parseFloat(lonStr);
        if (isFinite(lat) && isFinite(lon)) latlngs.push([lat, lon]);
      }
      return latlngs;
    }

    // KMZ parsing intentionally unsupported to simplify client-side; KML only.
    async function extractKmlFromKmz(file) {
      throw new Error('KMZ is not supported. Please upload a .kml file.');
    }

    // Fetch elevations for latlngs via OpenTopoData in batches; returns meters array
    async function fetchElevationsOpenTopo(latlngs) {
      // Strategy (more robust):
      // 1) Try multiple permissive CORS proxies (works on localhost).
      // 2) Try direct fetch (works if API provides CORS).
      // 3) Try JSONP via AllOrigins (last resort).
      // 4) If all fail, return zeros for the batch to keep UI functioning.
      const elevations = [];
  
      async function fetchJson(url) {
        const resp = await fetch(url, { headers: { 'Accept': 'application/json' } });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        // Some proxies (e.g., r.jina.ai) may downconvert; try JSON, fallback to text->JSON
        try {
          return await resp.json();
        } catch {
          const txt = await resp.text();
          try {
            return JSON.parse(txt);
          } catch {
            // For AllOrigins raw endpoint, the response is the upstream JSON already
            // If it wasn't valid JSON, surface an error
            throw new Error('Non-JSON response');
          }
        }
      }
  
      // JSONP fallback using allorigins JSONP (stable callback delivery)
      async function fetchViaJsonp(url) {
        return new Promise((resolve, reject) => {
          const cbName = 'otd_cb_' + Math.random().toString(36).slice(2);
          let finished = false;
          let script = null;
          const cleanup = () => {
            try { delete window[cbName]; } catch {}
            if (script && script.parentNode) script.parentNode.removeChild(script);
          };
          const finish = (fn, val) => {
            if (finished) return;
            finished = true;
            cleanup();
            fn(val);
          };
          window[cbName] = (payload) => {
            try {
              // allorigins wraps response in { contents: "<raw text>", status: {...} }
              const txt = typeof payload === 'string' ? payload : (payload && payload.contents) || '';
              const data = JSON.parse(txt);
              finish(resolve, data);
            } catch (e) {
              finish(reject, new Error('JSONP decode error'));
            }
          };
          // Use allorigins JSONP to fetch target and return raw text
          const jsonpUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}&callback=${cbName}`;
          script = document.createElement('script');
          script.src = jsonpUrl;
          script.onerror = () => finish(reject, new Error('JSONP script load error'));
          document.head.appendChild(script);
          // Safety timeout (10s)
          setTimeout(() => finish(reject, new Error('JSONP timeout')), 10000);
        });
      }
  
      for (let i = 0; i < latlngs.length; i += BATCH_SIZE) {
        const batch = latlngs.slice(i, i + BATCH_SIZE);
        const locations = batch.map(([lat, lon]) => `${lat.toFixed(6)},${lon.toFixed(6)}`).join('|');
        // Do not duplicate dataset param; base endpoint already includes dataset path.
        const directUrl = `${OPENTOPODATA_ENDPOINT}?locations=${encodeURIComponent(locations)}`;
  
        let got = null;
        try {
          // 1) Try via multiple proxies first to bypass CORS locally
          let lastProxyErr = null;
          for (const proxy of CORS_JSON_PROXIES) {
            try {
              const proxiedUrl = proxy.mode === 'param'
                ? (proxy.value + encodeURIComponent(directUrl))
                : (proxy.value + directUrl); // prefix mode
              const data = await fetchJson(proxiedUrl);
              if (data && data.status === 'OK' && Array.isArray(data.results)) {
                got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
                break;
              }
              lastProxyErr = new Error('Proxy returned invalid payload');
            } catch (e) {
              lastProxyErr = e;
            }
          }
          if (!got) throw lastProxyErr || new Error('All proxies failed');
        } catch (proxyErr) {
          try {
            // 2) Try direct without proxy
            const data = await fetchJson(directUrl);
            if (!data || data.status !== 'OK' || !Array.isArray(data.results)) throw new Error('Invalid payload');
            got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
          } catch (directErr) {
            try {
              // 3) JSONP last resort
              const data = await fetchViaJsonp(directUrl);
              if (!data || data.status !== 'OK' || !Array.isArray(data.results)) throw new Error('JSONP invalid payload');
              got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
            } catch (jsonpErr) {
              console.warn('Elevation fetch failed via proxies, direct, and JSONP. Using flat elevation for this batch.', proxyErr, directErr, jsonpErr);
              got = batch.map(() => 0);
            }
          }
        }
        elevations.push(...got);
      }
      return elevations;
    }

    // Compute cumulative distance in feet along polyline of [lat, lon] using simple haversine
    function cumulativeDistancesFt(latlngs) {
      const R = 6371000; // meters
      const toRad = d => d * Math.PI / 180;
      const dists = [0];
      let cum = 0;
      for (let i = 1; i < latlngs.length; i++) {
        const [lat1, lon1] = latlngs[i-1];
        const [lat2, lon2] = latlngs[i];
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const meters = R * c;
        const feet = meters * 3.28084;
        cum += feet;
        dists.push(cum);
      }
      return dists;
    }

    // Automatic midline pump placement (reactive baseline)
    function placeMidlinePumps(distFt, elevFt, sourcePsi, midlinePsi, minSuctionPsi, psiLossPer100) {
      const lossPerFt = psiLossPer100 / 100.0;
      const pumps = [];
      let currentPressure = sourcePsi;
      const HORIZON = 10;

      for (let i = 0; i < distFt.length - 1; i++) {
        let lookAheadPressure = currentPressure;
        let needsPump = false;

        for (let j = i + 1; j < Math.min(i + 1 + HORIZON, distFt.length); j++) {
          const segLenLA = distFt[j] - distFt[j - 1];
          const dhFtLA = elevFt[j] - elevFt[j - 1];
          const elevDeltaPsiLA = -dhFtLA * PSI_PER_FOOT_WATER;
          const frictionPsiLA = lossPerFt * segLenLA;
          lookAheadPressure = lookAheadPressure + elevDeltaPsiLA - frictionPsiLA;

          if (lookAheadPressure < minSuctionPsi) { needsPump = true; break; }
          if (lookAheadPressure > (minSuctionPsi + 20)) { break; }
        }

        if (needsPump && (i > 0 || currentPressure < minSuctionPsi)) {
          pumps.push({ index: i, distanceFt: distFt[i], pressureBefore: currentPressure, discharge: midlinePsi });
          currentPressure = midlinePsi;
        }

        const segLen = distFt[i + 1] - distFt[i];
        const dhFt = elevFt[i + 1] - elevFt[i];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        currentPressure = currentPressure + elevDeltaPsi - frictionPsi;
      }

      return { pumps, finalPressure: currentPressure };
    }

    // Removed automatic placement algorithms (optimized/curve). Manual-only app.

    // Removed automatic placement algorithms (minimized/fixed-setpoint). Manual-only app.

    // Build pressure profile including placed pumps (clear boost visualization)
    // Returns an object with distances and pressures arrays aligned 1:1 for Chart.js
    function buildProfileWithPumps(distFt, elevFt, sourcePsi, pumps, psiLossPer100) {
      // Build pressure profile for plotting. Do NOT clamp the plotted pressures;
      // only clamp the displayed inlet values at pump markers elsewhere.
      const lossPerFt = psiLossPer100 / 100.0;
      const outDistances = [];
      const outPressures = [];
      let p = sourcePsi;
      let pumpIdx = 0;

      // Seed first point (true simulated pressure)
      outDistances.push(distFt[0]);
      outPressures.push(p);

      for (let i = 1; i < distFt.length; i++) {
        // Check if a pump exists exactly at index i
        if (pumpIdx < pumps.length && pumps[pumpIdx].index === i) {
          // Add point just before pump (true pressure at this location)
          outDistances.push(distFt[i]);
          outPressures.push(p);

          // Add point just after pump (boosted pressure at same location)
          p = pumps[pumpIdx].discharge;
          outDistances.push(distFt[i]);
          outPressures.push(p);
          pumpIdx++;
        }

        // Calculate pressure change through current segment
        const segLen = distFt[i] - distFt[i - 1];
        const dhFt = elevFt[i] - elevFt[i - 1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        p = p + elevDeltaPsi - frictionPsi;

        // Add end point of segment (true pressure)
        outDistances.push(distFt[i]);
        outPressures.push(p);
      }

      return { distances: outDistances, pressures: outPressures };
    }

    // --- DOM refs ---
    const elFlowBpm = document.getElementById('flow-bpm');
    const elHoseSize = document.getElementById('hose-size');
    const elSourcePsi = document.getElementById('source-psi');
    const elMidlinePsi = document.getElementById('midline-psi');
    const elMaxHose = document.getElementById('max-hose-psi');
    const elHoseRuns = document.getElementById('hose-runs');

    const lossRadios = document.querySelectorAll('input[name="loss-method"]');
    const elManualWrap = document.getElementById('manual-loss-wrap');
    const elManualPsi100 = document.getElementById('manual-loss-psi100');

    const elKmlFile = document.getElementById('kml-file');
    const pathDirRadios = document.querySelectorAll('input[name="path-dir"]');
    // Back-compat guard in case req-outlet existed in prior state
    try { const stale = document.getElementById('req-outlet-psi'); if (stale) stale.remove(); } catch {}

    const elRun = document.getElementById('run-calc');
    const elReset = document.getElementById('reset-form');

    const elMapSection = document.getElementById('map-section');
    const elResults = document.getElementById('results-section');
    const elOutDist = document.getElementById('out-total-dist');
    const elOutUsedLoss = document.getElementById('out-used-loss');
    const elOutFinalPsi = document.getElementById('out-final-psi');
    const elOutOutletMet = document.getElementById('out-outlet-met');
    const elOutPumpCount = document.getElementById('out-pump-count');
    const elWarningsWrap = document.getElementById('warnings-wrap');
    const elWarningsList = document.getElementById('warnings-list');

    const elChartSection = document.getElementById('chart-section');
    const chartCanvas = document.getElementById('pressureChart');

    let chartInstance = null;
    let mapInstance = null;
    let pathLayer = null;
    let pumpLayer = null;

    // Manual placement state
    let manualMode = false;
    let manualLatLngs = [];  // active path
    let manualDistFt = [];   // cumulative distances for path
    let manualElevFt = [];   // elevation samples for path
    // pumps: { index: i, distanceFt, discharge, pressureBefore (computed), marker }
    let manualPumps = [];

    function currentLossMethod() {
      for (const r of lossRadios) if (r.checked) return r.value;
      return 'lookup';
    }
    function currentPathDir() {
      for (const r of pathDirRadios) if (r.checked) return r.value;
      return 'source_to_dest';
    }
    function updateManualVisibility() {
      elManualWrap.style.display = currentLossMethod() === 'manual' ? 'block' : 'none';
    }
    lossRadios.forEach(r => r.addEventListener('change', updateManualVisibility));
    updateManualVisibility();

    function resetForm() {
      elFlowBpm.value = '50';
      elHoseSize.value = '16';
      elSourcePsi.value = '100';
      elMidlinePsi.value = '80';
      elMaxHose.value = '150';
      document.querySelector('input[name="loss-method"][value="lookup"]').checked = true;
      elManualPsi100.value = '0';
      updateManualVisibility();
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';
      elMapSection.style.display = 'none';
      if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
      if (mapInstance) {
        try { mapInstance.remove(); } catch{}
        mapInstance = null; pathLayer = null; pumpLayer = null;
      }
      elKmlFile.value = '';
    }
    elReset.addEventListener('click', resetForm);

    function ensureMap() {
      if (mapInstance) return mapInstance;
      elMapSection.style.display = 'block';
      mapInstance = L.map('modeler-map', { zoomControl: true }).setView([35.5, -98.5], 6);

      // Base layers
      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap contributors'
      });

      // Esri World Imagery (satellite)
      const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Tiles © Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
      });

      // Esri World Boundaries and Places (labels) to create a hybrid overlay
      const esriLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Labels © Esri'
      });

      // Create a hybrid group (satellite + labels)
      const hybrid = L.layerGroup([esriSat, esriLabels]);

      // Add default base (Satellite with labels - Hybrid)
      // Turn on hybrid (satellite + labels) by default so users see imagery immediately.
      hybrid.addTo(mapInstance);

      // Pump layer lives above basemap(s)
      pumpLayer = L.layerGroup().addTo(mapInstance);

      // Layer control to switch between basemaps
      const baseMaps = {
        'Streets (OSM)': osm,
        'Satellite (Esri World Imagery)': esriSat,
        'Hybrid (Satellite + Labels)': hybrid
      };
      L.control.layers(baseMaps, null, { collapsed: true }).addTo(mapInstance);

      return mapInstance;
    }

    // Small status helper to report path length and points
    function updatePathStatus(latlngs, totalFt) {
      const el = document.getElementById('path-status');
      if (!el) return;
      if (!latlngs || !latlngs.length) { el.style.display = 'none'; return; }
      el.style.display = 'block';
      el.textContent = `Loaded ${latlngs.length} points • Total distance ~ ${totalFt.toFixed(0)} ft`;
    }

    function nearestPathIndex(latlngs, latlng) {
      // simple nearest vertex search
      let best = 0, bestD = Infinity;
      for (let i=0;i<latlngs.length;i++){
        const dLat = latlngs[i][0] - latlng.lat;
        const dLng = latlngs[i][1] - latlng.lng;
        const d2 = dLat*dLat + dLng*dLng;
        if (d2 < bestD) { bestD = d2; best = i; }
      }
      return best;
    }

    function rebuildManualList() {
      const list = document.getElementById('manual-pump-list');
      if (!list) return;
      if (!manualPumps.length) { list.innerHTML = '<div class="inline-help">No manual pumps yet.</div>'; return; }
      list.innerHTML = '';
      manualPumps
        .sort((a,b) => a.distanceFt - b.distanceFt)
        .forEach((p, idx) => {
          const row = document.createElement('div');
          row.className = 'manual-pump-row';
          row.innerHTML = `
            <div class="mp-col mp-col--id">#${idx+1} @ ${(p.distanceFt/5280).toFixed(2)} mi</div>
            <div class="mp-col mp-col--inlet">Inlet: ${(p.pressureBefore ?? 0).toFixed(1)} PSI</div>
            <div class="mp-col mp-col--disch">
              <label class="mp-label" for="mp-dis-${idx}">Discharge PSI</label>
              <input id="mp-dis-${idx}" class="mp-input" type="number" step="0.1" inputmode="decimal" value="${Number(p.discharge ?? elMidlinePsi.value)}">
            </div>
            <div class="mp-col mp-col--actions">
              <button class="btn secondary mp-del" data-del="${idx}">Delete</button>
            </div>
          `;
          // wire discharge edit: keep focus and allow continuous typing without re-clicking
          const inp = row.querySelector('.mp-input');
          // prevent update loop from rebuilding list while typing
          let typing = false;
          let rafId = null;
          const liveUpdate = () => {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(() => {
              const v = Number(inp.value);
              p.discharge = isFinite(v) ? v : 0;
              // Update pressures and chart only, avoid rebuilding list to preserve focus
              recomputeManualInlets();
              const prof = computeProfileWithGivenPumps(manualDistFt, manualElevFt, Number(elSourcePsi.value), manualPumps, window.__lastUsedPsiLossPer100 || 0);
              const finalPressure = prof.pressures.length ? prof.pressures[prof.pressures.length-1] : 0;
              renderResults(manualDistFt[manualDistFt.length-1]||0, (window.__lastUsedPsiLossPer100||0), finalPressure, manualPumps.length, (window.__lastWarnings||[]), prof.distances, prof.pressures, 0);
            });
          };
          // On input, do lightweight update without rebuilding list
          inp.addEventListener('input', liveUpdate);
          // On blur or Enter, commit and then rebuild list for any formatting
          const commitAndRebuild = () => {
            const v = Number(inp.value);
            p.discharge = isFinite(v) ? v : 0;
            updateManualProfileAndUI();
            // restore focus to same field index if still present
            requestAnimationFrame(() => {
              const again = document.getElementById('mp-dis-${idx}');
              if (again) { try { again.focus(); again.setSelectionRange(again.value.length, again.value.length); } catch {} }
            });
          };
          inp.addEventListener('change', commitAndRebuild);
          inp.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); commitAndRebuild(); }
          });
          inp.addEventListener('blur', commitAndRebuild);
          // wire delete
          const del = row.querySelector('.mp-del');
          del.addEventListener('click', () => {
            try { pumpLayer.removeLayer(p.marker); } catch {}
            manualPumps.splice(idx,1);
            updateManualProfileAndUI();
          });
          list.appendChild(row);
        });
    }

    function computeProfileWithGivenPumps(distFt, elevFt, sourcePsi, pumps, psiLossPer100) {
      // identical to buildProfileWithPumps but uses provided pumps array; returns {distances, pressures}
      const lossPerFt = psiLossPer100 / 100.0;
      const outDistances = [];
      const outPressures = [];
      let p = sourcePsi;
      let pumpIdx = 0;
      outDistances.push(distFt[0]); outPressures.push(p);
      for (let i = 1; i < distFt.length; i++) {
        if (pumpIdx < pumps.length && pumps[pumpIdx].index === i) {
          outDistances.push(distFt[i]); outPressures.push(p);
          p = pumps[pumpIdx].discharge;
          outDistances.push(distFt[i]); outPressures.push(p);
          pumpIdx++;
        }
        const segLen = distFt[i] - distFt[i-1];
        const dhFt = elevFt[i] - elevFt[i-1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        p = p + elevDeltaPsi - frictionPsi;
        outDistances.push(distFt[i]); outPressures.push(p);
      }
      return { distances: outDistances, pressures: outPressures };
    }

    function recomputeManualInlets() {
      // recompute inlet pressures at pump indices based on current manualPumps and current hydraulics
      const sourcePsi = Number(elSourcePsi.value);
      const usedPsiLossPer100 = window.__lastUsedPsiLossPer100 || 0;
      const lossPerFt = usedPsiLossPer100 / 100.0;

      let p = sourcePsi;
      let nextPumpIdx = 0;
      for (let i=1;i<manualDistFt.length;i++){
        if (nextPumpIdx < manualPumps.length && manualPumps[nextPumpIdx].index === i){
          // inlet at this node is current p
          manualPumps[nextPumpIdx].pressureBefore = p; // raw, no clamping
          // jump to discharge
          p = Number(manualPumps[nextPumpIdx].discharge || elMidlinePsi.value);
          nextPumpIdx++;
        }
        const segLen = manualDistFt[i] - manualDistFt[i-1];
        const dhFt = manualElevFt[i] - manualElevFt[i-1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        p = p + elevDeltaPsi - frictionPsi;
      }
    }

    function updateManualProfileAndUI() {
      // recompute inlets, redraw markers list, refresh chart/results
      recomputeManualInlets();
      rebuildManualList();

      // Build profile from manual pumps
      const prof = computeProfileWithGivenPumps(manualDistFt, manualElevFt, Number(elSourcePsi.value), manualPumps, window.__lastUsedPsiLossPer100 || 0);
      const distancesForChart = prof.distances;
      const pressures = prof.pressures;

      // Update map markers popups to show raw inlet
      pumpLayer.clearLayers();
      manualPumps.forEach((p, idx) => {
        const [lat, lon] = manualLatLngs[p.index];
        const m = L.marker([lat, lon], { draggable: true })
          .bindPopup(`<b>Manual Pump #${idx+1}</b><br>Distance: ${p.distanceFt.toFixed(0)} ft<br>Inlet: ${(p.pressureBefore??0).toFixed(1)} PSI<br>Discharge: ${Number(p.discharge||0).toFixed(1)} PSI`);
        m.on('dragend', (ev) => {
          const ll = ev.target.getLatLng();
          const i = nearestPathIndex(manualLatLngs, ll);
          p.index = i;
          p.distanceFt = manualDistFt[i];
          p.marker.setLatLng([manualLatLngs[i][0], manualLatLngs[i][1]]);
          updateManualProfileAndUI();
        });
        m.on('click', () => { // delete on click
          try { pumpLayer.removeLayer(m); } catch {}
          const k = manualPumps.indexOf(p);
          if (k>=0) { manualPumps.splice(k,1); updateManualProfileAndUI(); }
        });
        p.marker = m;
        pumpLayer.addLayer(m);
      });

      // Results and chart: pumpCount from manual, final outlet from profile tail
      const finalPressure = pressures.length ? pressures[pressures.length-1] : 0;
      renderResults(manualDistFt[manualDistFt.length-1]||0, (window.__lastUsedPsiLossPer100||0), finalPressure, manualPumps.length, (window.__lastWarnings||[]), distancesForChart, pressures, 0);

      // Persist last run for report with manual selection
      window.__modelerLastRun = window.__modelerLastRun || {};
      window.__modelerLastRun.profile = { distances: distancesForChart, pressures };
      window.__modelerLastRun.results = window.__modelerLastRun.results || {};
      window.__modelerLastRun.results.finalPressure = finalPressure;
      window.__lastPumps = manualPumps.map(p => ({ index:p.index, distanceFt:p.distanceFt, pressureBefore:p.pressureBefore, discharge:Number(p.discharge||0) }));
      window.__lastPlacementStrategy = 'manual';
    }

    function renderPathOnMap(latlngs, pumps) {
      const map = ensureMap();
      if (pathLayer) { map.removeLayer(pathLayer); pathLayer = null; }
      pumpLayer.clearLayers();

      if (latlngs && latlngs.length > 1) {
        pathLayer = L.polyline(latlngs, { color: 'red', weight: 5 }).addTo(map);
        map.fitBounds(pathLayer.getBounds().pad(0.1));

        // Manual mode click handler
        if (manualMode) {
          pathLayer.on('click', (ev) => {
            const i = nearestPathIndex(latlngs, ev.latlng);
            const distanceFt = manualDistFt[i] || 0;
            const discharge = Number(elMidlinePsi.value);
            const np = { index:i, distanceFt, discharge, pressureBefore: 0, marker: null };
            manualPumps.push(np);
            updateManualProfileAndUI();
          });
        } else {
          if (pathLayer) pathLayer.off('click');
        }
      }
      if (Array.isArray(pumps)) {
        pumps.forEach((p, idx) => {
          const i = p.index;
          if (i != null && i >= 0 && i < latlngs.length) {
            const [lat, lon] = latlngs[i];
            const rpmInfo = p.rpm ? `<br>RPM: ${p.rpm}` : '';
            const headInfo = p.headAddedFt ? `<br>Head Add: ${p.headAddedFt.toFixed(0)} ft` : '';
            const qInfo = p.qgpm ? `<br>Flow: ${p.qgpm.toFixed(0)} gpm` : '';
            const famInfo = p.family ? `<br>Family: ${p.family}` : '';
            const marker = L.marker([lat, lon]).bindPopup(
              `<b>Midline Pump #${idx+1}</b><br>Distance: ${p.distanceFt.toFixed(0)} ft` +
              `<br>Inlet: ${p.pressureBefore.toFixed(1)} PSI` +
              `<br>Discharge: ${p.discharge.toFixed(1)} PSI` +
              rpmInfo + headInfo + qInfo + famInfo
            );
            pumpLayer.addLayer(marker);
          }
        });
      }
    }

    function renderChart(distances, pressures, minSuction) {
      if (chartInstance) { 
        chartInstance.destroy(); 
        chartInstance = null; 
      }
      
      // Ensure we have valid data arrays
      if (!Array.isArray(distances) || !Array.isArray(pressures) || distances.length === 0 || pressures.length === 0) {
        console.warn('Invalid chart data:', { distances, pressures });
        return;
      }
      
      // Ensure arrays are same length
      const minLength = Math.min(distances.length, pressures.length);
      const chartDistances = distances.slice(0, minLength);
      const chartPressures = pressures.slice(0, minLength);
      
      // Create labels
      const labels = chartDistances.map(d => Number(d).toFixed(0));
      
      console.log('Chart data:', {
        labels: labels.length,
        pressures: chartPressures.length
      });
      
      chartInstance = new Chart(chartCanvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Pressure (PSI)',
              data: chartPressures,
              borderColor: '#0b5fff',
              backgroundColor: 'rgba(11,95,255,0.10)',
              pointRadius: 1.5,
              tension: 0,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          scales: {
            x: {
              title: { display: true, text: 'Distance (ft)' },
              type: 'category'
            },
            y: {
              title: { display: true, text: 'Pressure (PSI)' },
              beginAtZero: true
            }
          },
          plugins: {
            legend: {
              display: true
            }
          }
        }
      });
    }

    // --- Pump curves: Cornell 8HNTH (approx from provided chart), Q in GPM, head/NPSHR in feet ---
    // Monotone piecewise-cubic (PCHIP) for stable interpolation over anchor points
    function pchip(xs, ys) {
      const n = xs.length;
      const h = new Array(n-1);
      const s = new Array(n-1);
      for (let i=0;i<n-1;i++){ h[i]=xs[i+1]-xs[i]; s[i]=(ys[i+1]-ys[i])/(h[i]||1); }
      const m = new Array(n);
      m[0]=s[0]; m[n-1]=s[n-2];
      for (let i=1;i<n-1;i++){
        if (s[i-1]*s[i] <= 0) m[i]=0;
        else {
          const w1 = 2*h[i]+h[i-1], w2 = h[i]+2*h[i-1];
          m[i] = (w1+w2)/(w1/s[i-1] + w2/s[i]);
        }
      }
      return function(x){
        if (x<=xs[0]) return ys[0];
        if (x>=xs[n-1]) return ys[n-1];
        let k=0; while (xs[k+1] < x) k++;
        const t = (x - xs[k])/(h[k]||1);
        const t2=t*t, t3=t2*t;
        const yk=ys[k], yk1=ys[k+1], mk=m[k], mk1=m[k+1], hk=h[k];
        return (2*t3-3*t2+1)*yk + (t3-2*t2+t)*mk*hk + (-2*t3+3*t2)*yk1 + (t3-t2)*mk1*hk;
      };
    }

    // Anchor points estimated from charts. These are coarse and can be refined.
    // For each RPM band we map Q[gpm] -> Head[ft].
    const PUMP_8HNTH = (() => {
      const RPMS = [1200, 1400, 1600, 1800];
      const H_pts = {
        1200: { Q:[1500, 2500, 3500, 4500, 5500], H:[165, 160, 145, 130, 110] },
        1400: { Q:[1500, 2500, 3500, 4500, 5500, 6500], H:[210, 205, 190, 172, 152, 130] },
        1600: { Q:[2000, 3000, 4000, 5000, 6000, 7000], H:[260, 250, 235, 215, 195, 175] },
        1800: { Q:[2500, 3500, 4500, 5500, 6500, 8000], H:[320, 305, 285, 265, 240, 210] }
      };
      // NPSHR isolines ~10–30 ft rising with Q. Use a simple piecewise fit across total Q range.
      const NPSHR_pts = { Q:[2000, 3000, 4000, 5000, 6000, 7000, 8000], N:[10, 12, 15, 20, 24, 27, 30] };

      const headFns = {};
      RPMS.forEach(r => headFns[r] = pchip(H_pts[r].Q, H_pts[r].H));
      const npshrFn = pchip(NPSHR_pts.Q, NPSHR_pts.N);

      return {
        rpms: RPMS,
        headAt(Q, rpm) { return headFns[rpm](Q); },
        npshrAt(Q) { return npshrFn(Q); },
        domain() {
          const minQ = 1500, maxQ = 8000; // conservative from anchors
          return { minQ, maxQ };
        }
      };
    })();

    // Lower-capacity family: Cornell 8NHTA (from second chart)
    const PUMP_8NHTA = (() => {
      const RPMS = [800,1000,1200,1400,1600,1770];
      // Coarse anchors digitized from the provided chart (Q gpm -> Head ft)
      const H_pts = {
        800:  { Q:[ 500, 1000, 1500, 2000, 2500, 3000], H:[ 60,   70,   78,   85,   88,   85 ] },
        1000: { Q:[ 700, 1200, 1800, 2400, 3000, 3600], H:[ 85,   95,  108,  118,  122,  118 ] },
        1200: { Q:[ 900, 1500, 2200, 3000, 3600, 4200], H:[110,  125,  140,  150,  152,  145 ] },
        1400: { Q:[1000, 1800, 2600, 3400, 4200, 4800], H:[140,  160,  180,  195,  205,  198 ] },
        1600: { Q:[1200, 2000, 3000, 3800, 4600, 5200], H:[170,  195,  215,  235,  245,  238 ] },
        1770: { Q:[1400, 2200, 3200, 4200, 5000, 5600], H:[200,  225,  250,  270,  285,  275 ] }
      };
      // NPSHR isolines 8–20 ft increasing with flow
      const NPSHR_pts = { Q:[500,1000,1500,2000,2500,3000,4000,5000,5600], N:[8,9,10,11.5,13,14.5,16.5,18.5,20] };

      const headFns = {};
      RPMS.forEach(r => headFns[r] = pchip(H_pts[r].Q, H_pts[r].H));
      const npshrFn = pchip(NPSHR_pts.Q, NPSHR_pts.N);

      return {
        rpms: RPMS,
        headAt(Q, rpm) { return headFns[rpm](Q); },
        npshrAt(Q) { return npshrFn(Q); },
        domain() {
          const minQ = 500, maxQ = 5600;
          return { minQ, maxQ };
        }
      };
    })();

    // Compute discharge using pump curve with selectable policy.
    // policy: 'min' (lowest RPM meeting need), 'max' (highest RPM under max hose PSI), default 'max' for auto-pick.
    function computePumpDischargeByCurve({ inletPsi, maxHosePsi, flowBpm, psiLossPerFt, upcomingElevFt, upcomingDistFt, family='8HNTH', policy='max' }) {
      const Qgpm = bpmToGpm(flowBpm);
      const fam = family === '8NHTA' ? PUMP_8NHTA : PUMP_8HNTH;
      const { minQ, maxQ } = fam.domain();
      const Qc = Math.max(minQ, Math.min(maxQ, Qgpm));

      // Control horizon L to estimate head need near the placement
      const L = Math.max(1000, Math.min(6000, upcomingDistFt || 3000)); // 1k–6k ft
      const elevGainFt = Math.max(0, (upcomingElevFt || 0) * (L / Math.max(1, upcomingDistFt || L)));
      const frictionHeadFt = (psiLossPerFt * L) / PSI_PER_FOOT_WATER;
      const requiredHeadFt = elevGainFt + frictionHeadFt;

      // Evaluate all RPMs
      const candidates = fam.rpms.map(rpm => {
        const H = fam.headAt(Qc, rpm);
        const boostPsi = H * PSI_PER_FOOT_WATER;
        const dischargePsi = Math.min(inletPsi + boostPsi, maxHosePsi);
        return { rpm, H, dischargePsi };
      });

      let pick;
      if (policy === 'min') {
        // Choose the lowest RPM that meets required head with small margin
        pick = candidates.find(c => c.H >= requiredHeadFt * 0.98) || candidates[candidates.length - 1];
      } else {
        // 'max' policy: choose the highest RPM that does not exceed Max Hose PSI at discharge
        // If multiple share the same discharge clamp (==maxHosePsi), take highest RPM among those; else take highest RPM overall.
        const valid = candidates.filter(c => c.dischargePsi <= maxHosePsi + 1e-6);
        pick = (valid.length ? valid[valid.length - 1] : candidates[candidates.length - 1]);
      }

      const npshrFt = fam.npshrAt(Qc);
      return { dischargePsi: pick.dischargePsi, rpm: pick.rpm, headAddedFt: pick.H, npshrFt, Qgpm: Qc };
    }

    async function readKmlOrKmz(file) {
      const name = (file?.name || '').toLowerCase();
      if (name.endsWith('.kml')) {
        const text = await file.text();
        return text;
      } else if (name.endsWith('.kmz')) {
        throw new Error('Unsupported file type: KMZ is not supported. Please upload a .kml file.');
      } else {
        throw new Error('Unsupported file type. Please upload a .kml file.');
      }
    }

    function collectWarningsInto(list, msg) {
      list.push(msg);
    }

    function determinePsiLossPer100(flowBpm, hoseIn, lossMethod, manualVal, warnings, runsCount) {
      const runs = Math.max(1, Number(runsCount) || 1);
      let usedPsiLossPer100 = 0;

      if (lossMethod === 'manual') {
        if (!(manualVal >= 0)) {
          collectWarningsInto(warnings, 'Manual PSI loss per 100 ft must be >= 0.');
          usedPsiLossPer100 = 0;
        } else {
          // For parallel identical hoses carrying the same total flow, head loss halves for 2 runs.
          usedPsiLossPer100 = manualVal / runs;
        }
      } else {
        // Lookup mode: compute loss at per-hose flow when using multiple runs,
        // then combine in parallel which divides head loss by number of runs.
        // Total flow is split evenly across runs.
        const totalGpm = bpmToGpm(flowBpm);
        const perHoseGpm = totalGpm / runs;

        const headLoss12_perHose = lookupHeadLoss12in(perHoseGpm);
        if (headLoss12_perHose == null) {
          collectWarningsInto(warnings, 'Flow is outside the 12" lookup table range; cannot interpolate.');
          usedPsiLossPer100 = 0;
        } else {
          const scaledHeadLoss_perHose = scaleHeadLossByDiameter(headLoss12_perHose, hoseIn);
          const psiPerHose = headLossFtToPsi(scaledHeadLoss_perHose);
          // Parallel identical hoses reduce head loss by factor of runs
          usedPsiLossPer100 = psiPerHose / runs;
        }
      }
      return usedPsiLossPer100;
    }

    function renderResults(totalFt, usedPsiLossPer100, finalPressure, pumpCount, warnings, distances, pressures, minSuction) {
      elResults.style.display = 'block';
      elOutDist.textContent = totalFt.toFixed(1);
      elOutUsedLoss.textContent = usedPsiLossPer100.toFixed(4) + ' PSI/100ft';
      elOutFinalPsi.textContent = finalPressure.toFixed(1);
      // Ensure we only count midline pumps, not the source pump (source is not included in auto.pumps)
      const midlineCount = Math.max(0, Number(pumpCount) || 0);
      elOutPumpCount.textContent = String(midlineCount);

      if (warnings.length) {
        elWarningsWrap.style.display = 'block';
        elWarningsList.innerHTML = '';
        warnings.forEach(w => {
          const li = document.createElement('li');
          li.textContent = w;
          elWarningsList.appendChild(li);
        });
      } else {
        elWarningsWrap.style.display = 'none';
        elWarningsList.innerHTML = '';
      }

      elChartSection.style.display = 'block';
      renderChart(distances, pressures, minSuction);

      // Enable report button now that we have a successful run
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = false;

      // Store the latest run dataset on window for report generation
      window.__modelerLastRun = {
        flowBpm: Number(elFlowBpm.value),
        hoseIn: Number(elHoseSize.value),
        hoseRuns: Number(document.getElementById('hose-runs')?.value || 1),
        sourcePsi: Number(elSourcePsi.value),
        midlinePsi: Number(elMidlinePsi.value),
        minSuction: 0,
        maxHose: Number(elMaxHose.value),
        lossMethod: currentLossMethod(),
        manualPsi100: Number(elManualPsi100.value),
        placementStrategy: 'manual',
        pathDir: currentPathDir(),
        results: {
          totalFt,
          usedPsiLossPer100,
          finalPressure,
          pumpCount,
          warnings: [...warnings]
        },
        profile: { distances, pressures },
        pumpsSummary: (window.__lastPumps || []),
        placementStrategy: 'manual'
      };
    }

    async function runCalc() {
      const flowBpm = Number(elFlowBpm.value);
      const hoseIn = Number(elHoseSize.value);
      const sourcePsi = Number(elSourcePsi.value);
      const midlinePsi = Number(elMidlinePsi.value);
      // Manual-only: no user min suction; keep zero for compatibility
      const minSuction = 0;
      const maxHose = Number(elMaxHose.value);
      const lossMethod = currentLossMethod();
      const manualPsi100 = Number(elManualPsi100.value);
      const runsCount = Math.max(1, Number(elHoseRuns && elHoseRuns.value ? elHoseRuns.value : 1));
      const pathDir = currentPathDir();
      const placementStrategy = 'manual';

      const warnings = [];
      if (!(flowBpm >= 0)) warnings.push('Flow rate (BPM) must be >= 0.');
      if (!(sourcePsi > 0)) warnings.push('Source discharge PSI must be > 0.');
      if (!(maxHose > 0)) warnings.push('Max allowable hose PSI must be > 0.');
      if (sourcePsi > maxHose) warnings.push(`Source discharge (${sourcePsi.toFixed(1)} PSI) exceeds hose max (${maxHose.toFixed(1)} PSI).`);

      // Determine friction loss
      const usedPsiLossPer100 = determinePsiLossPer100(flowBpm, hoseIn, lossMethod, manualPsi100, warnings, runsCount);

      // Path handling
      let latlngs = [];
      let usingKml = false;
      const file = elKmlFile.files && elKmlFile.files[0] ? elKmlFile.files[0] : null;
      if (file) {
        usingKml = true;
        let kmlText = '';
        try {
          kmlText = await readKmlOrKmz(file);
        } catch (e) {
          warnings.push(`KML/KMZ error: ${e.message}`);
        }
        if (kmlText) {
          const parsed = parseKmlLineStringToLatLngs(kmlText);
          if (!parsed.length) warnings.push('No LineString coordinates found in KML.');
          latlngs = parsed;
        }
      }

      // If no KML path provided, block calculation silently and prompt user in path section
      if (!latlngs.length) {
        const reportBtn = document.getElementById('generate-report');
        if (reportBtn) reportBtn.disabled = true;
        delete window.__modelerLastRun;

        elMapSection.style.display = 'none';
        elResults.style.display = 'none';
        elChartSection.style.display = 'none';
        elWarningsWrap.style.display = 'none';
        elWarningsList.innerHTML = '';

        const pathStatus = document.getElementById('path-status');
        if (pathStatus) {
          pathStatus.style.display = 'block';
          pathStatus.textContent = 'No path loaded. Upload a KML to run.';
        }
        return;
      }

      // If we have KML path, optionally reverse
      if (pathDir === 'dest_to_source') latlngs.reverse();

      // Downsample if needed
      const dsLatLngs = downsampleLatLngs(latlngs, MAX_POINTS);

      // Elevations
      let elevationsM = [];
      try {
        elevationsM = await fetchElevationsOpenTopo(dsLatLngs);
      } catch (e) {
        warnings.push(`Elevation fetch failed: ${e.message}. Proceeding with flat elevation.`);
        elevationsM = dsLatLngs.map(() => 0);
      }
      const elevationsFt = elevationsM.map(m => m * 3.28084);

      // Distances
      const distFt = cumulativeDistancesFt(dsLatLngs);
      const totalFt = distFt[distFt.length - 1] || 0;

      // Cache for manual mode recompute
      manualLatLngs = dsLatLngs;
      manualDistFt = distFt;
      manualElevFt = elevationsFt;

      // Determine friction loss we used (for manual recompute reuse)
      window.__lastUsedPsiLossPer100 = usedPsiLossPer100;
      window.__lastWarnings = warnings;

      // Manual-only: minSuction already defined earlier in scope as 0

      // Auto midline pump placement: choose algorithm by Pump Logic
      let auto;
      if (placementStrategy === 'manual') {
        manualMode = true;
        // ensure UI elements visible
        document.getElementById('manual-panel').style.display = 'block';
        // if first time entering manual on this path and there are no pumps, start with empty set (source only)
        if (!Array.isArray(manualPumps)) manualPumps = [];
        // render baseline map/path and any existing manual markers, then recompute profile
        renderPathOnMap(dsLatLngs, []);
        updateManualProfileAndUI();
        return; // manual mode defers results build to updateManualProfileAndUI
      } else if (placementStrategy === 'curve_8hnth' || placementStrategy === 'curve_8nht4va' || placementStrategy === 'curve_auto') {
        const lossPerFt = usedPsiLossPer100 / 100.0;
        const pumps = [];
        let i0 = 0;
        let p = sourcePsi;

        function simulateTo(idxFrom, pFrom, idxTo) {
          let pp = pFrom;
          for (let k = idxFrom + 1; k <= idxTo; k++) {
            const segLen = distFt[k] - distFt[k-1];
            const dh = elevationsFt[k] - elevationsFt[k-1];
            pp = pp + (-dh) * PSI_PER_FOOT_WATER - lossPerFt * segLen;
          }
          return pp;
        }

        function nextFailIndex() {
          let pp = p;
          for (let k = i0 + 1; k < distFt.length; k++) {
            const segLen = distFt[k] - distFt[k-1];
            const dh = elevationsFt[k] - elevationsFt[k-1];
            pp = pp + (-dh) * PSI_PER_FOOT_WATER - lossPerFt * segLen;
            if (pp < minSuction) return k;
          }
          return -1;
        }

        while (i0 < distFt.length - 1) {
          const fi = nextFailIndex();
          if (fi < 0) break;

          // pick placement near valley before failure (scan back up to 12 indices)
          const lo = Math.max(i0 + 1, fi - 12);
          const hi = Math.max(i0 + 1, fi - 1);
          let placeIdx = lo, bestP = Infinity;
          for (let k = lo; k <= hi; k++) {
            const pk = simulateTo(i0, p, k);
            if (pk < bestP) { bestP = pk; placeIdx = k; }
          }

          // compute discharge from curve for a horizon ahead (from placeIdx to min(placeIdx+N,end))
          const aheadIdx = Math.min(distFt.length - 1, placeIdx + 20);
          const horizonDist = distFt[aheadIdx] - distFt[placeIdx];
          const horizonElev = elevationsFt[aheadIdx] - elevationsFt[placeIdx];
          const inletAtPlace = simulateTo(i0, p, placeIdx);

          // Enforce positive suction/NPSH at placement by moving upstream if needed.
          // Convert inlet PSI to feet of water head for NPSH comparison.
          function psiToFeet(psi){ return psi / PSI_PER_FOOT_WATER; }
          let adjustedIdx = placeIdx;
          let inletPsiTrue = inletAtPlace;
          let inletHeadFt = psiToFeet(inletPsiTrue);
          // Approximate NPSHR at current flow (use both families and take the min requirement)
          const gpmForNpsh = bpmToGpm(flowBpm);
          const npshr8hnth = PUMP_8HNTH.npshrAt(Math.max(PUMP_8HNTH.domain().minQ, Math.min(PUMP_8HNTH.domain().maxQ, gpmForNpsh)));
          const npshr8nht4 = PUMP_8NHT4VA.npshrAt(Math.max(PUMP_8NHT4VA.domain().minQ, Math.min(PUMP_8NHT4VA.domain().maxQ, gpmForNpsh)));
          const npshrReqFt = Math.min(npshr8hnth, npshr8nht4); // optimistic, ensures at least one family is feasible
          const suctionFloorPsi = Math.max(minSuction, 0);     // user floor in PSI

          // Shift upstream until both inlet PSI ≥ user floor and inlet head ≥ NPSHR
          while (adjustedIdx > i0 + 1) {
            if (inletPsiTrue >= suctionFloorPsi && inletHeadFt >= npshrReqFt) break;
            adjustedIdx -= 1;
            inletPsiTrue = simulateTo(i0, p, adjustedIdx);
            inletHeadFt = psiToFeet(inletPsiTrue);
          }
          placeIdx = adjustedIdx;

          function computeForFamily(famKey, policy){
            return computePumpDischargeByCurve({
              inletPsi: Math.max(inletPsiTrue, suctionFloorPsi),
              maxHosePsi: maxHose,
              flowBpm: flowBpm,
              psiLossPerFt: lossPerFt,
              upcomingElevFt: horizonElev,
              upcomingDistFt: horizonDist,
              family: famKey,
              policy
            });
          }
          let curve;
          if (placementStrategy === 'curve_8hnth') {
            curve = computeForFamily('8HNTH','max');
          } else if (placementStrategy === 'curve_8nht4va') {
            curve = computeForFamily('8NHT4VA','max');
          } else {
            // auto-pick with suction feasibility: evaluate both families with 'max' policy,
            // discard family if resulting discharge would back-calc inlet below NPSHR (rare) then pick best head.
            const c1 = computeForFamily('8HNTH','max');
            const c2 = computeForFamily('8NHT4VA','max');
            // Prefer higher discharge; tie-break on head, then lower RPM
            const pick = (c1.dischargePsi > c2.dischargePsi + 1e-6) ? c1 : (c2.dischargePsi > c1.dischargePsi + 1e-6 ? c2 :
                         (c1.headAddedFt > c2.headAddedFt + 1e-6 ? c1 : (c2.headAddedFt > c1.headAddedFt + 1e-6 ? c2 :
                         ((c1.rpm||9999) <= (c2.rpm||9999) ? c1 : c2))));
            curve = pick; curve.family = (pick === c1) ? '8HNTH' : '8NHT4VA';
          }

          // Enforce feasible inlet: shift upstream until inlet ≥ minSuction and ≥ 0 PSI
          function isFeasibleInletCurve(psi) { return psi >= Math.max(minSuction, 0); }
          while (placeIdx > i0 + 1) {
            inletPsiTrue = simulateTo(i0, p, placeIdx);
            if (isFeasibleInletCurve(inletPsiTrue)) break;
            placeIdx -= 1;
          }
          inletPsiTrue = simulateTo(i0, p, placeIdx);
          if (!isFeasibleInletCurve(inletPsiTrue)) {
            return { pumps, finalPressure: NaN, infeasible: true, infeasibleAtFt: distFt[placeIdx] };
          }

          pumps.push({
            index: placeIdx,
            distanceFt: distFt[placeIdx],
            pressureBefore: inletPsiTrue,
            discharge: curve.dischargePsi,
            rpm: curve.rpm,
            headAddedFt: curve.headAddedFt,
            qgpm: curve.Qgpm,
            family: curve.family || (placementStrategy === 'curve_8nht4va' ? '8NHT4VA' : '8HNTH')
          });

          // reset state
          i0 = placeIdx;
          p = curve.dischargePsi;
        }

        const finalPressure = simulateTo(i0, p, distFt.length - 1);
        auto = { pumps, finalPressure };
      } else {
        // Fixed setpoint mode (existing minimized algorithm)
        auto = placeMidlinePumpsMinimized(distFt, elevationsFt, sourcePsi, midlinePsi, minSuction, usedPsiLossPer100);
      }

      // Path status line
      updatePathStatus(dsLatLngs, distFt[distFt.length - 1] || 0);

      // Hide manual panel when not in manual mode
      const mp = document.getElementById('manual-panel');
      if (mp) mp.style.display = (placementStrategy === 'manual') ? 'block' : 'none';
      manualMode = (placementStrategy === 'manual');

      // Build final pressure profile with placed pumps
      const prof = buildProfileWithPumps(distFt, elevationsFt, sourcePsi, auto.pumps, usedPsiLossPer100);

      const distancesForChart = prof.distances || [];
      const pressures = prof.pressures || [];

      // Checks
      if (pressures.some(p => p > maxHose)) {
        warnings.push('Calculated pressure exceeds the maximum hose rating somewhere along the line.');
      }

      // Map render
      renderPathOnMap(dsLatLngs, auto.pumps);
      // Keep pumps for report details (raw inlet preserved)
      // Also persist the actual placement strategy used for the run (for report header)
      window.__lastPumps = Array.isArray(auto.pumps) ? auto.pumps.map(p => ({...p})) : [];
      window.__lastPlacementStrategy = placementStrategy;

      // If algorithm declared infeasible, surface an explicit warning and set outlet/met accordingly
      if (auto.infeasible) {
        warnings.push(`Planning infeasible: cannot place pump with acceptable inlet (≥ ${Math.max(minSuction,0).toFixed(1)} PSI). Last attempt near ${Math.round(auto.infeasibleAtFt||0)} ft.`);
      }

      // Results + chart
      renderResults(totalFt, usedPsiLossPer100, auto.finalPressure, auto.pumps.length, warnings, distancesForChart, pressures, minSuction);
    }

    document.getElementById('run-calc').addEventListener('click', runCalc);

    // --- Printable Report (new tab) ---
    function milesFromFeet(ft) { return (Number(ft||0) / 5280); }
    function fmt(n, digits=1) { return isFinite(n) ? Number(n).toFixed(digits) : '—'; }

    function buildReportHtml(state) {
      const dt = new Date();
      const dateStr = dt.toLocaleDateString() + ' ' + dt.toLocaleTimeString();
      const totalMi = milesFromFeet(state.results.totalFt);
      const usedLoss = state.results.usedPsiLossPer100;

      // Helper to compute NPSHR used (min across families) for the flow in the run
      const qgpm = bpmToGpm(state.flowBpm || 0);
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const q8h = clamp(qgpm, (PUMP_8HNTH?.domain().minQ)||0, (PUMP_8HNTH?.domain().maxQ)||qgpm);
      const q8v = clamp(qgpm, (PUMP_8NHTA?.domain().minQ)||0, (PUMP_8NHTA?.domain().maxQ)||qgpm);
      const npshrMinFt = Math.min(
        PUMP_8HNTH ? PUMP_8HNTH.npshrAt(q8h) : Infinity,
        PUMP_8NHTA ? PUMP_8NHTA.npshrAt(q8v) : Infinity
      );
      const npshMarginFt = 5;
      const npshrWithMarginFt = undefined; // suppress NPSHR note in manual-mode report

      // Build per-pump rows with curve details where available
      const pumpRows = (state.pumpsSummary || []).map((p, i) => {
        const distMi = milesFromFeet(p.distanceFt);
        const fam = p.family ? String(p.family) : '—';
        const rpm = p.rpm != null ? `${p.rpm}` : '—';
        const head = p.headAddedFt != null ? `${fmt(p.headAddedFt,0)} ft` : '—';
        const q = p.qgpm != null ? `${fmt(p.qgpm,0)} gpm` : '—';
        return `
          <tr>
            <td>#${i+1}</td>
            <td>${fmt(distMi, 2)} mi</td>
            <td>${fmt(p.pressureBefore, 1)} PSI</td>
            <td>${fmt(p.discharge, 1)} PSI</td>
            <td>${fam}</td>
            <td>${rpm}</td>
            <td>${head}</td>
            <td>${q}</td>
          </tr>`;
      }).join('') || `<tr><td colspan="8">No midline pumps placed</td></tr>`;

      // Inline CSS optimized for 8.5x11 portrait, narrow centered stack
      const styles = `
        <style>
          @page { size: 8.5in 11in; margin: 0.5in; }
          :root { --fg:#111; --muted:#555; --line:#dcddea; --accent:#0b5fff; --soft:#eef2ff; }
          * { box-sizing: border-box; }
          body { font-family: 'ISOCPEUR', Arial, sans-serif; color:var(--fg); background:white; font-size: 14px; }
          .wrap { max-width: 820px; margin: 0 auto; }
          .hdr { text-align:center; margin: 8px 0 14px; }
          .title { font-size:28px; font-weight:800; margin:4px 0 0; letter-spacing:0.2px; }
          .subtitle { font-size:13px; color:var(--muted); }
          .card { border:1px solid var(--line); border-radius:12px; padding:14px 16px; background:#fff; }
          .section-h { font-size:16px; font-weight:700; margin: 0 0 8px; color:#222; }
          .stack { display:grid; grid-template-columns: 1fr; gap:8px; }
          .kv { display:flex; justify-content:space-between; gap:10px; font-size:14px; line-height:1.35; }
          .kv .k { color:#333; font-weight:600; }
          .kv .v { color:#111; font-weight:700; }
          .chips { display:flex; flex-wrap:wrap; gap:8px; margin-top:6px; }
          .chip { font-size:12px; padding:4px 10px; border-radius:999px; background:var(--soft); border:1px solid #d8ddff; color:#222; font-weight:600; }
          table { width:100%; border-collapse: collapse; font-size:14px; }
          th, td { border: 1px solid var(--line); padding:8px 9px; text-align:left; }
          th { background:#f3f5ff; font-weight:800; }
          .chart { width:100%; height:320px; margin-top:8px; border:1px solid #e3e6ff; border-radius:10px; }
          .badge { display:inline-block; padding:2px 9px; border-radius:10px; color:#fff; font-size:12px; font-weight:700; }
          .good { background:#198754; }
          .bad { background:#dc3545; }
          .note { font-size:12px; color:var(--muted); margin-top:8px; }
          /* Axes labels for inline SVG */
          .axis-label {
            font-size: 20px;
            font-weight: 800;
            fill: #222;
            font-family: 'ISOCPEUR', Arial, sans-serif;
          }
        </style>
      `;

      // Embed profile as SVG (no external libs)
      const distances = state.profile.distances || [];
      const pressures = state.profile.pressures || [];
      const svg = buildSimplePressureSvg(distances, pressures, state.minSuction);

      const runsLabel = state.hoseRuns ? (state.hoseRuns === 2 ? 'Dual (parallel)' : 'Single') : 'Single';
      return `
        <!doctype html>
        <html>
          <head><meta charset="utf-8">${styles}<title>Layflat Line Report</title></head>
          <body>
            <div class="wrap">
              <div class="hdr">
                <div class="title">Line Profile Report</div>
                <div class="subtitle">Generated ${dateStr}</div>
              </div>

              <div class="card" style="margin-bottom:10px;">
                <div class="section-h">Manual Mode Summary</div>
                <div class="stack">
                  <div class="kv"><div class="k">Distance</div><div class="v">${fmt(totalMi,2)} miles</div></div>
                  <div class="kv"><div class="k">Desired Rate</div><div class="v">${fmt(state.flowBpm,0)} BPM</div></div>
                  <div class="kv"><div class="k">Hose Diameter</div><div class="v">${fmt(state.hoseIn,0)} in</div></div>
                  <div class="kv"><div class="k">Hose Runs</div><div class="v">${runsLabel}</div></div>
                  <div class="kv"><div class="k">Friction Loss</div><div class="v">${fmt(usedLoss,4)} PSI/100 ft</div></div>
                  <div class="kv"><div class="k">Max Hose PSI</div><div class="v">${fmt(state.maxHose,0)} PSI</div></div>
                  <div class="kv"><div class="k">Loss Method</div><div class="v">${state.lossMethod}</div></div>
                  <div class="kv"><div class="k">Path Direction</div><div class="v">${state.pathDir === 'dest_to_source' ? 'Destination → Source' : 'Source → Destination'}</div></div>
                </div>
                <!-- NPSHR note intentionally removed for manual-mode report -->
                <div class="chips">
                  <span class="chip">Source Discharge: ${fmt(state.sourcePsi,1)} PSI</span>
                  <span class="chip">Midline Setpoint: ${fmt(state.midlinePsi,1)} PSI</span>
                  <span class="chip">Final Outlet: ${fmt(state.results.finalPressure,1)} PSI</span>
                  <span class="chip">Manual Pumps: ${(state.pumpsSummary||[]).length}</span>
                </div>
              </div>

              <div class="card" style="margin-bottom:10px;">
                <div class="section-h">Midline Pumps</div>
                <table>
                  <thead>
                    <tr>
                      <th>#</th><th>Distance</th><th>Inlet PSI</th><th>Discharge PSI</th>
                      <th>Family</th><th>RPM</th><th>Head Added</th><th>Flow</th>
                    </tr>
                  </thead>
                  <tbody>${pumpRows}</tbody>
                </table>
              </div>

              <div class="card">
                <div class="section-h">Pressure Profile</div>
                <div class="chart">${svg}</div>
                ${state.results.warnings && state.results.warnings.length ? `
                  <div class="section-h" style="margin-top:10px;">Warnings</div>
                  <ul class="note">${state.results.warnings.map(w => `<li>${w}</li>`).join('')}</ul>
                ` : ''}
              </div>
            </div>
          </body>
        </html>
      `;
    }

    // Render a basic SVG pressure chart without external libraries
    function buildSimplePressureSvg(distances, pressures, minLine) {
      if (!Array.isArray(distances) || !Array.isArray(pressures) || distances.length < 2) {
        return '<div class="center" style="padding:20px;color:#666;">No chart data</div>';
      }
      const width = 900, height = 300, padL = 60, padR = 10, padT = 10, padB = 38;
      const minX = distances[0], maxX = distances[distances.length-1];

      // Only include a solid red Max Hose line; remove the yellow min-suction reference line
      const maxHosePsi = Number(window.__modelerLastRun?.maxHose ?? 0);

      // Determine Y extents considering pressures and max hose reference (omit minLine entirely)
      const valuesForY = [...pressures];
      if (isFinite(maxHosePsi)) valuesForY.push(maxHosePsi);
      let minY = Math.min(...valuesForY);
      let maxY = Math.max(...valuesForY);
      if (!isFinite(minY) || !isFinite(maxY) || minY === maxY) { minY = 0; maxY = 1; }

      // Nice tick generation utilities
      function niceStep(span, maxTicks) {
        const rough = span / Math.max(1, maxTicks);
        const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
        const candidates = [1, 2, 2.5, 5, 10].map(m => m * pow10);
        // choose the step that yields tick count closest to maxTicks
        let best = candidates[0], bestDiff = Infinity;
        for (const s of candidates) {
          const n = Math.ceil(span / s);
          const diff = Math.abs(n - maxTicks);
          if (diff < bestDiff) { bestDiff = diff; best = s; }
        }
        return best;
      }
      function linspaceTicks(minV, maxV, desired) {
        const span = Math.max(1e-9, maxV - minV);
        const step = niceStep(span, desired);
        const start = Math.ceil(minV / step) * step;
        const ticks = [];
        for (let v = start; v <= maxV + 1e-9; v += step) ticks.push(Number(v.toFixed(10)));
        return { ticks, step };
      }

      // Create scales
      const sx = x => padL + (x - minX) * (width - padL - padR) / (maxX - minX || 1);
      const sy = y => height - padB - (y - minY) * (height - padT - padB) / (maxY - minY || 1);

      // Build polyline points
      const pts = distances.map((d,i) => `${sx(d)},${sy(pressures[i])}`).join(' ');

      // Axis ticks (aim ~6 on each axis)
      const yTicksInfo = linspaceTicks(minY, maxY, 6);
      const xTicksInfo = linspaceTicks(minX, maxX, 6);
      const fmtFeet = n => Number(n).toLocaleString(undefined, { maximumFractionDigits: 0 });

      const yTicksSvg = yTicksInfo.ticks.map(v => `
        <line x1="${padL-4}" y1="${sy(v)}" x2="${padL}" y2="${sy(v)}" stroke="#777" stroke-width="1"/>
        <line x1="${padL}" y1="${sy(v)}" x2="${width-padR}" y2="${sy(v)}" stroke="#e9ecff" stroke-width="1"/>
        <text x="${padL-8}" y="${sy(v)+4}" text-anchor="end" font-size="11" fill="#444"
              font-family="'ISOCPEUR', Arial, sans-serif">${Math.round(v)}</text>
      `).join('');

      const xTicksSvg = xTicksInfo.ticks.map(v => `
        <line x1="${sx(v)}" y1="${height-padB}" x2="${sx(v)}" y2="${height-padB+4}" stroke="#777" stroke-width="1"/>
        <line x1="${sx(v)}" y1="${padT}" x2="${sx(v)}" y2="${height-padB}" stroke="#f2f4ff" stroke-width="1"/>
        <text x="${sx(v)}" y="${height-padB+16}" text-anchor="middle" font-size="11" fill="#444"
              font-family="'ISOCPEUR', Arial, sans-serif">${fmtFeet(v)}</text>
      `).join('');

      // Max hose (solid red) + label
      const maxHoseLine = isFinite(maxHosePsi) && maxHosePsi > 0 ? `
        <line x1="${sx(minX)}" y1="${sy(maxHosePsi)}" x2="${sx(maxX)}" y2="${sy(maxHosePsi)}"
              stroke="#dc3545" stroke-width="2" />
        <text x="${sx(maxX) - 8}" y="${sy(maxHosePsi) - 6}" text-anchor="end"
              font-size="12" font-weight="700" fill="#dc3545"
              font-family="'ISOCPEUR', Arial, sans-serif">
          User-defined Max Pressure (PSI)
        </text>
      ` : '';

      return `
        <svg viewBox="0 0 ${width} ${height}" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
          <rect x="0" y="0" width="${width}" height="${height}" fill="white" />
          <!-- Axes base lines -->
          <line x1="${padL}" y1="${padT}" x2="${padL}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <line x1="${padL}" y1="${height-padB}" x2="${width-padR}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <!-- Grid + tick labels -->
          ${yTicksSvg}
          ${xTicksSvg}
          <!-- Axis labels -->
          <text class="axis-label" x="${(padL + (width - padR)) / 2}" y="${height - 4}" text-anchor="middle">Distance (ft)</text>
          <text class="axis-label" transform="translate(16 ${(padT + (height - padB)) / 2}) rotate(-90)" text-anchor="middle">Pressure (PSI)</text>
          <!-- Data -->
          ${maxHoseLine}
          <polyline fill="none" stroke="#0b5fff" stroke-width="2" points="${pts}" />
        </svg>
      `;
    }

    function openReport() {
      const state = window.__modelerLastRun;
      if (!state) {
        alert('Run a calculation with a valid path before generating a report.');
        return;
      }
      const html = buildReportHtml(state);
      const w = window.open('', '_blank');
      if (!w) { alert('Popup blocked. Allow popups to view the report.'); return; }
      w.document.open();
      w.document.write(html);
      w.document.close();
      // Try to trigger print preview after load for convenience
      w.onload = () => { try { w.focus(); } catch {} };
    }

    const reportBtn = document.getElementById('generate-report');
    if (reportBtn) {
      reportBtn.addEventListener('click', openReport);
    }

    // --- Input-change mechanics: no auto-run; require explicit Run Calculation ---

    // Clear derived UI when inputs change to prevent reading stale values
    function clearDerivedUI() {
      // Hide previous results/chart until the next run completes
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';
      // Keep map section visible but clear pumps so user sees path without stale boosts
      if (pumpLayer) { try { pumpLayer.clearLayers(); } catch {} }
      // Disable report and clear last run to avoid stale report generation
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = true;
      delete window.__modelerLastRun;
    }

    // Whenever a user changes inputs that affect hydraulics, just clear derived UI (no auto run)
    const hydraulicInputs = [
      elFlowBpm, elHoseSize, elSourcePsi, elMidlinePsi,
      elMaxHose, elManualPsi100, elPlacementStrategy, elHoseRuns
    ];
    hydraulicInputs.forEach(inp => {
      if (!inp) return;
      inp.addEventListener('input', () => { clearDerivedUI(); });
      inp.addEventListener('change', () => { clearDerivedUI(); });
    });

    // Friction loss method radios
    lossRadios.forEach(r => {
      r.addEventListener('change', () => { updateManualVisibility(); clearDerivedUI(); });
    });

    // Path direction radios (reverse path)
    pathDirRadios.forEach(r => {
      r.addEventListener('change', () => { clearDerivedUI(); });
    });

    // When a new KML/KMZ is selected, clear outputs; user must press Run Calculation
    elKmlFile.addEventListener('change', () => {
      // Clear everything visual so a new file doesn't mix with old output
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = true;
      delete window.__modelerLastRun;

      if (chartInstance) { try { chartInstance.destroy(); } catch {} chartInstance = null; }
      if (mapInstance) {
        // Remove old layers/instance to ensure a clean start
        try { mapInstance.remove(); } catch {}
        mapInstance = null; pathLayer = null; pumpLayer = null;
      }
    });

    // Remove previous auto-run blur handler: no-op now
  </script>
</body>
</html>