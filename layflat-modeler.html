<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Layflat Hydraulic Modeler</title>
  <link rel="stylesheet" href="css/style.css"/>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <!-- Leaflet CSS for map preview -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    /* Page-local styles for the modeler (kept minimal; reuses global font) */
    .modeler-wrap {
      max-width: 1000px;
      margin: 0 auto;
      padding: 12px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
    }
    .site-header {
      padding: 10px;
      border-bottom: 1px solid #e5e5e5;
      background: #fff;
      font-family: 'ISOCPEUR', Arial, sans-serif;
    }
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .field label {
      font-size: 13px;
    }
    .field input[type="number"], .field select, .field input[type="file"] {
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      background: #fff;
      color: #222;
    }
    .radio-row {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      font-size: 14px;
    }
    .section-card {
      background: #fff;
      border: 1px solid #e5e5e5;
      border-radius: 10px;
      padding: 14px;
      margin-top: 14px;
    }
    .section-card h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
    }
    .btn {
      display: inline-block;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #0b5fff;
      color: #fff;
      text-decoration: none;
      cursor: pointer;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      font-size: 14px;
      border-color: #084bd1;
    }
    .btn[disabled] {
      opacity: 0.65;
      cursor: not-allowed;
    }
    .btn.secondary {
      background: #f9f9f9;
      color: #333;
      border-color: #ddd;
    }
    .inline-help {
      font-size: 12px;
      color: #666;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .results-table th, .results-table td {
      border: 1px solid #e5e5e5;
      padding: 6px 8px;
    }
    .results-table th {
      background: #f8f8f8;
      text-align: left;
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      color: #fff;
    }
    .badge.good { background: #198754; }
    .badge.bad { background: #dc3545; }
    .warnings {
      margin: 8px 0 0 18px;
      color: #b58900;
    }
    .chart-box {
      position: relative;
      height: 320px;
      width: 100%;
    }
    /* Map preview box */
    #busy-overlay {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.75);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(1px);
    }
    .busy-card {
      background: #ffffff;
      border: 1px solid #e5e5e5;
      border-radius: 10px;
      padding: 14px 16px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.15);
      font-family: 'ISOCPEUR', Arial, sans-serif;
      color: #333;
      min-width: 260px;
      text-align: center;
    }
    .spinner {
      width: 22px;
      height: 22px;
      border: 3px solid #cfd8ff;
      border-top-color: #0b5fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 10px;
      flex: 0 0 auto;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #modeler-map {
      height: 350px;
      width: 100%;
      border: 1px solid #e5e5e5;
      border-radius: 10px;
    }

    /* Manual Pump List layout */
    .manual-pump-list {
      display: grid;
      gap: 10px;
    }
    .manual-pump-row {
      display: grid;
      grid-template-columns: 1fr 1fr 280px auto;
      gap: 10px 12px;
      align-items: end;
      margin-bottom: 4px;
    }
    .mp-col--id,
    .mp-col--inlet {
      font-size: 14px;
      line-height: 1.3;
    }
    .mp-col--disch {
      display: grid;
      grid-template-columns: 110px 1fr;
      align-items: center;
      gap: 8px;
    }
    .mp-label {
      font-size: 12px;
      color: #666;
      margin: 0;
      text-align: right;
    }
    .mp-input {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      background: #fff;
      color: #222;
    }
    .mp-col--actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
    }

    /* Stack nicely on narrow screens */
    @media (max-width: 640px) {
      .manual-pump-row {
        grid-template-columns: 1fr 1fr;
      }
      .mp-col--actions {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body class="modeler-page">
  <header class="site-header" role="banner">
    <strong>Layflat Hydraulic Modeler</strong>
  </header>

  <main class="modeler-wrap" role="main">
    <!-- Introductory guidance -->
    <section class="section-card" style="background:#fcfcff;">
      <h3>How to use this tool</h3>
      <p class="inline-help" style="max-width:880px;">
        This calculator estimates pressure along a layflat hose route. You manually place midline booster pumps on the map and adjust their discharge setpoints to shape the pressure profile. KML only: upload a .kml file that contains a single simple LineString path. KMZ is not supported.
      </p>
      <ol class="inline-help" style="max-width:880px; margin-top:6px; padding-left:18px;">
        <li>Create a KML file containing one LineString that follows your hose path on the ground. You can draw this in Google Earth or other GIS tools.</li>
        <li>Upload the KML below. Choose the drawing direction so the path begins at your Source pump and ends at the Destination (or reverse if needed).</li>
        <li>Set your hydraulic inputs (flow, hose diameter, pressure limits). Choose how friction loss is determined (lookup vs manual).</li>
        <li>Click "Run Calculation". The map will display your path, and “Manual Pumps” mode will be enabled.</li>
        <li>Place manual midline pumps:
          <ul style="margin:6px 0 0 18px;">
            <li>Click along the red path to add a booster pump at that location.</li>
            <li>Drag a pump marker to move it along the path.</li>
            <li>Click a marker to delete it.</li>
            <li>Edit each pump’s “Discharge PSI” in the Manual Pumps panel; the profile updates immediately.</li>
          </ul>
        </li>
        <li>Review outputs:
          <ul style="margin:6px 0 0 18px;">
            <li>Map preview of your path and manually placed pumps.</li>
            <li>Pressure profile chart showing the impact of pump placement and discharge settings.</li>
            <li>Results summary including total distance, used friction loss, final outlet pressure, and pump count.</li>
          </ul>
        </li>
        <li>When satisfied, click “Generate Report” to open a printable summary of inputs, pump list, and the pressure profile.</li>
      </ol>
      <p class="inline-help" style="max-width:880px; margin-top:8px;">
        Notes: Elevations are sampled from public terrain data and may be approximate.
      </p>
    </section>

    <!-- 1) Path first: user uploads KML up front -->
    <section class="section-card">
      <h3>Path (KML only)</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Upload a .kml file containing one LineString. If the route was drawn from Destination back to Source, use the "Reverse" option so the simulation starts at the Source pump.
      </p>
      <div class="form-grid">
        <div class="field">
          <label for="kml-file">Upload KML (LineString path)</label>
          <input id="kml-file" type="file" accept=".kml">
          <div class="inline-help">Up to ~2,000 points are used (downsampling applied if needed). Direction can be reversed below.</div>
        </div>
        <div class="field">
          <label>Path Drawing Direction</label>
          <div class="radio-row">
            <label><input type="radio" name="path-dir" value="source_to_dest" checked> Source → Destination</label>
            <label><input type="radio" name="path-dir" value="dest_to_source"> Destination → Source (Reverse)</label>
          </div>
          <div class="inline-help">Pick the direction that matches how your LineString was drawn so the "Source" end is simulated first.</div>
        </div>
      </div>
      <div class="inline-help" id="path-status" style="margin-top:8px;display:none;"></div>
    </section>

    <!-- 2) Core hydraulics inputs -->
    <section class="section-card">
      <h3>Hydraulic Inputs</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Set operating parameters for your system. After you click Run Calculation, give it a second to process.
      </p>
      <div class="inline-help" style="margin-top:6px; color:#444; line-height:1.45;">
        <strong>How friction loss is calculated</strong>: The PSI loss per 100 ft is derived from an empirical lookup table that was measured on a 12‑inch layflat system at various flows (converted from barrels per minute to GPM). For 12" hose, we interpolate between the nearest table points to get the head loss in feet per 100 ft, then convert to PSI using 0.433 PSI/ft of water column.
        <br/><br/>
        For 14" and 16" hoses, the 12" baseline is scaled using a standard hydraulic similarity relationship where head loss varies with diameter to approximately the 4.87 power. In practice this means larger diameters have proportionally lower friction loss for the same total flow. Mathematically, Loss(target) ≈ Loss(12") × (12 / target_diameter)^4.87. When dual parallel runs are selected, the total flow is split evenly between the hoses and the resulting per‑run loss is divided by the number of runs.
      </div>
      <div class="form-grid">
        <div class="field">
          <label for="flow-bpm">Flow Rate (Barrels per minute)</label>
          <input id="flow-bpm" type="number" step="0.1" min="0" value="75" data-default="75">
        </div>

        <div class="field">
          <label for="hose-size">Hose Diameter</label>
          <select id="hose-size" data-default="12">
            <option value="12" selected>12 inches</option>
            <option value="14">14 inches</option>
            <option value="16">16 inches</option>
          </select>
        </div>

        <div class="field">
          <label for="source-psi">Source Pump Discharge (PSI)</label>
          <input id="source-psi" type="number" step="0.1" min="0.1" value="100" data-default="100">
          <div class="inline-help">Starting pressure at the source.</div>
        </div>

        <div class="field">
          <label for="midline-psi">Default Booster Discharge (PSI)</label>
          <input id="midline-psi" type="number" step="0.1" min="0" value="100" data-default="100">
          <div class="inline-help">Default discharge applied when adding a manual booster. You can change per-pump in the panel.</div>
        </div>

        <div class="field">
          <label for="max-hose-psi">Max Allowable Hose Pressure (PSI)</label>
          <input id="max-hose-psi" type="number" step="1" min="1" value="150" data-default="150">
        </div>


        <div class="field">
          <label for="hose-runs">Hose Runs</label>
          <select id="hose-runs" data-default="1">
            <option value="1" selected>Single</option>
            <option value="2">Dual (parallel)</option>
          </select>
          <div class="inline-help">Dual run uses two parallel hoses. Friction loss is reduced accordingly for the same total flow.</div>
        </div>
      </div>

      <div class="section-card" style="margin-top:12px;">
        <div class="field">
          <label>Friction Loss</label>
          <div class="radio-row">
            <label><input type="radio" name="loss-method" value="lookup" checked> Calculate from Flow & Hose Size</label>
            <label><input type="radio" name="loss-method" value="manual"> Enter PSI Loss Manually</label>
          </div>
          <div class="inline-help">Used to calculate friction loss along LinePath.</div>
        </div>
        <div id="manual-loss-wrap" class="field" style="display:none; margin-top:8px;">
          <label for="manual-loss-psi100">Manual PSI Loss per 100 ft</label>
          <input id="manual-loss-psi100" type="number" step="0.01" min="0" value="0" data-default="0">
        </div>
      </div>

      <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;">
        <button id="run-calc" class="btn">Run Calculation</button>
        <button id="reset-form" class="btn secondary">Reset</button>
        <button id="generate-report" class="btn secondary" title="Open printable report in a new tab" disabled>Generate Report</button>
      </div>
    </section>

    <section class="section-card" id="map-section" style="display:none;">
      <h3>Map Preview</h3>
      <p class="inline-help" style="margin-top:-6px;">
        The polyline shows your uploaded path.
        Click on the red line to add manual booster pumps.
      </p>
      <div id="modeler-map"></div>
      <div class="inline-help" id="map-hint" style="margin-top:6px;">Path and pump markers will display here after KML processing.</div>

      <div id="elev-retry-wrap" style="display:none; margin-top:8px;">
        <button id="retry-elev" class="btn secondary">Retry Elevations</button>
        <span class="inline-help">Elevation sampling failed. Retry will re-fetch elevation and refresh results.</span>
      </div>

      <div id="manual-panel" class="section-card" style="margin-top:10px; display:none;">
        <h3 style="margin-top:0;">Manual Pumps</h3>
        <div class="inline-help" style="margin-top:-6px;">
          Click on the red polyline to add a booster pump. Drag markers to move along the line. Click a marker to delete. Edit discharge setpoints below.
        </div>
        <div id="manual-pump-list" class="manual-pump-list" style="margin-top:8px;"></div>
      </div>
    </section>

    <section class="section-card" id="results-section" style="display:none;">
      <h3>Results Summary</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Total distance is derived from your path after downsampling (if applied).
      </p>
      <table class="results-table">
        <tbody>
          <tr><th>Total Distance (ft)</th><td id="out-total-dist">—</td></tr>
          <tr><th>Used PSI Loss / 100 ft</th><td id="out-used-loss">—</td></tr>
          <tr><th>Final Outlet Pressure (PSI)</th><td id="out-final-psi">—</td></tr>
          <tr><th>Midline Pumps Placed</th><td id="out-pump-count">—</td></tr>
        </tbody>
      </table>
      <div id="warnings-wrap" style="margin-top:8px; display:none;">
        <strong>Warnings</strong>
        <ul class="warnings" id="warnings-list"></ul>
      </div>
    </section>

    <section class="section-card" id="chart-section" style="display:none;">
      <h3>Pressure Profile</h3>
      <p class="inline-help" style="margin-top:-6px;">
        The blue line is pressure along the path (includes elevation changes and friction). Vertical jumps indicate pump boosts.
      </p>
      <div class="chart-box">
        <canvas id="pressureChart"></canvas>
      </div>
    </section>

    <section class="section-card" id="elev-chart-section" style="display:none;">
      <h3>Elevation Profile and Pump Location</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Elevation along the line (ft) with black dots at pump locations. X-axis is distance in miles.
      </p>
      <div class="chart-box">
        <canvas id="elevationChart"></canvas>
      </div>
    </section>
  </main>

  <footer class="site-footer" role="contentinfo">
    <nav class="footer-nav" aria-label="Footer">
      <a class="footer-link" href="index.html">Home</a>
      <a class="footer-link" href="layflat-modeler.html" aria-current="page">Layflat Hydraulic Modeler</a>
      <a id="resume-link" class="footer-link" href="resume.html" data-protected="true">Resume</a>
    </nav>
  </footer>

  <!-- Busy overlay -->
  <div id="busy-overlay" aria-live="polite" aria-busy="true">
    <div class="busy-card">
      <div style="display:flex;align-items:center;justify-content:center;">
        <div class="spinner" aria-hidden="true"></div>
        <div class="busy-text">Loading…</div>
      </div>
    </div>
  </div>
 
  <!-- Leaflet JS for map preview -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
 
  <!-- Chart.js for pressure plot -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  

  <!-- Lightweight client-side gate for Resume link -->
  <script>
    (function(){
      const link = document.getElementById('resume-link');
      if (!link) return;
      const PASSWORD = 'water2025';
      const STORAGE_KEY = 'resume_access_granted_v1';
      function hasAccess(){ try { return sessionStorage.getItem(STORAGE_KEY) === 'true'; } catch(_) { return false; } }
      function grantAccess(){ try { sessionStorage.setItem(STORAGE_KEY, 'true'); } catch(_) {} }
      function promptForPassword(){
        const input = window.prompt('Enter password to view the resume:');
        if (input === null) return false;
        if (input === PASSWORD) { grantAccess(); return true; }
        window.alert('Incorrect password.'); return false;
      }
      function handleNavigate(ev){
        if (hasAccess()) return;
        ev.preventDefault();
        if (promptForPassword()) {
          window.location.href = link.getAttribute('href') || 'resume.html';
        }
      }
      link.addEventListener('click', handleNavigate);
      link.addEventListener('keydown', function(e){
        if (e.key === 'Enter' || e.key === ' ') handleNavigate(e);
      });
    })();
  </script>
  <script>
    // --- Constants and data ---
    const BARRELS_TO_GALLONS = 42.0;
    const PSI_PER_FOOT_WATER = 0.433;

    // Backend proxy endpoint hosted on PythonAnywhere (Flask).
    // Prefer this to eliminate CORS/proxy/JSONP issues.
    const BACKEND_ELEV_ENDPOINT = '/elevation';

    // Keep original OpenTopoData URL for fallback path if backend is unavailable.
    const OPENTOPODATA_ENDPOINT = 'https://api.opentopodata.org/v1/ned10m';

    // Minimal proxy list retained ONLY for hard fallback after backend failure.
    const CORS_JSON_PROXIES = [
      { mode: 'prefix', value: 'https://r.jina.ai/' }
    ];

    const MAX_POINTS = 2000;          // hard cap for safety
    const BATCH_SIZE = 100;           // batch chunk (server matches this)
    // 12" reference table: [GPM, head loss (ft) per 100 ft]
    const HOSE_DATA_12_INCH = [
      [0,0.0],[300,0.03],[350,0.04],[400,0.04],[450,0.05],
      [500,0.06],[550,0.07],[600,0.09],[650,0.11],[700,0.13],
      [750,0.15],[800,0.17],[850,0.19],[900,0.21],[950,0.23],
      [1000,0.26],[1100,0.30],[1200,0.35],[1300,0.40],[1400,0.46],
      [1500,0.53],[1600,0.60],[1700,0.67],[1800,0.75],[1900,0.83],
      [2000,0.92],[2500,1.45],[3000,2.05],[3500,2.75],[4000,3.57],
      [4500,4.31],[5000,5.01]
    ];

    function bpmToGpm(bpm) { return bpm * BARRELS_TO_GALLONS; }

    function lookupHeadLoss12in(gpm) {
      if (gpm < 0) return null;
      if (gpm === 0) return 0.0;
      let lower = null, upper = null;
      for (let i=0;i<HOSE_DATA_12_INCH.length;i++) {
        const [x, y] = HOSE_DATA_12_INCH[i];
        if (x === gpm) return y;
        if (x < gpm) lower = [x,y];
        if (x > gpm) { upper = [x,y]; break; }
      }
      if (!lower && upper) return null;
      if (lower && !upper) return null;
      if (!lower || !upper) return null;
      const [x1,y1] = lower, [x2,y2] = upper;
      if (x2 === x1) return y1;
      return y1 + (y2 - y1) * (gpm - x1) / (x2 - x1);
    }

    function scaleHeadLossByDiameter(headLoss12, targetInches) {
      const d = Number(targetInches);
      if (!d || d <= 0) return headLoss12;
      if (d === 12) return headLoss12;
      const factor = Math.pow(12.0 / d, 4.87);
      return headLoss12 * factor;
    }

    function headLossFtToPsi(headLossFt) {
      return headLossFt * PSI_PER_FOOT_WATER;
    }

    // Small helper for retry backoff
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // Downsample coordinates to at most maxPoints using even index sampling
    function downsampleLatLngs(latlngs, maxPoints) {
      if (!latlngs || latlngs.length <= maxPoints) return latlngs || [];
      const result = [];
      const step = (latlngs.length - 1) / (maxPoints - 1);
      for (let i = 0; i < maxPoints; i++) {
        const idx = Math.round(i * step);
        result.push(latlngs[idx]);
      }
      return result;
    }

    // Parse KML text to extract first LineString coordinates as [lat, lng]
    function parseKmlLineStringToLatLngs(kmlText) {
      const parser = new DOMParser();
      const xml = parser.parseFromString(kmlText, 'text/xml');
      const coords = xml.getElementsByTagName('coordinates');
      if (!coords || !coords.length) return [];
      const text = coords[0].textContent || '';
      const parts = text.trim().split(/\s+/);
      const latlngs = [];
      for (const p of parts) {
        const [lonStr, latStr] = p.split(',');
        const lat = parseFloat(latStr), lon = parseFloat(lonStr);
        if (isFinite(lat) && isFinite(lon)) latlngs.push([lat, lon]);
      }
      return latlngs;
    }

    // KMZ parsing intentionally unsupported to simplify client-side; KML only.
    async function extractKmlFromKmz(file) {
      throw new Error('KMZ is not supported. Please upload a .kml file.');
    }

    // Fetch elevations with backend-first strategy; returns array of meters
    async function fetchElevationsOpenTopo(latlngs) {
      const elevations = [];

      async function fetchJson(url, init) {
        const resp = await fetch(url, init);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        return await resp.json();
      }

      // JSONP fallback kept for extreme cases (should rarely be needed now)
      async function fetchViaJsonp(url) {
        return new Promise((resolve, reject) => {
          const cbName = 'otd_cb_' + Math.random().toString(36).slice(2);
          let finished = false;
          let script = null;
          const cleanup = () => {
            try { delete window[cbName]; } catch {}
            if (script && script.parentNode) script.parentNode.removeChild(script);
          };
          const finish = (fn, val) => {
            if (finished) return;
            finished = true;
            cleanup();
            fn(val);
          };
          window[cbName] = (payload) => {
            try {
              const txt = typeof payload === 'string' ? payload : (payload && payload.contents) || '';
              const data = JSON.parse(txt);
              finish(resolve, data);
            } catch (e) {
              finish(reject, new Error('JSONP decode error'));
            }
          };
          const jsonpUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}&callback=${cbName}`;
          script = document.createElement('script');
          script.src = jsonpUrl;
          script.onerror = () => finish(reject, new Error('JSONP script load error'));
          document.head.appendChild(script);
          setTimeout(() => finish(reject, new Error('JSONP timeout')), 10000);
        });
      }

      const MAX_RETRIES = 2;

      for (let i = 0; i < latlngs.length; i += BATCH_SIZE) {
        const batch = latlngs.slice(i, i + BATCH_SIZE);
        const locArr = batch.map(([lat, lon]) => `${lat.toFixed(6)},${lon.toFixed(6)}`);

        let got = null;
        let attempt = 0;

        while (attempt <= MAX_RETRIES && !got) {
          try {
            // 1) Try our backend first (POST /elevation)
            const data = await fetchJson(BACKEND_ELEV_ENDPOINT, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
              body: JSON.stringify({ locations: locArr })
            });
            if (data && data.status === 'OK' && Array.isArray(data.results)) {
              got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
            } else {
              throw new Error('Backend invalid payload');
            }
          } catch (backendErr) {
            try {
              // 2) Fallback to reader proxy of OpenTopoData (GET)
              const locations = encodeURIComponent(locArr.join('|'));
              const directUrl = `${OPENTOPODATA_ENDPOINT}?locations=${locations}`;
              const proxiedUrl = `${CORS_JSON_PROXIES[0].value}${directUrl}`;
              const data = await fetchJson(proxiedUrl, { headers: { 'Accept': 'application/json' } });
              if (data && data.status === 'OK' && Array.isArray(data.results)) {
                got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
              } else {
                throw new Error('Proxy invalid payload');
              }
            } catch (proxyErr) {
              try {
                // 3) Last resort JSONP
                const locations = encodeURIComponent(locArr.join('|'));
                const directUrl = `${OPENTOPODATA_ENDPOINT}?locations=${locations}`;
                const data = await fetchViaJsonp(directUrl);
                if (!data || data.status !== 'OK' || !Array.isArray(data.results)) throw new Error('JSONP invalid payload');
                got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
              } catch (jsonpErr) {
                if (attempt === MAX_RETRIES) throw new Error('Elevation batch failed after retries');
              }
            }
          }

          if (!got) {
            await sleep(400 + attempt * 400);
            attempt++;
          }
        }

        if (!got) throw new Error('Elevation batch failed');

        elevations.push(...got);
      }
      return elevations;
    }

    // Compute cumulative distance in feet along polyline of [lat, lon] using simple haversine
    function cumulativeDistancesFt(latlngs) {
      const R = 6371000; // meters
      const toRad = d => d * Math.PI / 180;
      const dists = [0];
      let cum = 0;
      for (let i = 1; i < latlngs.length; i++) {
        const [lat1, lon1] = latlngs[i-1];
        const [lat2, lon2] = latlngs[i];
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const meters = R * c;
        const feet = meters * 3.28084;
        cum += feet;
        dists.push(cum);
      }
      return dists;
    }

    // [Removed] automatic midline pump placement (legacy)

    // Removed automatic placement algorithms (optimized/curve). Manual-only app.

    // Removed automatic placement algorithms (minimized/fixed-setpoint). Manual-only app.

    // Build pressure profile including placed pumps (clear boost visualization)
    // Returns an object with distances and pressures arrays aligned 1:1 for Chart.js
    function buildProfileWithPumps(distFt, elevFt, sourcePsi, pumps, psiLossPer100) {
      // Build pressure profile for plotting. Do NOT clamp the plotted pressures;
      // only clamp the displayed inlet values at pump markers elsewhere.
      const lossPerFt = psiLossPer100 / 100.0;
      const outDistances = [];
      const outPressures = [];
      let p = sourcePsi;
      let pumpIdx = 0;

      // Seed first point (true simulated pressure)
      outDistances.push(distFt[0]);
      outPressures.push(p);

      for (let i = 1; i < distFt.length; i++) {
        // Check if a pump exists exactly at index i
        if (pumpIdx < pumps.length && pumps[pumpIdx].index === i) {
          // Add point just before pump (true pressure at this location)
          outDistances.push(distFt[i]);
          outPressures.push(p);

          // Add point just after pump (boosted pressure at same location)
          p = pumps[pumpIdx].discharge;
          outDistances.push(distFt[i]);
          outPressures.push(p);
          pumpIdx++;
        }

        // Calculate pressure change through current segment
        const segLen = distFt[i] - distFt[i - 1];
        const dhFt = elevFt[i] - elevFt[i - 1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        p = p + elevDeltaPsi - frictionPsi;

        // Add end point of segment (true pressure)
        outDistances.push(distFt[i]);
        outPressures.push(p);
      }

      return { distances: outDistances, pressures: outPressures };
    }

    // --- DOM refs ---
    const elFlowBpm = document.getElementById('flow-bpm');
    const elHoseSize = document.getElementById('hose-size');
    const elSourcePsi = document.getElementById('source-psi');
    const elMidlinePsi = document.getElementById('midline-psi');
    const elMaxHose = document.getElementById('max-hose-psi');
    const elHoseRuns = document.getElementById('hose-runs');

    const lossRadios = document.querySelectorAll('input[name="loss-method"]');
    const elManualWrap = document.getElementById('manual-loss-wrap');
    const elManualPsi100 = document.getElementById('manual-loss-psi100');

    const elKmlFile = document.getElementById('kml-file');
    const pathDirRadios = document.querySelectorAll('input[name="path-dir"]');
    // Back-compat guard in case req-outlet existed in prior state
    try { const stale = document.getElementById('req-outlet-psi'); if (stale) stale.remove(); } catch {}

    const elRun = document.getElementById('run-calc');
    const elReset = document.getElementById('reset-form');

    const elMapSection = document.getElementById('map-section');
    const elResults = document.getElementById('results-section');
    const elOutDist = document.getElementById('out-total-dist');
    const elOutUsedLoss = document.getElementById('out-used-loss');
    const elOutFinalPsi = document.getElementById('out-final-psi');
    const elOutOutletMet = document.getElementById('out-outlet-met');
    const elOutPumpCount = document.getElementById('out-pump-count');
    const elWarningsWrap = document.getElementById('warnings-wrap');
    const elWarningsList = document.getElementById('warnings-list');

    const elChartSection = document.getElementById('chart-section');
    const chartCanvas = document.getElementById('pressureChart');

    // Elevation chart DOM
    const elElevChartSection = document.getElementById('elev-chart-section');
    const elevChartCanvas = document.getElementById('elevationChart');
 
    let chartInstance = null;
    let elevChartInstance = null;
    let mapInstance = null;
    let pathLayer = null;
    let pumpLayer = null;

    // Manual placement state
    let manualMode = false;
    let manualLatLngs = [];  // active path
    let manualDistFt = [];   // cumulative distances for path
    let manualElevFt = [];   // elevation samples for path
    // pumps: { index: i, distanceFt, discharge, pressureBefore (computed), marker }
    let manualPumps = [];

    // --- Elevation cache helpers (reuse elevations if KML path doesn't change) ---
    function pathKeyFromLatLngs(latlngs) {
      // Build a compact, stable string key from the downsampled coords
      // Use 6-decimal precision to match fetch batching precision
      if (!Array.isArray(latlngs) || !latlngs.length) return '';
      const parts = [];
      for (let i = 0; i < latlngs.length; i++) {
        const [lat, lon] = latlngs[i];
        parts.push(lat.toFixed(6) + ',' + lon.toFixed(6));
      }
      return parts.join('|');
    }

    // Simple in-memory cache keyed by pathKey
    window.__elevCache = window.__elevCache || Object.create(null);

    function getCachedElevationsFt(pathKey) {
      try {
        const entry = window.__elevCache[pathKey];
        if (!entry || !Array.isArray(entry.elevFt)) return null;
        return entry.elevFt.slice(); // return a copy
      } catch {
        return null;
      }
    }

    function setCachedElevationsFt(pathKey, elevFt) {
      try {
        window.__elevCache[pathKey] = { elevFt: Array.isArray(elevFt) ? elevFt.slice() : [] };
      } catch {}
    }

    function currentLossMethod() {
      for (const r of lossRadios) if (r.checked) return r.value;
      return 'lookup';
    }
    function currentPathDir() {
      for (const r of pathDirRadios) if (r.checked) return r.value;
      return 'source_to_dest';
    }
    function updateManualVisibility() {
      elManualWrap.style.display = currentLossMethod() === 'manual' ? 'block' : 'none';
    }
    lossRadios.forEach(r => r.addEventListener('change', updateManualVisibility));
    updateManualVisibility();

    function resetForm() {
      // Reset inputs to their initial defaults as in markup
      function valOrAttr(el) {
        if (!el) return;
        const def = el.getAttribute('data-default');
        if (def != null) {
          el.value = def;
        } else if (el.hasAttribute('value')) {
          el.value = el.getAttribute('value');
        }
      }
      valOrAttr(elFlowBpm);
      valOrAttr(elHoseSize);
      valOrAttr(elSourcePsi);
      valOrAttr(elMidlinePsi);
      valOrAttr(elMaxHose);
      valOrAttr(elManualPsi100);
      valOrAttr(elHoseRuns);

      // Reset radios to their original checked state using DOM attributes
      const lossLookup = document.querySelector('input[name="loss-method"][value="lookup"]');
      const lossManual = document.querySelector('input[name="loss-method"][value="manual"]');
      if (lossLookup) lossLookup.checked = lossLookup.hasAttribute('checked');
      if (lossManual) lossManual.checked = lossManual.hasAttribute('checked');

      const pathSrcToDest = document.querySelector('input[name="path-dir"][value="source_to_dest"]');
      const pathDestToSrc = document.querySelector('input[name="path-dir"][value="dest_to_source"]');
      if (pathSrcToDest) pathSrcToDest.checked = pathSrcToDest.hasAttribute('checked');
      if (pathDestToSrc) pathDestToSrc.checked = pathDestToSrc.hasAttribute('checked');

      updateManualVisibility();

      // Hide main sections
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';
      elMapSection.style.display = 'none';

      // Destroy pressure chart instance
      if (chartInstance) { chartInstance.destroy(); chartInstance = null; }

      // Destroy elevation chart instance and hide its section; clear the canvas to remove residual drawing
      if (elevChartInstance) { try { elevChartInstance.destroy(); } catch {} elevChartInstance = null; }
      if (elElevChartSection) { elElevChartSection.style.display = 'none'; }
      if (elevChartCanvas && elevChartCanvas.getContext) {
        try {
          const ctx = elevChartCanvas.getContext('2d');
          ctx && ctx.clearRect(0, 0, elevChartCanvas.width, elevChartCanvas.height);
        } catch {}
      }

      // Tear down map and layers
      if (mapInstance) {
        try { mapInstance.remove(); } catch{}
        mapInstance = null; pathLayer = null; pumpLayer = null;
      }

      // Clear file chooser
      elKmlFile.value = '';

      // Reset manual placement mode and state
      manualMode = false;
      manualLatLngs = [];
      manualDistFt = [];
      manualElevFt = [];
      manualPumps = [];

      // Hide manual panel and clear list UI
      const manualPanelEl = document.getElementById('manual-panel');
      if (manualPanelEl) manualPanelEl.style.display = 'none';
      const manualListEl = document.getElementById('manual-pump-list');
      if (manualListEl) manualListEl.innerHTML = '';

      // Disable report button and clear last run/report state
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = true;
      try {
        delete window.__modelerLastRun;
        delete window.__lastPumps;
        delete window.__lastPlacementStrategy;
        delete window.__lastUsedPsiLossPer100;
        delete window.__lastWarnings;
        delete window.__lastDsLatLngs;
        delete window.__lastPathKey;
      } catch {}

      // Hide path status and clear text
      const pathStatus = document.getElementById('path-status');
      if (pathStatus) { pathStatus.style.display = 'none'; pathStatus.textContent = ''; }

      // Hide warnings and clear list
      if (elWarningsWrap) elWarningsWrap.style.display = 'none';
      if (elWarningsList) elWarningsList.innerHTML = '';

      // Hide "Retry Elevations" UI
      const retryWrap = document.getElementById('elev-retry-wrap');
      if (retryWrap) retryWrap.style.display = 'none';

      // Also remove any lingering JSONP script tags (defensive)
      try {
        const heads = document.querySelectorAll('head script[src*="api.allorigins.win/get"]');
        heads.forEach(s => s.parentNode && s.parentNode.removeChild(s));
      } catch {}
    }
    elReset.addEventListener('click', resetForm);

    function ensureMap() {
      if (mapInstance) return mapInstance;
      elMapSection.style.display = 'block';
      mapInstance = L.map('modeler-map', { zoomControl: true }).setView([35.5, -98.5], 6);

      // Base layers
      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap contributors'
      });

      // Esri World Imagery (satellite)
      const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Tiles © Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
      });

      // Esri World Boundaries and Places (labels) to create a hybrid overlay
      const esriLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Labels © Esri'
      });

      // Create a hybrid group (satellite + labels)
      const hybrid = L.layerGroup([esriSat, esriLabels]);

      // Add default base (Satellite with labels - Hybrid)
      // Turn on hybrid (satellite + labels) by default so users see imagery immediately.
      hybrid.addTo(mapInstance);

      // Pump layer lives above basemap(s)
      pumpLayer = L.layerGroup().addTo(mapInstance);

      // Layer control to switch between basemaps
      const baseMaps = {
        'Streets (OSM)': osm,
        'Satellite (Esri World Imagery)': esriSat,
        'Hybrid (Satellite + Labels)': hybrid
      };
      L.control.layers(baseMaps, null, { collapsed: true }).addTo(mapInstance);

      return mapInstance;
    }

    // Small status helper to report path length and points
    function updatePathStatus(latlngs, totalFt) {
      const el = document.getElementById('path-status');
      if (!el) return;
      if (!latlngs || !latlngs.length) { el.style.display = 'none'; return; }
      el.style.display = 'block';
      el.textContent = `Loaded ${latlngs.length} points • Total distance ~ ${totalFt.toFixed(0)} ft`;
    }

    function showBusy(msg = 'Loading…') {
      const ov = document.getElementById('busy-overlay');
      if (!ov) return;
      ov.style.display = 'flex';
      const t = ov.querySelector('.busy-text');
      if (t) t.textContent = msg;
    }
    function hideBusy() {
      const ov = document.getElementById('busy-overlay');
      if (ov) ov.style.display = 'none';
    }

    function nearestPathIndex(latlngs, latlng) {
      // simple nearest vertex search
      let best = 0, bestD = Infinity;
      for (let i=0;i<latlngs.length;i++){
        const dLat = latlngs[i][0] - latlng.lat;
        const dLng = latlngs[i][1] - latlng.lng;
        const d2 = dLat*dLat + dLng*dLng;
        if (d2 < bestD) { bestD = d2; best = i; }
      }
      return best;
    }

    function rebuildManualList() {
      const list = document.getElementById('manual-pump-list');
      if (!list) return;
      if (!manualPumps.length) { list.innerHTML = '<div class="inline-help">No manual pumps yet.</div>'; return; }
      list.innerHTML = '';
      manualPumps
        .sort((a,b) => a.distanceFt - b.distanceFt)
        .forEach((p, idx) => {
          const row = document.createElement('div');
          row.className = 'manual-pump-row';
          row.innerHTML = `
            <div class="mp-col mp-col--id">#${idx+1} @ ${(p.distanceFt/5280).toFixed(2)} mi</div>
            <div class="mp-col mp-col--inlet">Inlet: ${(p.pressureBefore ?? 0).toFixed(1)} PSI</div>
            <div class="mp-col mp-col--disch">
              <label class="mp-label" for="mp-dis-${idx}">Discharge PSI</label>
              <input id="mp-dis-${idx}" class="mp-input" type="number" step="0.1" inputmode="decimal" value="${Number(p.discharge ?? elMidlinePsi.value)}">
            </div>
            <div class="mp-col mp-col--actions">
              <button class="btn secondary mp-del" data-del="${idx}">Delete</button>
            </div>
          `;
          // wire discharge edit: keep focus and allow continuous typing without re-clicking
          const inp = row.querySelector('.mp-input');
          // prevent update loop from rebuilding list while typing
          let typing = false;
          let rafId = null;
          const liveUpdate = () => {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(() => {
              const v = Number(inp.value);
              p.discharge = isFinite(v) ? v : 0;
              // Update pressures and chart only, avoid rebuilding list to preserve focus
              recomputeManualInlets();
              const prof = computeProfileWithGivenPumps(manualDistFt, manualElevFt, Number(elSourcePsi.value), manualPumps, window.__lastUsedPsiLossPer100 || 0);
              const finalPressure = prof.pressures.length ? prof.pressures[prof.pressures.length-1] : 0;
              renderResults(manualDistFt[manualDistFt.length-1]||0, (window.__lastUsedPsiLossPer100||0), finalPressure, manualPumps.length, (window.__lastWarnings||[]), prof.distances, prof.pressures, 0);
            });
          };
          // On input, do lightweight update without rebuilding list
          inp.addEventListener('input', liveUpdate);
          // On blur or Enter, commit and then rebuild list for any formatting
          const commitAndRebuild = () => {
            const v = Number(inp.value);
            p.discharge = isFinite(v) ? v : 0;
            updateManualProfileAndUI();
            // restore focus to same field index if still present
            requestAnimationFrame(() => {
              const again = document.getElementById('mp-dis-${idx}');
              if (again) { try { again.focus(); again.setSelectionRange(again.value.length, again.value.length); } catch {} }
            });
          };
          inp.addEventListener('change', commitAndRebuild);
          inp.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); commitAndRebuild(); }
          });
          inp.addEventListener('blur', commitAndRebuild);
          // wire delete
          const del = row.querySelector('.mp-del');
          del.addEventListener('click', () => {
            try { pumpLayer.removeLayer(p.marker); } catch {}
            manualPumps.splice(idx,1);
            updateManualProfileAndUI();
          });
          list.appendChild(row);
        });
    }

    function computeProfileWithGivenPumps(distFt, elevFt, sourcePsi, pumps, psiLossPer100) {
      // identical to buildProfileWithPumps but uses provided pumps array; returns {distances, pressures}
      const lossPerFt = psiLossPer100 / 100.0;
      const outDistances = [];
      const outPressures = [];
      let p = sourcePsi;
      let pumpIdx = 0;
      outDistances.push(distFt[0]); outPressures.push(p);
      for (let i = 1; i < distFt.length; i++) {
        if (pumpIdx < pumps.length && pumps[pumpIdx].index === i) {
          outDistances.push(distFt[i]); outPressures.push(p);
          p = pumps[pumpIdx].discharge;
          outDistances.push(distFt[i]); outPressures.push(p);
          pumpIdx++;
        }
        const segLen = distFt[i] - distFt[i-1];
        const dhFt = elevFt[i] - elevFt[i-1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        p = p + elevDeltaPsi - frictionPsi;
        outDistances.push(distFt[i]); outPressures.push(p);
      }
      return { distances: outDistances, pressures: outPressures };
    }

    function recomputeManualInlets() {
      // recompute inlet pressures at pump indices based on current manualPumps and current hydraulics
      const sourcePsi = Number(elSourcePsi.value);
      const usedPsiLossPer100 = window.__lastUsedPsiLossPer100 || 0;
      const lossPerFt = usedPsiLossPer100 / 100.0;

      let p = sourcePsi;
      let nextPumpIdx = 0;
      for (let i=1;i<manualDistFt.length;i++){
        if (nextPumpIdx < manualPumps.length && manualPumps[nextPumpIdx].index === i){
          // inlet at this node is current p
          manualPumps[nextPumpIdx].pressureBefore = p; // raw, no clamping
          // jump to discharge
          p = Number(manualPumps[nextPumpIdx].discharge || elMidlinePsi.value);
          nextPumpIdx++;
        }
        const segLen = manualDistFt[i] - manualDistFt[i-1];
        const dhFt = manualElevFt[i] - manualElevFt[i-1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        p = p + elevDeltaPsi - frictionPsi;
      }
    }

    function updateManualProfileAndUI() {
      // recompute inlets, redraw markers list, refresh chart/results
      recomputeManualInlets();
      rebuildManualList();

      // Build profile from manual pumps
      const prof = computeProfileWithGivenPumps(manualDistFt, manualElevFt, Number(elSourcePsi.value), manualPumps, window.__lastUsedPsiLossPer100 || 0);
      const distancesForChart = prof.distances;
      const pressures = prof.pressures;

      // Update map markers popups to show raw inlet
      pumpLayer.clearLayers();
      manualPumps.forEach((p, idx) => {
        const [lat, lon] = manualLatLngs[p.index];
        const m = L.marker([lat, lon], { draggable: true })
          .bindPopup(`<b>Manual Pump #${idx+1}</b><br>Distance: ${p.distanceFt.toFixed(0)} ft<br>Inlet: ${(p.pressureBefore??0).toFixed(1)} PSI<br>Discharge: ${Number(p.discharge||0).toFixed(1)} PSI`);
        m.on('dragend', (ev) => {
          const ll = ev.target.getLatLng();
          const i = nearestPathIndex(manualLatLngs, ll);
          p.index = i;
          p.distanceFt = manualDistFt[i];
          p.marker.setLatLng([manualLatLngs[i][0], manualLatLngs[i][1]]);
          updateManualProfileAndUI();
        });
        m.on('click', () => { // delete on click
          try { pumpLayer.removeLayer(m); } catch {}
          const k = manualPumps.indexOf(p);
          if (k>=0) { manualPumps.splice(k,1); updateManualProfileAndUI(); }
        });
        p.marker = m;
        pumpLayer.addLayer(m);
      });

      // Results and chart: pumpCount from manual, final outlet from profile tail
      const finalPressure = pressures.length ? pressures[pressures.length-1] : 0;
      renderResults(manualDistFt[manualDistFt.length-1]||0, (window.__lastUsedPsiLossPer100||0), finalPressure, manualPumps.length, (window.__lastWarnings||[]), distancesForChart, pressures, 0);

      // Elevation chart update (manual mode)
      renderElevationChart(manualDistFt, manualElevFt, manualPumps);
 
      // Persist last run for report with manual selection
      // Build a fresh, sorted summary for report consistency
      const sortedForReport = manualPumps
        .slice()
        .sort((a,b) => a.distanceFt - b.distanceFt)
        .map(p => ({
          index: p.index,
          distanceFt: p.distanceFt,
          pressureBefore: p.pressureBefore,
          discharge: Number(p.discharge || 0)
        }));

      // Persist last run for report with manual selection
      window.__lastPumps = sortedForReport;
      window.__lastPlacementStrategy = 'manual';

      // Keep __modelerLastRun synchronized for report
      window.__modelerLastRun = window.__modelerLastRun || {};
      window.__modelerLastRun.profile = { distances: distancesForChart, pressures };
      // Also persist the elevation profile (ft) aligned to dist indices for the report
      window.__modelerLastRun.elevationsFt = Array.isArray(manualElevFt) ? manualElevFt.slice() : [];
      window.__modelerLastRun.baseDistancesFt = Array.isArray(manualDistFt) ? manualDistFt.slice() : [];
      window.__modelerLastRun.results = window.__modelerLastRun.results || {};
      window.__modelerLastRun.results.finalPressure = finalPressure;
      window.__modelerLastRun.pumpsSummary = sortedForReport;
      window.__modelerLastRun.placementStrategy = 'manual';
    }

    function renderPathOnMap(latlngs, pumps) {
      const map = ensureMap();
      if (pathLayer) { map.removeLayer(pathLayer); pathLayer = null; }
      pumpLayer.clearLayers();

      if (latlngs && latlngs.length > 1) {
        pathLayer = L.polyline(latlngs, { color: 'red', weight: 5 }).addTo(map);
        map.fitBounds(pathLayer.getBounds().pad(0.1));

        // Manual mode click handler
        if (manualMode) {
          pathLayer.on('click', (ev) => {
            const i = nearestPathIndex(latlngs, ev.latlng);
            const distanceFt = manualDistFt[i] || 0;
            const discharge = Number(elMidlinePsi.value);
            const np = { index:i, distanceFt, discharge, pressureBefore: 0, marker: null };
            manualPumps.push(np);
            updateManualProfileAndUI();
          });
        } else {
          if (pathLayer) pathLayer.off('click');
        }
      }
      if (Array.isArray(pumps)) {
        pumps.forEach((p, idx) => {
          const i = p.index;
          if (i != null && i >= 0 && i < latlngs.length) {
            const [lat, lon] = latlngs[i];
            const rpmInfo = p.rpm ? `<br>RPM: ${p.rpm}` : '';
            const headInfo = p.headAddedFt ? `<br>Head Add: ${p.headAddedFt.toFixed(0)} ft` : '';
            const qInfo = p.qgpm ? `<br>Flow: ${p.qgpm.toFixed(0)} gpm` : '';
            const famInfo = p.family ? `<br>Family: ${p.family}` : '';
            const marker = L.marker([lat, lon]).bindPopup(
              `<b>Midline Pump #${idx+1}</b><br>Distance: ${p.distanceFt.toFixed(0)} ft` +
              `<br>Inlet: ${p.pressureBefore.toFixed(1)} PSI` +
              `<br>Discharge: ${p.discharge.toFixed(1)} PSI` +
              rpmInfo + headInfo + qInfo + famInfo
            );
            pumpLayer.addLayer(marker);
          }
        });
      }
    }

    function renderChart(distances, pressures, minSuction) {
      if (chartInstance) {
        chartInstance.destroy();
        chartInstance = null;
      }
      
      // Ensure we have valid data arrays
      if (!Array.isArray(distances) || !Array.isArray(pressures) || distances.length === 0 || pressures.length === 0) {
        console.warn('Invalid chart data:', { distances, pressures });
        return;
      }
      
      // Ensure arrays are same length
      const minLength = Math.min(distances.length, pressures.length);
      const chartDistances = distances.slice(0, minLength);
      const chartPressures = pressures.slice(0, minLength);
      
      // Create labels
      const labels = chartDistances.map(d => Number(d).toFixed(0));
      
      chartInstance = new Chart(chartCanvas.getContext('2d'), {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Pressure (PSI)',
              data: chartPressures,
              borderColor: '#0b5fff',
              backgroundColor: 'rgba(11,95,255,0.10)',
              pointRadius: 1.5,
              tension: 0,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          scales: {
            x: {
              title: { display: true, text: 'Distance (ft)' },
              type: 'category'
            },
            y: {
              title: { display: true, text: 'Pressure (PSI)' },
              beginAtZero: true
            }
          },
          plugins: {
            legend: {
              display: true
            }
          }
        }
      });
    }

    // Render Elevation Profile with pump markers
    function renderElevationChart(distFt, elevFt, pumps) {
      // Destroy previous
      if (elevChartInstance) {
        try { elevChartInstance.destroy(); } catch {}
        elevChartInstance = null;
      }
      // If no valid data, hide the section and clear canvas so nothing persists visually
      if (!Array.isArray(distFt) || !Array.isArray(elevFt) || distFt.length === 0 || elevFt.length === 0) {
        if (elElevChartSection) elElevChartSection.style.display = 'none';
        if (elevChartCanvas && elevChartCanvas.getContext) {
          try {
            const ctx = elevChartCanvas.getContext('2d');
            ctx && ctx.clearRect(0, 0, elevChartCanvas.width, elevChartCanvas.height);
          } catch {}
        }
        return;
      }

      // Build labels in miles, but LIMIT the number of unique category labels to avoid duplicates causing jumps.
      // Use one label per point, preserving order, and do NOT round for labels; let formatter handle display.
      const miles = distFt.map(d => (Number(d) / 5280));
      const labels = miles.map(m => m); // raw numeric; displayed via ticks callback

      // Build the line series aligned by index (use index mode with category scale)
      const n = Math.min(distFt.length, elevFt.length);
      const lineData = new Array(n).fill(0).map((_, i) => Number(elevFt[i]));

      // Pump markers: target by index on the same category axis (x is the index)
      const pumpPoints = Array.isArray(pumps) ? pumps.map(p => {
        const idx = Math.max(0, Math.min(n - 1, Number(p.index) || 0));
        return { x: idx, y: Number(elevFt[idx]) };
      }) : [];

      // Ensure section visible
      if (elElevChartSection) elElevChartSection.style.display = 'block';

      elevChartInstance = new Chart(elevChartCanvas.getContext('2d'), {
        type: 'line',
        data: {
          // Use a linear scale for X with numeric miles to avoid category artifacts
          datasets: [
            {
              // Draw the pumps above the line by giving a higher dataset index and parsing order
              label: 'Elevation (ft)',
              data: miles.slice(0, lineData.length).map((m, i) => ({ x: m, y: lineData[i] })),
              borderColor: 'rgba(11,95,255,0.85)',
              backgroundColor: 'rgba(11,95,255,0.20)',
              pointRadius: 0,
              tension: 0.1,
              order: 1
            },
            {
              label: 'Pump',
              type: 'scatter',
              data: pumpPoints.map(p => ({ x: miles[p.x], y: p.y })), // convert index -> miles
              pointBackgroundColor: '#000',
              pointBorderColor: '#000',
              pointRadius: 6,
              showLine: false,
              order: 0
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          scales: {
            x: {
              title: { display: true, text: 'Line Distance (miles)' },
              type: 'linear',
              ticks: {
                callback: (value) => Number(value).toFixed(2),
                maxRotation: 60,
                minRotation: 45
              }
            },
            y: {
              title: { display: true, text: 'Elevation (ft)' },
              beginAtZero: false
            }
          },
          plugins: {
            legend: { display: true }
          },
          elements: {
            line: { spanGaps: true }
          }
        }
      });
    }

    // [Removed] pump curve helpers and families (manual mode only)

    async function readKmlOrKmz(file) {
      const name = (file?.name || '').toLowerCase();
      if (name.endsWith('.kml')) {
        const text = await file.text();
        return text;
      } else if (name.endsWith('.kmz')) {
        throw new Error('Unsupported file type: KMZ is not supported. Please upload a .kml file.');
      } else {
        throw new Error('Unsupported file type. Please upload a .kml file.');
      }
    }

    function collectWarningsInto(list, msg) {
      list.push(msg);
    }

    function determinePsiLossPer100(flowBpm, hoseIn, lossMethod, manualVal, warnings, runsCount) {
      const runs = Math.max(1, Number(runsCount) || 1);
      let usedPsiLossPer100 = 0;

      if (lossMethod === 'manual') {
        if (!(manualVal >= 0)) {
          collectWarningsInto(warnings, 'Manual PSI loss per 100 ft must be >= 0.');
          usedPsiLossPer100 = 0;
        } else {
          // For parallel identical hoses carrying the same total flow, head loss halves for 2 runs.
          usedPsiLossPer100 = manualVal / runs;
        }
      } else {
        // Lookup mode: compute loss at per-hose flow when using multiple runs,
        // then combine in parallel which divides head loss by number of runs.
        // Total flow is split evenly across runs.
        const totalGpm = bpmToGpm(flowBpm);
        const perHoseGpm = totalGpm / runs;

        const headLoss12_perHose = lookupHeadLoss12in(perHoseGpm);
        if (headLoss12_perHose == null) {
          collectWarningsInto(warnings, 'Flow is outside the 12" lookup table range; cannot interpolate.');
          usedPsiLossPer100 = 0;
        } else {
          const scaledHeadLoss_perHose = scaleHeadLossByDiameter(headLoss12_perHose, hoseIn);
          const psiPerHose = headLossFtToPsi(scaledHeadLoss_perHose);
          // Parallel identical hoses reduce head loss by factor of runs
          usedPsiLossPer100 = psiPerHose / runs;
        }
      }
      return usedPsiLossPer100;
    }

    function renderResults(totalFt, usedPsiLossPer100, finalPressure, pumpCount, warnings, distances, pressures, minSuction) {
      elResults.style.display = 'block';
      elOutDist.textContent = totalFt.toFixed(1);
      elOutUsedLoss.textContent = usedPsiLossPer100.toFixed(4) + ' PSI/100ft';
      elOutFinalPsi.textContent = finalPressure.toFixed(1);
      // Ensure we only count midline pumps, not the source pump (source is not included in auto.pumps)
      const midlineCount = Math.max(0, Number(pumpCount) || 0);
      elOutPumpCount.textContent = String(midlineCount);

      if (warnings.length) {
        elWarningsWrap.style.display = 'block';
        elWarningsList.innerHTML = '';
        warnings.forEach(w => {
          const li = document.createElement('li');
          li.textContent = w;
          elWarningsList.appendChild(li);
        });
      } else {
        elWarningsWrap.style.display = 'none';
        elWarningsList.innerHTML = '';
      }

      elChartSection.style.display = 'block';
      renderChart(distances, pressures, minSuction);
  
      // Enable report button now that we have a successful run
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = false;
  
      // Store the latest run dataset on window for report generation
      window.__modelerLastRun = {
        flowBpm: Number(elFlowBpm.value),
        hoseIn: Number(elHoseSize.value),
        hoseRuns: Number(document.getElementById('hose-runs')?.value || 1),
        sourcePsi: Number(elSourcePsi.value),
        midlinePsi: Number(elMidlinePsi.value),
        minSuction: 0,
        maxHose: Number(elMaxHose.value),
        lossMethod: currentLossMethod(),
        manualPsi100: Number(elManualPsi100.value),
        placementStrategy: 'manual',
        pathDir: currentPathDir(),
        results: {
          totalFt,
          usedPsiLossPer100,
          finalPressure,
          pumpCount,
          warnings: [...warnings]
        },
        profile: { distances, pressures },
        // Elevation series and base distances for the elevation chart in the report
        elevationsFt: Array.isArray(manualElevFt) ? manualElevFt.slice() : [],
        baseDistancesFt: Array.isArray(manualDistFt) ? manualDistFt.slice() : [],
        pumpsSummary: (window.__lastPumps || []),
        placementStrategy: 'manual'
      };
    }

    async function runCalc() {
      const flowBpm = Number(elFlowBpm.value);
      const hoseIn = Number(elHoseSize.value);
      const sourcePsi = Number(elSourcePsi.value);
      const midlinePsi = Number(elMidlinePsi.value);
      // Manual-only: no user min suction; keep zero for compatibility
      const minSuction = 0;
      const maxHose = Number(elMaxHose.value);
      const lossMethod = currentLossMethod();
      const manualPsi100 = Number(elManualPsi100.value);
      const runsCount = Math.max(1, Number(elHoseRuns && elHoseRuns.value ? elHoseRuns.value : 1));
      const pathDir = currentPathDir();
      const placementStrategy = 'manual';

      const warnings = [];
      if (!(flowBpm >= 0)) warnings.push('Flow rate (BPM) must be >= 0.');
      if (!(sourcePsi > 0)) warnings.push('Source discharge PSI must be > 0.');
      if (!(maxHose > 0)) warnings.push('Max allowable hose PSI must be > 0.');
      if (sourcePsi > maxHose) warnings.push(`Source discharge (${sourcePsi.toFixed(1)} PSI) exceeds hose max (${maxHose.toFixed(1)} PSI).`);

      // Determine friction loss
      const usedPsiLossPer100 = determinePsiLossPer100(flowBpm, hoseIn, lossMethod, manualPsi100, warnings, runsCount);

      // Path handling
      let latlngs = [];
      let usingKml = false;
      const file = elKmlFile.files && elKmlFile.files[0] ? elKmlFile.files[0] : null;
      if (file) {
        usingKml = true;
        let kmlText = '';
        try {
          kmlText = await readKmlOrKmz(file);
        } catch (e) {
          warnings.push(`KML/KMZ error: ${e.message}`);
        }
        if (kmlText) {
          const parsed = parseKmlLineStringToLatLngs(kmlText);
          if (!parsed.length) warnings.push('No LineString coordinates found in KML.');
          latlngs = parsed;
        }
      }

      // If no KML path provided, block calculation silently and prompt user in path section
      if (!latlngs.length) {
        const reportBtn = document.getElementById('generate-report');
        if (reportBtn) reportBtn.disabled = true;
        delete window.__modelerLastRun;

        elMapSection.style.display = 'none';
        elResults.style.display = 'none';
        elChartSection.style.display = 'none';
        elWarningsWrap.style.display = 'none';
        elWarningsList.innerHTML = '';

        const pathStatus = document.getElementById('path-status');
        if (pathStatus) {
          pathStatus.style.display = 'block';
          pathStatus.textContent = 'No path loaded. Upload a KML to run.';
        }
        return;
      }

      // If we have KML path, optionally reverse
      if (pathDir === 'dest_to_source') latlngs.reverse();

      // Downsample if needed
      const dsLatLngs = downsampleLatLngs(latlngs, MAX_POINTS);

      // Build a path cache key based on the downsampled coordinates
      const pathKey = pathKeyFromLatLngs(dsLatLngs);
      window.__lastPathKey = pathKey; // keep for retries/report if needed

      // Elevations (cache-first)
      let elevationsFt = null;
      const retryWrap = document.getElementById('elev-retry-wrap');

      // Try cache
      const cachedFt = getCachedElevationsFt(pathKey);
      if (cachedFt && cachedFt.length === dsLatLngs.length) {
        elevationsFt = cachedFt;
        if (retryWrap) retryWrap.style.display = 'none';
      } else {
        // Cache miss: fetch from network
        let elevationsM = [];
        try {
          showBusy('Sampling elevation…');
          elevationsM = await fetchElevationsOpenTopo(dsLatLngs);
          if (retryWrap) retryWrap.style.display = 'none';
        } catch (e) {
          if (retryWrap) retryWrap.style.display = 'block';
          warnings.push(`Elevation fetch failed: ${e.message}`);
          elevationsM = dsLatLngs.map(() => 0);
        } finally {
          hideBusy();
          // Clear any pending JSONP script tags that might outlive failures
          try {
            const heads = document.querySelectorAll('head script[src*="api.allorigins.win/get"]');
            heads.forEach(s => s.parentNode && s.parentNode.removeChild(s));
          } catch {}
        }
        elevationsFt = elevationsM.map(m => m * 3.28084);
        // Store in cache if sizes align
        if (Array.isArray(elevationsFt) && elevationsFt.length === dsLatLngs.length) {
          setCachedElevationsFt(pathKey, elevationsFt);
        }
      }

      // Distances
      const distFt = cumulativeDistancesFt(dsLatLngs);
      const totalFt = distFt[distFt.length - 1] || 0;

      // Cache for manual mode recompute
      manualLatLngs = dsLatLngs;
      manualDistFt = distFt;
      manualElevFt = elevationsFt;
      // Persist last dsLatLngs for elevation retry
      window.__lastDsLatLngs = dsLatLngs;

      // Determine friction loss we used (for manual recompute reuse)
      window.__lastUsedPsiLossPer100 = usedPsiLossPer100;
      window.__lastWarnings = warnings;

      // Manual-only: show manual panel, render path, and defer outputs to manual UI recompute
      manualMode = true;
      document.getElementById('manual-panel').style.display = 'block';
      if (!Array.isArray(manualPumps)) manualPumps = [];
      renderPathOnMap(dsLatLngs, []);
      updateManualProfileAndUI();
      return;
    }

    document.getElementById('run-calc').addEventListener('click', runCalc);

    // --- Printable Report (new tab) ---
    function milesFromFeet(ft) { return (Number(ft||0) / 5280); }
    function fmt(n, digits=1) { return isFinite(n) ? Number(n).toFixed(digits) : '—'; }

    function buildReportHtml(state) {
      const dt = new Date();
      const dateStr = dt.toLocaleDateString() + ' ' + dt.toLocaleTimeString();
      const totalMi = milesFromFeet(state.results.totalFt);
      const usedLoss = state.results.usedPsiLossPer100;

      // Manual-mode report: no NPSHR or curve family details.
      const pumpRows = (state.pumpsSummary || []).map((p, i) => {
        const distMi = milesFromFeet(p.distanceFt);
        return `
          <tr>
            <td>#${i+1}</td>
            <td>${fmt(distMi, 2)} mi</td>
            <td>${fmt(p.pressureBefore, 1)} PSI</td>
            <td>${fmt(p.discharge, 1)} PSI</td>
          </tr>`;
      }).join('') || `<tr><td colspan="4">No midline pumps placed</td></tr>`;

      // Inline CSS optimized for 8.5x11 portrait, narrow centered stack
      const styles = `
        <style>
          @page { size: 8.5in 11in; margin: 0.5in; }
          :root { --fg:#111; --muted:#555; --line:#dcddea; --accent:#0b5fff; --soft:#eef2ff; }
          * { box-sizing: border-box; }
          body { font-family: 'ISOCPEUR', Arial, sans-serif; color:var(--fg); background:white; font-size: 14px; }
          .wrap { max-width: 820px; margin: 0 auto; }
          .hdr { text-align:center; margin: 8px 0 14px; }
          .title { font-size:28px; font-weight:800; margin:4px 0 0; letter-spacing:0.2px; }
          .subtitle { font-size:13px; color:var(--muted); }
          .card { border:1px solid var(--line); border-radius:12px; padding:14px 16px; background:#fff; }
          .section-h { font-size:16px; font-weight:700; margin: 0 0 8px; color:#222; }
          .stack { display:grid; grid-template-columns: 1fr; gap:8px; }
          .kv { display:flex; justify-content:space-between; gap:10px; font-size:14px; line-height:1.35; }
          .kv .k { color:#333; font-weight:600; }
          .kv .v { color:#111; font-weight:700; }
          .chips { display:flex; flex-wrap:wrap; gap:8px; margin-top:6px; }
          .chip { font-size:12px; padding:4px 10px; border-radius:999px; background:var(--soft); border:1px solid #d8ddff; color:#222; font-weight:600; }
          table { width:100%; border-collapse: collapse; font-size:14px; }
          th, td { border: 1px solid var(--line); padding:8px 9px; text-align:left; }
          th { background:#f3f5ff; font-weight:800; }
          .chart { width:100%; height:320px; margin-top:8px; border:1px solid #e3e6ff; border-radius:10px; }
          .badge { display:inline-block; padding:2px 9px; border-radius:10px; color:#fff; font-size:12px; font-weight:700; }
          .good { background:#198754; }
          .bad { background:#dc3545; }
          .note { font-size:12px; color:var(--muted); margin-top:8px; }
          /* Axes labels for inline SVG */
          .axis-label {
            font-size: 20px;
            font-weight: 800;
            fill: #222;
            font-family: 'ISOCPEUR', Arial, sans-serif;
          }
        </style>
      `;

      // Embed profile as SVG (no external libs)
      const distances = state.profile.distances || [];
      const pressures = state.profile.pressures || [];
      const svg = buildSimplePressureSvg(distances, pressures, state.minSuction);

      // Elevation profile inputs
      const elevDistancesFt = Array.isArray(state.baseDistancesFt) && state.baseDistancesFt.length ? state.baseDistancesFt : distances;
      const elevationsFt = Array.isArray(state.elevationsFt) ? state.elevationsFt : [];
      const elevSvg = elevationsFt.length && elevDistancesFt.length ? buildSimpleElevationSvg(elevDistancesFt, elevationsFt, state.pumpsSummary || []) : '<div class="chart" style="display:flex;align-items:center;justify-content:center;color:#666;">No elevation data</div>';

      const runsLabel = state.hoseRuns ? (state.hoseRuns === 2 ? 'Dual (parallel)' : 'Single') : 'Single';
      return `
        <!doctype html>
        <html>
          <head><meta charset="utf-8">${styles}<title>Layflat Line Report</title></head>
          <body>
            <div class="wrap">
              <div class="hdr">
                <div class="title">Line Profile Report</div>
                <div class="subtitle">Generated ${dateStr}</div>
              </div>

              <div class="card" style="margin-bottom:10px;">
                <div class="section-h">Manual Mode Summary</div>
                <div class="stack">
                  <div class="kv"><div class="k">Distance</div><div class="v">${fmt(totalMi,2)} miles</div></div>
                  <div class="kv"><div class="k">Desired Rate</div><div class="v">${fmt(state.flowBpm,0)} BPM</div></div>
                  <div class="kv"><div class="k">Hose Diameter</div><div class="v">${fmt(state.hoseIn,0)} in</div></div>
                  <div class="kv"><div class="k">Hose Runs</div><div class="v">${runsLabel}</div></div>
                  <div class="kv"><div class="k">Friction Loss</div><div class="v">${fmt(usedLoss,4)} PSI/100 ft</div></div>
                  <div class="kv"><div class="k">Max Hose PSI</div><div class="v">${fmt(state.maxHose,0)} PSI</div></div>
                  <div class="kv"><div class="k">Final Outlet Pressure</div><div class="v">${fmt(state.results.finalPressure,1)} PSI</div></div>
                  <div class="kv"><div class="k">Loss Method</div><div class="v">${state.lossMethod}</div></div>
                  <div class="kv"><div class="k">Path Direction</div><div class="v">${state.pathDir === 'dest_to_source' ? 'Destination → Source' : 'Source → Destination'}</div></div>
                </div>
                <!-- NPSHR note intentionally removed for manual-mode report -->
              </div>

              <div class="card" style="margin-bottom:10px;">
                <div class="section-h">Midline Pumps</div>
                <table>
                  <thead>
                    <tr>
                      <th>#</th><th>Distance</th><th>Inlet PSI</th><th>Discharge PSI</th>
                    </tr>
                  </thead>
                  <tbody>${pumpRows}</tbody>
                </table>
              </div>

              <div class="card">
                <div class="section-h">Pressure Profile</div>
                <div class="chart">${svg}</div>
              </div>

              <div class="card" style="margin-top:10px;">
                <div class="section-h">Elevation Profile</div>
                <div class="chart">${elevSvg}</div>
                ${state.results.warnings && state.results.warnings.length ? `
                  <div class="section-h" style="margin-top:10px;">Warnings</div>
                  <ul class="note">${state.results.warnings.map(w => `<li>${w}</li>`).join('')}</ul>
                ` : ''}
              </div>
            </div>
          </body>
        </html>
      `;
    }

    // Render a basic SVG pressure chart without external libraries
    function buildSimplePressureSvg(distances, pressures, minLine) {
      if (!Array.isArray(distances) || !Array.isArray(pressures) || distances.length < 2) {
        return '<div class="center" style="padding:20px;color:#666;">No chart data</div>';
      }
      const width = 900, height = 300, padL = 60, padR = 10, padT = 10, padB = 38;
      const minX = distances[0], maxX = distances[distances.length-1];

      // Only include a solid red Max Hose line; remove the yellow min-suction reference line
      const maxHosePsi = Number(window.__modelerLastRun?.maxHose ?? 0);

      // Determine Y extents considering pressures and max hose reference (omit minLine entirely)
      const valuesForY = [...pressures];
      if (isFinite(maxHosePsi)) valuesForY.push(maxHosePsi);
      let minY = Math.min(...valuesForY);
      let maxY = Math.max(...valuesForY);
      if (!isFinite(minY) || !isFinite(maxY) || minY === maxY) { minY = 0; maxY = 1; }

      // Nice tick generation utilities
      function niceStep(span, maxTicks) {
        const rough = span / Math.max(1, maxTicks);
        const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
        const candidates = [1, 2, 2.5, 5, 10].map(m => m * pow10);
        // choose the step that yields tick count closest to maxTicks
        let best = candidates[0], bestDiff = Infinity;
        for (const s of candidates) {
          const n = Math.ceil(span / s);
          const diff = Math.abs(n - maxTicks);
          if (diff < bestDiff) { bestDiff = diff; best = s; }
        }
        return best;
      }
      function linspaceTicks(minV, maxV, desired) {
        const span = Math.max(1e-9, maxV - minV);
        const step = niceStep(span, desired);
        const start = Math.ceil(minV / step) * step;
        const ticks = [];
        for (let v = start; v <= maxV + 1e-9; v += step) ticks.push(Number(v.toFixed(10)));
        return { ticks, step };
      }

      // Create scales
      const sx = x => padL + (x - minX) * (width - padL - padR) / (maxX - minX || 1);
      const sy = y => height - padB - (y - minY) * (height - padT - padB) / (maxY - minY || 1);

      // Build polyline points
      const pts = distances.map((d,i) => `${sx(d)},${sy(pressures[i])}`).join(' ');

      // Axis ticks (aim ~6 on each axis)
      const yTicksInfo = linspaceTicks(minY, maxY, 6);
      const xTicksInfo = linspaceTicks(minX, maxX, 6);
      const fmtFeet = n => Number(n).toLocaleString(undefined, { maximumFractionDigits: 0 });

      const yTicksSvg = yTicksInfo.ticks.map(v => `
        <line x1="${padL-4}" y1="${sy(v)}" x2="${padL}" y2="${sy(v)}" stroke="#777" stroke-width="1"/>
        <line x1="${padL}" y1="${sy(v)}" x2="${width-padR}" y2="${sy(v)}" stroke="#e9ecff" stroke-width="1"/>
        <text x="${padL-8}" y="${sy(v)+4}" text-anchor="end" font-size="11" fill="#444"
              font-family="'ISOCPEUR', Arial, sans-serif">${Math.round(v)}</text>
      `).join('');

      const xTicksSvg = xTicksInfo.ticks.map(v => `
        <line x1="${sx(v)}" y1="${height-padB}" x2="${sx(v)}" y2="${height-padB+4}" stroke="#777" stroke-width="1"/>
        <line x1="${sx(v)}" y1="${padT}" x2="${sx(v)}" y2="${height-padB}" stroke="#f2f4ff" stroke-width="1"/>
        <text x="${sx(v)}" y="${height-padB+16}" text-anchor="middle" font-size="11" fill="#444"
              font-family="'ISOCPEUR', Arial, sans-serif">${fmtFeet(v)}</text>
      `).join('');

      // Max hose (solid red) + label
      const maxHoseLine = isFinite(maxHosePsi) && maxHosePsi > 0 ? `
        <line x1="${sx(minX)}" y1="${sy(maxHosePsi)}" x2="${sx(maxX)}" y2="${sy(maxHosePsi)}"
              stroke="#dc3545" stroke-width="2" />
        <text x="${sx(maxX) - 8}" y="${sy(maxHosePsi) - 6}" text-anchor="end"
              font-size="12" font-weight="700" fill="#dc3545"
              font-family="'ISOCPEUR', Arial, sans-serif">
          User-defined Max Pressure (PSI)
        </text>
      ` : '';

      return `
        <svg viewBox="0 0 ${width} ${height}" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
          <rect x="0" y="0" width="${width}" height="${height}" fill="white" />
          <!-- Axes base lines -->
          <line x1="${padL}" y1="${padT}" x2="${padL}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <line x1="${padL}" y1="${height-padB}" x2="${width-padR}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <!-- Grid + tick labels -->
          ${yTicksSvg}
          ${xTicksSvg}
          <!-- Axis labels -->
          <text class="axis-label" x="${(padL + (width - padR)) / 2}" y="${height - 4}" text-anchor="middle">Distance (ft)</text>
          <text class="axis-label" transform="translate(16 ${(padT + (height - padB)) / 2}) rotate(-90)" text-anchor="middle">Pressure (PSI)</text>
          <!-- Data -->
          ${maxHoseLine}
          <polyline fill="none" stroke="#0b5fff" stroke-width="2" points="${pts}" />
        </svg>
      `;
    }

    // Render a basic SVG elevation chart with pump markers (inline, no external libs)
    function buildSimpleElevationSvg(distancesFt, elevationsFt, pumpsSummary) {
      if (!Array.isArray(distancesFt) || !Array.isArray(elevationsFt) || distancesFt.length < 2 || elevationsFt.length < 2) {
        return '<div class="center" style="padding:20px;color:#666;">No elevation data</div>';
      }
      const n = Math.min(distancesFt.length, elevationsFt.length);
      const dist = distancesFt.slice(0, n);
      const elev = elevationsFt.slice(0, n);

      // Convert X to miles for labeling/scale
      const miles = dist.map(d => Number(d) / 5280);

      const width = 900, height = 300, padL = 60, padR = 10, padT = 10, padB = 38;
      const minX = miles[0], maxX = miles[miles.length - 1];

      let minY = Math.min(...elev);
      let maxY = Math.max(...elev);
      if (!isFinite(minY) || !isFinite(maxY) || minY === maxY) { minY = 0; maxY = 1; }

      function niceStep(span, maxTicks) {
        const rough = span / Math.max(1, maxTicks);
        const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
        const candidates = [1, 2, 2.5, 5, 10].map(m => m * pow10);
        let best = candidates[0], bestDiff = Infinity;
        for (const s of candidates) {
          const n = Math.ceil(span / s);
          const diff = Math.abs(n - maxTicks);
          if (diff < bestDiff) { bestDiff = diff; best = s; }
        }
        return best;
      }
      function linspaceTicks(minV, maxV, desired) {
        const span = Math.max(1e-9, maxV - minV);
        const step = niceStep(span, desired);
        const start = Math.ceil(minV / step) * step;
        const ticks = [];
        for (let v = start; v <= maxV + 1e-9; v += step) ticks.push(Number(v.toFixed(10)));
        return { ticks, step };
      }

      const sx = x => padL + (x - minX) * (width - padL - padR) / (maxX - minX || 1);
      const sy = y => height - padB - (y - minY) * (height - padT - padB) / (maxY - minY || 1);

      // Line path
      const pts = miles.map((m, i) => `${sx(m)},${sy(elev[i])}`).join(' ');

      // Pump markers: locate by nearest distance in feet against dist array
      const pumpDots = Array.isArray(pumpsSummary) ? pumpsSummary.map((p) => {
        const dFt = Number(p.distanceFt || 0);
        // linear search for nearest index (n is at most 2000 after downsampling)
        let bestI = 0, bestDiff = Infinity;
        for (let i = 0; i < dist.length; i++) {
          const df = Math.abs(dist[i] - dFt);
          if (df < bestDiff) { bestDiff = df; bestI = i; }
        }
        const x = sx(miles[bestI]);
        const y = sy(elev[bestI]);
        return `<circle cx="${x}" cy="${y}" r="4.5" fill="#000" stroke="#000" />`;
      }).join('') : '';

      const yTicksInfo = linspaceTicks(minY, maxY, 6);
      const xTicksInfo = linspaceTicks(minX, maxX, 6);

      const yTicksSvg = yTicksInfo.ticks.map(v => `
        <line x1="${padL-4}" y1="${sy(v)}" x2="${padL}" y2="${sy(v)}" stroke="#777" stroke-width="1"/>
        <line x1="${padL}" y1="${sy(v)}" x2="${width-padR}" y2="${sy(v)}" stroke="#e9ecff" stroke-width="1"/>
        <text x="${padL-8}" y="${sy(v)+4}" text-anchor="end" font-size="11" fill="#444"
              font-family="'ISOCPEUR', Arial, sans-serif">${Math.round(v)}</text>
      `).join('');

      const xTicksSvg = xTicksInfo.ticks.map(v => `
        <line x1="${sx(v)}" y1="${height-padB}" x2="${sx(v)}" y2="${height-padB+4}" stroke="#777" stroke-width="1"/>
        <line x1="${sx(v)}" y1="${padT}" x2="${sx(v)}" y2="${height-padB}" stroke="#f2f4ff" stroke-width="1"/>
        <text x="${sx(v)}" y="${height-padB+16}" text-anchor="middle" font-size="11" fill="#444"
              font-family="'ISOCPEUR', Arial, sans-serif">${Number(v).toFixed(2)}</text>
      `).join('');

      return `
        <svg viewBox="0 0 ${width} ${height}" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
          <rect x="0" y="0" width="${width}" height="${height}" fill="white" />
          <!-- Axes base lines -->
          <line x1="${padL}" y1="${padT}" x2="${padL}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <line x1="${padL}" y1="${height-padB}" x2="${width-padR}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <!-- Grid + tick labels -->
          ${yTicksSvg}
          ${xTicksSvg}
          <!-- Axis labels -->
          <text class="axis-label" x="${(padL + (width - padR)) / 2}" y="${height - 4}" text-anchor="middle">Distance (miles)</text>
          <text class="axis-label" transform="translate(16 ${(padT + (height - padB)) / 2}) rotate(-90)" text-anchor="middle">Elevation (ft)</text>
          <!-- Data -->
          <polyline fill="none" stroke="rgba(11,95,255,0.85)" stroke-width="2" points="${pts}" />
          ${pumpDots}
        </svg>
      `;
    }
    function openReport() {
      const state = window.__modelerLastRun;
      if (!state) {
        alert('Run a calculation with a valid path before generating a report.');
        return;
      }

      // Rebuild pumpsSummary from the current manualPumps to reflect any drags/edits
      if (Array.isArray(window.manualPumps) && window.manualPumps.length) {
        const refreshed = window.manualPumps
          .slice()
          .sort((a,b) => a.distanceFt - b.distanceFt)
          .map(p => ({
            index: p.index,
            distanceFt: p.distanceFt,
            pressureBefore: p.pressureBefore,
            discharge: Number(p.discharge || 0)
          }));
        state.pumpsSummary = refreshed;
      }

      const html = buildReportHtml(state);
      const w = window.open('', '_blank');
      if (!w) { alert('Popup blocked. Allow popups to view the report.'); return; }
      w.document.open();
      w.document.write(html);
      w.document.close();
      // Try to trigger print preview after load for convenience
      w.onload = () => { try { w.focus(); } catch {} };
    }

    const reportBtn = document.getElementById('generate-report');
    if (reportBtn) {
      reportBtn.addEventListener('click', openReport);
    }
    // Wire Excel button (bind once at load)
 
    // Wire Retry Elevations button
    const __retryBtn = document.getElementById('retry-elev');
    if (__retryBtn) {
      __retryBtn.addEventListener('click', async () => {
        const coords = window.__lastDsLatLngs;
        if (!Array.isArray(coords) || !coords.length) return;
        try {
          showBusy('Retrying elevation…');
          const m = await fetchElevationsOpenTopo(coords);
          const ft = m.map(v => v * 3.28084);
          manualElevFt = ft;

          // Also update cache for the current pathKey
          const k = window.__lastPathKey || pathKeyFromLatLngs(coords);
          if (k) setCachedElevationsFt(k, ft);

          hideBusy();
          const rw = document.getElementById('elev-retry-wrap');
          if (rw) rw.style.display = 'none';
          updateManualProfileAndUI();
        } catch (e) {
          hideBusy();
          alert('Retry failed: ' + e.message);
        }
      });
    }

    // --- Input-change mechanics: no auto-run; require explicit Run Calculation ---

    // Clear derived UI when inputs change to prevent reading stale values
    function clearDerivedUI() {
      // Hide previous results/chart until the next run completes
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';

      // Elevation: destroy instance, hide section, and clear canvas to avoid ghost rendering
      if (elevChartInstance) { try { elevChartInstance.destroy(); } catch {} elevChartInstance = null; }
      if (elElevChartSection) elElevChartSection.style.display = 'none';
      if (elevChartCanvas && elevChartCanvas.getContext) {
        try {
          const ctx = elevChartCanvas.getContext('2d');
          ctx && ctx.clearRect(0, 0, elevChartCanvas.width, elevChartCanvas.height);
        } catch {}
      }

      // Keep map section visible but clear pumps so user sees path without stale boosts
      if (pumpLayer) { try { pumpLayer.clearLayers(); } catch {} }
      // Disable report and clear last run to avoid stale report generation
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = true;
      delete window.__modelerLastRun;
    }

    // Whenever a user changes inputs that affect hydraulics, just clear derived UI (no auto run)
    // Note: elPlacementStrategy no longer exists in this manual-only app.
    const hydraulicInputs = [
      elFlowBpm, elHoseSize, elSourcePsi, elMidlinePsi,
      elMaxHose, elManualPsi100, /* elPlacementStrategy, */ elHoseRuns
    ];
    hydraulicInputs.forEach(inp => {
      if (!inp) return;
      inp.addEventListener('input', () => { clearDerivedUI(); });
      inp.addEventListener('change', () => { clearDerivedUI(); });
    });

    // Friction loss method radios
    lossRadios.forEach(r => {
      r.addEventListener('change', () => { updateManualVisibility(); clearDerivedUI(); });
    });

    // Path direction radios (reverse path)
    pathDirRadios.forEach(r => {
      r.addEventListener('change', () => { clearDerivedUI(); });
    });

    // When a new KML/KMZ is selected, clear outputs; user must press Run Calculation
    elKmlFile.addEventListener('change', () => {
      // Clear everything visual so a new file doesn't mix with old output
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = true;
      delete window.__modelerLastRun;

      if (chartInstance) { try { chartInstance.destroy(); } catch {} chartInstance = null; }
      if (mapInstance) {
        // Remove old layers/instance to ensure a clean start
        try { mapInstance.remove(); } catch {}
        mapInstance = null; pathLayer = null; pumpLayer = null;
      }
    });

    // Remove previous auto-run blur handler: no-op now
  </script>
</body>
</html>