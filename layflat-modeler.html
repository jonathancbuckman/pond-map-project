<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Layflat Hydraulic Modeler</title>
  <link rel="stylesheet" href="css/style.css"/>
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#121212">
  <meta name="color-scheme" content="dark">

  <!-- Leaflet CSS for map preview -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    /* Page-local styles for the modeler (kept minimal; reuses global font) */
    .modeler-wrap {
      max-width: 1000px;
      margin: 0 auto;
      padding: 12px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
    }
    .site-header {
      padding: 10px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-header);
      color: var(--text-primary);
      font-family: 'ISOCPEUR', Arial, sans-serif;
    }
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .field label {
      font-size: 13px;
    }
    .field input[type="number"], .field select, .field input[type="file"] {
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 14px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      background: #121418;
      color: var(--text-primary);
    }
    .radio-row {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      font-size: 14px;
    }
    .section-card {
      background: var(--bg-graph);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      margin-top: 14px;
    }
    .section-card h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: var(--text-primary);
    }
    .btn {
      display: inline-block;
      padding: 8px 12px;
      border: 1px solid var(--accent);
      border-radius: 8px;
      background: var(--accent);
      color: #fff;
      text-decoration: none;
      cursor: pointer;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      font-size: 14px;
    }
    .btn[disabled] {
      opacity: 0.65;
      cursor: not-allowed;
    }
    .btn.secondary {
      background: #14171c;
      color: var(--text-primary);
      border-color: var(--border);
    }
    .inline-help {
      font-size: 12px;
      color: var(--text-muted);
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    .results-table th, .results-table td {
      border: 1px solid var(--border);
      padding: 6px 8px;
      color: var(--text-primary);
    }
    .results-table th {
      background: #1a1d24;
      text-align: left;
      color: var(--text-secondary);
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 12px;
      color: #fff;
    }
    .badge.good { background: #198754; }
    .badge.bad { background: #dc3545; }
    .warnings {
      margin: 8px 0 0 18px;
      color: #e1b84a;
    }
    .chart-box {
      position: relative;
      height: 320px;
      width: 100%;
      background: #141821;
      border: 1px solid var(--border);
      border-radius: 10px;
    }
    /* Map preview box */
    #busy-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      z-index: 3000;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(1px);
    }
    .busy-card {
      background: #0f1115;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px 16px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
      font-family: 'ISOCPEUR', Arial, sans-serif;
      color: var(--text-primary);
      min-width: 260px;
      text-align: center;
    }
    .spinner {
      width: 22px;
      height: 22px;
      border: 3px solid #283a66;
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-right: 10px;
      flex: 0 0 auto;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    #modeler-map {
      height: 350px;
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0f1115;
    }

    /* Manual Pump List layout */
    .manual-pump-list {
      display: grid;
      gap: 10px;
    }
    .manual-pump-row {
      display: grid;
      grid-template-columns: 1fr 1fr 280px auto;
      gap: 10px 12px;
      align-items: center;
      margin-bottom: 4px;
    }
    .mp-col--id,
    .mp-col--inlet {
      font-size: 14px;
      line-height: 1.3;
    }
    .mp-col--disch {
      display: grid;
      grid-template-columns: 110px 1fr;
      align-items: center;
      gap: 8px;
    }
    .mp-label {
      font-size: 12px;
      color: var(--text-muted);
      margin: 0;
      text-align: right;
    }
    .mp-input {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 14px;
      font-family: 'ISOCPEUR', Arial, sans-serif;
      background: var(--bg-card);
      color: var(--text-primary);
    }
    .mp-col--actions {
      display: flex;
      justify-content: flex-end;
      align-items: center;
    }

    /* Stack nicely on narrow screens */
    @media (max-width: 640px) {
      .manual-pump-row {
        grid-template-columns: 1fr 1fr;
      }
      .mp-col--actions {
        justify-content: flex-start;
      }
    }
  </style>
</head>
<body class="modeler-page">
  <header class="site-header" role="banner">
    <strong>Layflat Hydraulic Modeler</strong>
  </header>

  <main class="modeler-wrap" role="main">
    <!-- Introductory guidance -->
    <section class="section-card">
      <h3>Information</h3>
      <p class="inline-help" style="max-width:880px;">
        Quick guide: pick your flow (e.g. 100 BPM) and how to estimate the friction loss at that specific flow rate. Lookup (model interpolates PSI/100ft for the flow and hose size based on a conservative empirical table) or Manual (enter PSI/100ft at the specific flow rate). Upload a single KML LineString and click "Run Calculation". KMZ won't work. Click the red path to add midline pumps (drag to snap to vertices along the path; click a marker to delete). Each pump’s Discharge PSI is the pump outlet; the model computes the inlet pressure at that vertex and updates the profile instantly. Long runs at higher flow rates or with steep elevation changes can drive the outlet pressure very low, so add pumps until the outlet reaches your required outlet pressure. The empirical table assumes a typical water transfer manifold trailer with 6" tank hoses.
      </p>
      <p class="inline-help" style="max-width:880px; margin-top:8px;">
        KML only: upload a single LineString. Elevations are sampled from public terrain data and may be approximate.
      </p>
    </section>

    <!-- 1) Path first: user uploads KML up front -->
    <section class="section-card">
      <h3>Path (KML only)</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Upload a .kml file containing one LineString. If the route was drawn from Destination back to Source, use the "Reverse" option so the simulation starts at the Source pump.
      </p>
      <div class="form-grid">
        <div class="field">
          <label for="kml-file">Upload KML (LineString path)</label>
          <input id="kml-file" type="file" accept=".kml">
          <div class="inline-help">Up to ~2,000 points are used (downsampling applied if needed). Direction can be reversed below.</div>
        </div>
        <div class="field">
          <label>Path Drawing Direction</label>
          <div class="radio-row">
            <label><input type="radio" name="path-dir" value="source_to_dest" checked> Source → Destination</label>
            <label><input type="radio" name="path-dir" value="dest_to_source"> Destination → Source (Reverse)</label>
          </div>
          <div class="inline-help">Pick the direction that matches how your LineString was drawn so the "Source" end is simulated first.</div>
        </div>
      </div>
      <div class="inline-help" id="path-status" style="margin-top:8px;display:none;"></div>
    </section>

    <!-- 2) Core hydraulics inputs -->
    <section class="section-card">
      <h3>Hydraulic Inputs</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Set operating parameters for your system. After you click Run Calculation, give it a second to process.
      </p>
      <div class="inline-help" style="margin-top:6px; color:var(--text-muted); line-height:1.45;">
        <strong>How friction loss is calculated</strong>: The PSI loss per 100 ft is derived from an empirical lookup table that was measured on a 12‑inch layflat system at various flows (converted from barrels per minute to GPM). For 12" hose, we interpolate between the nearest table points to get the head loss in feet per 100 ft, then convert to PSI using 0.433 PSI/ft of water column.
        <br/><br/>
        For 14" and 16" hoses, the 12" baseline is scaled using a standard hydraulic similarity relationship where head loss varies with diameter to approximately the 4.87 power. In practice this means larger diameters have proportionally lower friction loss for the same total flow. Mathematically, Loss(target) ≈ Loss(12") × (12 / target_diameter)^4.87. When dual parallel runs are selected, the total flow is split evenly between the hoses. For Lookup and Hazen‑Williams, the system friction loss per 100 ft equals the loss of one hose at the per‑hose flow (no additional division). In Manual mode, the entered single‑run loss at the total flow is divided by runs^1.85 to account for the reduced flow per hose.
      </div>
      <div class="form-grid">
        <div class="field">
          <label for="flow-bpm">Flow Rate (Barrels per minute)</label>
          <input id="flow-bpm" type="number" step="0.1" min="0" value="75" data-default="75">
        </div>

        <div class="field">
          <label for="hose-size">Hose Diameter</label>
          <select id="hose-size" data-default="12">
            <option value="12" selected>12 inches</option>
            <option value="14">14 inches</option>
            <option value="16">16 inches</option>
          </select>
        </div>

        <div class="field">
          <label for="source-psi">Source Pump Discharge (PSI)</label>
          <input id="source-psi" type="number" step="0.1" min="0.1" value="100" data-default="100">
          <div class="inline-help">Starting pressure at the source.</div>
        </div>

        <div class="field">
          <label for="midline-psi">Default Booster Discharge (PSI)</label>
          <input id="midline-psi" type="number" step="0.1" min="0" value="100" data-default="100">
          <div class="inline-help">Default discharge applied when adding a manual booster. You can change per-pump in the panel.</div>
        </div>

        <div class="field">
          <label for="max-hose-psi">Max Allowable Hose Pressure (PSI)</label>
          <input id="max-hose-psi" type="number" step="1" min="1" value="150" data-default="150">
        </div>


        <div class="field">
          <label for="hose-runs">Hose Runs</label>
          <select id="hose-runs" data-default="1">
            <option value="1" selected>Single</option>
            <option value="2">Dual (parallel)</option>
          </select>
          <div class="inline-help">Dual run uses two parallel hoses. Friction loss is reduced accordingly for the same total flow.</div>
        </div>
      </div>

      <div class="section-card" style="margin-top:12px;">
        <div class="field">
          <label>Friction Loss</label>
          <div class="radio-row">
            <label><input type="radio" name="loss-method" value="lookup" checked> Calculate from Flow & Hose Size</label>
            <label><input type="radio" name="loss-method" value="manual"> Enter PSI Loss Manually</label>
            <label><input type="radio" name="loss-method" value="hazen"> Hazen Williams</label>
          </div>
          <div class="inline-help">Used to calculate friction loss along LinePath.</div>
        </div>
        <div id="manual-loss-wrap" class="field" style="display:none; margin-top:8px;">
          <label for="manual-loss-psi100">Manual PSI Loss per 100 ft</label>
          <input id="manual-loss-psi100" type="number" step="0.01" min="0" value="0" data-default="0">
        </div>
        <div id="hazen-williams-wrap" class="field" style="display:none; margin-top:8px;">
          <label for="hazen-c-factor">Hose Roughness Coefficient (C-Factor)</label>
          <input id="hazen-c-factor" type="number" step="1" min="1" value="140" data-default="140">
          <div class="inline-help">Common values: 150 for new, smooth pipe; 140 for typical use; 100 for old or rough pipe.</div>
        </div>
      </div>

      <div class="btn-group" style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap;">
        <button id="run-calc" class="btn">Run Calculation</button>
        <button id="reset-form" class="btn secondary">Reset</button>
        <button id="download-csv" class="btn secondary" title="Download hydraulic data as CSV" disabled>Download CSV</button>
      </div>
    </section>

    <section class="section-card" id="map-section" style="display:none;">
      <h3>Map Preview</h3>
      <p class="inline-help" style="margin-top:-6px;">
        The polyline shows your uploaded path.
        Click on the red line to add manual booster pumps.
      </p>
      <div id="modeler-map"></div>
      <div class="inline-help" id="map-hint" style="margin-top:6px;">Path and pump markers will display here after KML processing.</div>

      <div id="elev-retry-wrap" style="display:none; margin-top:8px;">
        <button id="retry-elev" class="btn secondary">Retry Elevations</button>
        <span class="inline-help">Elevation sampling failed. Retry will re-fetch elevation and refresh results.</span>
      </div>

      <div id="manual-panel" class="section-card" style="margin-top:10px; display:none;">
        <h3 style="margin-top:0;">Manual Pumps</h3>
        <div class="inline-help" style="margin-top:-6px;">
          Click on the red polyline to add a booster pump. Drag markers to move along the line. Click a marker to delete. Edit discharge setpoints below.
        </div>
        <div id="manual-pump-list" class="manual-pump-list" style="margin-top:8px;"></div>
      </div>
    </section>

    <section class="section-card" id="results-section" style="display:none;">
      <h3>Results Summary</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Total distance is derived from your path after downsampling (if applied).
      </p>
      <table class="results-table">
        <tbody>
          <tr>
            <td>Total Distance (ft)</td>
            <td data-value="—"><span id="out-total-dist">—</span></td>
          </tr>
          <tr>
            <td>Used PSI Loss / 100 ft</td>
            <td data-value="—"><span id="out-used-loss">—</span></td>
          </tr>
          <tr>
            <td>Final Outlet Pressure (PSI)</td>
            <td data-value="—"><span id="out-final-psi">—</span></td>
          </tr>
          <tr>
            <td>Midline Pumps Placed</td>
            <td data-value="—"><span id="out-pump-count">—</span></td>
          </tr>
        </tbody>
      </table>
      <div id="warnings-wrap" style="margin-top:8px; display:none;">
        <strong>Warnings</strong>
        <ul class="warnings" id="warnings-list"></ul>
      </div>
    </section>

    <section class="section-card" id="chart-section" style="display:none;">
      <h3>Pressure Profile</h3>
      <p class="inline-help" style="margin-top:-6px;">
        The blue line is pressure along the path (includes elevation changes and friction). Vertical jumps indicate pump boosts.
      </p>
      <div class="chart-box">
        <canvas id="pressureChart"></canvas>
      </div>
    </section>

    <section class="section-card" id="elev-chart-section" style="display:none;">
      <h3>Elevation Profile and Pump Location</h3>
      <p class="inline-help" style="margin-top:-6px;">
        Elevation along the line (ft) with black dots at pump locations. X-axis is distance in miles.
      </p>
      <div class="chart-box">
        <canvas id="elevationChart"></canvas>
      </div>
    </section>
  </main>

  <footer class="site-footer" role="contentinfo">
    <nav class="footer-nav" aria-label="Footer">
      <a class="footer-link" href="index.html">Home</a>
      <a class="footer-link" href="layflat-modeler.html" aria-current="page">Layflat Hydraulic Modeler</a>
      <a id="resume-link" class="footer-link" href="resume.html" data-protected="true">Resume</a>
    </nav>
  </footer>

  <!-- Busy overlay -->
  <div id="busy-overlay" aria-live="polite" aria-busy="true">
    <div class="busy-card">
      <div style="display:flex;align-items:center;justify-content:center;">
        <div class="spinner" aria-hidden="true"></div>
        <div class="busy-text">Loading…</div>
      </div>
    </div>
  </div>
 
  <!-- Leaflet JS for map preview -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
 
  <!-- Chart.js for pressure plot -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script>
    // Dark theme defaults for Chart.js to mimic reference styling
    // Set these before creating charts
    if (window.Chart) {
      Chart.defaults.color = getComputedStyle(document.documentElement).getPropertyValue('--chart-text').trim() || '#9aa3ad';
      Chart.defaults.font.family = 'ISOCPEUR, Arial, sans-serif';
      Chart.defaults.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid-minor').trim() || '#1e2630';
      Chart.defaults.scale.grid.color = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid-minor').trim() || '#1e2630';
      Chart.defaults.scale.ticks.color = getComputedStyle(document.documentElement).getPropertyValue('--chart-text').trim() || '#9aa3ad';
      Chart.defaults.plugins.legend.labels.color = getComputedStyle(document.documentElement).getPropertyValue('--chart-text').trim() || '#9aa3ad';
      Chart.defaults.plugins.tooltip.backgroundColor = '#0f1115';
      Chart.defaults.plugins.tooltip.borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border').trim() || '#2a2d2f';
      Chart.defaults.plugins.tooltip.borderWidth = 1;
    }
  </script>

  <!-- Plugin to force pump markers to draw last, above lines -->
  <script>
    // Draw pump markers on top after all datasets using Chart.js plugin hook
    const PumpOnTopPlugin = {
      id: 'pumpOnTop',
      afterDatasetsDraw(chart, args, pluginOptions) {
        const { ctx, data } = chart;
        // Find pump datasets by label (robust to index changes)
        const pumpDatasets = chart.getDatasetMeta ?
          data.datasets
            .map((ds, i) => ({ ds, meta: chart.getDatasetMeta(i) }))
            .filter(x => x.ds && x.ds.label && String(x.ds.label).toLowerCase() === 'pump')
          : [];

        if (!pumpDatasets.length) return;

        ctx.save();
        pumpDatasets.forEach(({ ds, meta }) => {
          if (!meta || !meta.data) return;
          const radius = Number(ds.pointRadius ?? 7);
          const color = ds.pointBackgroundColor || '#ff7f0e';

          meta.data.forEach(element => {
            if (!element || !element.x || !element.y) return;
            const x = element.x;
            const y = element.y;
            // draw triangle centered at (x, y)
            const h = radius;
            const w = radius * 1.15;
            ctx.beginPath();
            ctx.moveTo(x, y - h);        // top
            ctx.lineTo(x + w, y + h);    // bottom right
            ctx.lineTo(x - w, y + h);    // bottom left
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            if (ds.pointBorderColor) {
              ctx.lineWidth = 1.25;
              ctx.strokeStyle = ds.pointBorderColor;
              ctx.stroke();
            }
          });
        });
        ctx.restore();
      }
    };

    if (window.Chart && !Chart.registry.plugins.get('pumpOnTop')) {
      Chart.register(PumpOnTopPlugin);
    }
  </script>

  <!-- Lightweight client-side gate for Resume link -->
  <script>
    (function(){
      const link = document.getElementById('resume-link');
      if (!link) return;
      const PASSWORD = 'water2025';
      const STORAGE_KEY = 'resume_access_granted_v1';
      function hasAccess(){ try { return sessionStorage.getItem(STORAGE_KEY) === 'true'; } catch(_) { return false; } }
      function grantAccess(){ try { sessionStorage.setItem(STORAGE_KEY, 'true'); } catch(_) {} }
      function promptForPassword(){
        const input = window.prompt('Enter password to view the resume:');
        if (input === null) return false;
        if (input === PASSWORD) { grantAccess(); return true; }
        window.alert('Incorrect password.'); return false;
      }
      function handleNavigate(ev){
        if (hasAccess()) return;
        ev.preventDefault();
        if (promptForPassword()) {
          window.location.href = link.getAttribute('href') || 'resume.html';
        }
      }
      link.addEventListener('click', handleNavigate);
      link.addEventListener('keydown', function(e){
        if (e.key === 'Enter' || e.key === ' ') handleNavigate(e);
      });
    })();
  </script>
  <script>
    // --- Constants and data ---
    const BARRELS_TO_GALLONS = 42.0;
    const PSI_PER_FOOT_WATER = 0.433;

    // Pump icon image (forces distinct rendering path to ensure on-top layering)
    const pumpIcon = new Image(14, 14);
    pumpIcon.src = 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14"><path d="M7 0L14 10.5H0z" fill="#ff7f0e"/></svg>');

    // Backend proxy endpoint hosted on PythonAnywhere (Flask).
    // Prefer this to eliminate CORS/proxy/JSONP issues.
    const BACKEND_ELEV_ENDPOINT = '/elevation';

    // Keep original OpenTopoData URL for fallback path if backend is unavailable.
    const OPENTOPODATA_ENDPOINT = 'https://api.opentopodata.org/v1/ned10m';

    // Minimal proxy list retained ONLY for hard fallback after backend failure.
    const CORS_JSON_PROXIES = [
      { mode: 'prefix', value: 'https://r.jina.ai/' }
    ];

    const MAX_POINTS = 2000;          // hard cap for safety
    const BATCH_SIZE = 100;           // batch chunk (server matches this)
    // 12" reference table: [GPM, head loss (ft) per 100 ft]
    const HOSE_DATA_12_INCH = [
      [0,0.0],[300,0.03],[350,0.04],[400,0.04],[450,0.05],
      [500,0.06],[550,0.07],[600,0.09],[650,0.11],[700,0.13],
      [750,0.15],[800,0.17],[850,0.19],[900,0.21],[950,0.23],
      [1000,0.26],[1100,0.30],[1200,0.35],[1300,0.40],[1400,0.46],
      [1500,0.53],[1600,0.60],[1700,0.67],[1800,0.75],[1900,0.83],
      [2000,0.92],[2500,1.45],[3000,2.05],[3500,2.75],[4000,3.57],
      [4500,4.31],[5000,5.01]
    ];

    function bpmToGpm(bpm) { return bpm * BARRELS_TO_GALLONS; }

    function lookupHeadLoss12in(gpm) {
      if (gpm < 0) return null;
      if (gpm === 0) return 0.0;
      let lower = null, upper = null;
      for (let i=0;i<HOSE_DATA_12_INCH.length;i++) {
        const [x, y] = HOSE_DATA_12_INCH[i];
        if (x === gpm) return y;
        if (x < gpm) lower = [x,y];
        if (x > gpm) { upper = [x,y]; break; }
      }
      if (!lower && upper) return null;
      if (lower && !upper) return null;
      if (!lower || !upper) return null;
      const [x1,y1] = lower, [x2,y2] = upper;
      if (x2 === x1) return y1;
      return y1 + (y2 - y1) * (gpm - x1) / (x2 - x1);
    }

    function scaleHeadLossByDiameter(headLoss12, targetInches) {
      const d = Number(targetInches);
      if (!d || d <= 0) return headLoss12;
      if (d === 12) return headLoss12;
      const factor = Math.pow(12.0 / d, 4.87);
      return headLoss12 * factor;
    }

    function headLossFtToPsi(headLossFt) {
      return headLossFt * PSI_PER_FOOT_WATER;
    }

    function calculateHazenWilliamsLoss(gpm, cFactor, diameterInches) {
          if (gpm <= 0 || cFactor <= 0 || diameterInches <= 0) return 0;
          // Standard Hazen-Williams head loss in feet of water per 100 ft:
          // hf_100ft = 0.2083 * (100/C)^1.85 * Q_gpm^1.85 / d_in^4.87
          const hf_per_100ft = 0.2083 * Math.pow(100 / cFactor, 1.85) * Math.pow(gpm, 1.85) / Math.pow(diameterInches, 4.87);
          // Convert ft of water to PSI per 100 ft (1 ft of water ≈ 0.433 PSI)
          return hf_per_100ft * PSI_PER_FOOT_WATER;
        }

    // Small helper for retry backoff
    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // Downsample coordinates to at most maxPoints using even index sampling
    function downsampleLatLngs(latlngs, maxPoints) {
      if (!latlngs || latlngs.length <= maxPoints) return latlngs || [];
      const result = [];
      const step = (latlngs.length - 1) / (maxPoints - 1);
      for (let i = 0; i < maxPoints; i++) {
        const idx = Math.round(i * step);
        result.push(latlngs[idx]);
      }
      return result;
    }

    // Parse KML text to extract first LineString coordinates as [lat, lng]
    function parseKmlLineStringToLatLngs(kmlText) {
      const parser = new DOMParser();
      const xml = parser.parseFromString(kmlText, 'text/xml');
      const coords = xml.getElementsByTagName('coordinates');
      if (!coords || !coords.length) return [];
      const text = coords[0].textContent || '';
      const parts = text.trim().split(/\s+/);
      const latlngs = [];
      for (const p of parts) {
        const [lonStr, latStr] = p.split(',');
        const lat = parseFloat(latStr), lon = parseFloat(lonStr);
        if (isFinite(lat) && isFinite(lon)) latlngs.push([lat, lon]);
      }
      return latlngs;
    }

    // KMZ parsing intentionally unsupported to simplify client-side; KML only.
    async function extractKmlFromKmz(file) {
      throw new Error('KMZ is not supported. Please upload a .kml file.');
    }

    // Fetch elevations with backend-first strategy; returns array of meters
    async function fetchElevationsOpenTopo(latlngs) {
      const elevations = [];

      async function fetchJson(url, init) {
        const resp = await fetch(url, init);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        return await resp.json();
      }

      // JSONP fallback kept for extreme cases (should rarely be needed now)
      async function fetchViaJsonp(url) {
        return new Promise((resolve, reject) => {
          const cbName = 'otd_cb_' + Math.random().toString(36).slice(2);
          let finished = false;
          let script = null;
          const cleanup = () => {
            try { delete window[cbName]; } catch {}
            if (script && script.parentNode) script.parentNode.removeChild(script);
          };
          const finish = (fn, val) => {
            if (finished) return;
            finished = true;
            cleanup();
            fn(val);
          };
          window[cbName] = (payload) => {
            try {
              const txt = typeof payload === 'string' ? payload : (payload && payload.contents) || '';
              const data = JSON.parse(txt);
              finish(resolve, data);
            } catch (e) {
              finish(reject, new Error('JSONP decode error'));
            }
          };
          const jsonpUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}&callback=${cbName}`;
          script = document.createElement('script');
          script.src = jsonpUrl;
          script.onerror = () => finish(reject, new Error('JSONP script load error'));
          document.head.appendChild(script);
          setTimeout(() => finish(reject, new Error('JSONP timeout')), 10000);
        });
      }

      const MAX_RETRIES = 2;

      for (let i = 0; i < latlngs.length; i += BATCH_SIZE) {
        const batch = latlngs.slice(i, i + BATCH_SIZE);
        const locArr = batch.map(([lat, lon]) => `${lat.toFixed(6)},${lon.toFixed(6)}`);

        let got = null;
        let attempt = 0;

        while (attempt <= MAX_RETRIES && !got) {
          try {
            // 1) Try our backend first (POST /elevation)
            const data = await fetchJson(BACKEND_ELEV_ENDPOINT, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
              body: JSON.stringify({ locations: locArr })
            });
            if (data && data.status === 'OK' && Array.isArray(data.results)) {
              got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
            } else {
              throw new Error('Backend invalid payload');
            }
          } catch (backendErr) {
            try {
              // 2) Fallback to reader proxy of OpenTopoData (GET)
              const locations = encodeURIComponent(locArr.join('|'));
              const directUrl = `${OPENTOPODATA_ENDPOINT}?locations=${locations}`;
              const proxiedUrl = `${CORS_JSON_PROXIES[0].value}${directUrl}`;
              const data = await fetchJson(proxiedUrl, { headers: { 'Accept': 'application/json' } });
              if (data && data.status === 'OK' && Array.isArray(data.results)) {
                got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
              } else {
                throw new Error('Proxy invalid payload');
              }
            } catch (proxyErr) {
              try {
                // 3) Last resort JSONP
                const locations = encodeURIComponent(locArr.join('|'));
                const directUrl = `${OPENTOPODATA_ENDPOINT}?locations=${locations}`;
                const data = await fetchViaJsonp(directUrl);
                if (!data || data.status !== 'OK' || !Array.isArray(data.results)) throw new Error('JSONP invalid payload');
                got = data.results.map(r => (r && typeof r.elevation === 'number') ? r.elevation : 0);
              } catch (jsonpErr) {
                if (attempt === MAX_RETRIES) throw new Error('Elevation batch failed after retries');
              }
            }
          }

          if (!got) {
            await sleep(400 + attempt * 400);
            attempt++;
          }
        }

        if (!got) throw new Error('Elevation batch failed');

        elevations.push(...got);
      }
      return elevations;
    }

    // Compute cumulative distance in feet along polyline of [lat, lon] using simple haversine
    function cumulativeDistancesFt(latlngs) {
      const R = 6371000; // meters
      const toRad = d => d * Math.PI / 180;
      const dists = [0];
      let cum = 0;
      for (let i = 1; i < latlngs.length; i++) {
        const [lat1, lon1] = latlngs[i-1];
        const [lat2, lon2] = latlngs[i];
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const meters = R * c;
        const feet = meters * 3.28084;
        cum += feet;
        dists.push(cum);
      }
      return dists;
    }

    // [Removed] automatic midline pump placement (legacy)

    // Removed automatic placement algorithms (optimized/curve). Manual-only app.

    // Removed automatic placement algorithms (minimized/fixed-setpoint). Manual-only app.

    // Build pressure profile including placed pumps (clear boost visualization)
    // Returns an object with distances, pressures, and kinds arrays aligned 1:1 for Chart.js
    function buildProfileWithPumps(distFt, elevFt, sourcePsi, pumps, psiLossPer100) {
      // Build pressure profile for plotting. Do NOT clamp the plotted pressures;
      // only clamp the displayed inlet values at pump markers elsewhere.
      const lossPerFt = psiLossPer100 / 100.0;
      const outDistances = [];
      const outPressures = [];
      const outKinds = []; // 'normal' | 'pre' | 'post'
      let p = sourcePsi;
      let pumpIdx = 0;

      // Seed first point (true simulated pressure)
      outDistances.push(distFt[0]);
      outPressures.push(p);
      outKinds.push('normal');

      // Corrected loop: compute segment loss to node i first, then process pump at i
      for (let i = 1; i < distFt.length; i++) {
        // 1) pressure at the end of segment (i-1 -> i)
        const segLen = distFt[i] - distFt[i - 1];
        const dhFt = elevFt[i] - elevFt[i - 1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        const pressureAtNodeI = p + elevDeltaPsi - frictionPsi;

        // 2) if pump at node i, emit pre with inlet pressureAtNodeI, then post with discharge
        if (pumpIdx < pumps.length && pumps[pumpIdx].index === i) {
          // pre (inlet) exactly at node i
          outDistances.push(distFt[i]);
          outPressures.push(pressureAtNodeI);
          outKinds.push('pre');

          // jump to discharge
          p = pumps[pumpIdx].discharge;

          // post (discharge) at same node i
          outDistances.push(distFt[i]);
          outPressures.push(p);
          outKinds.push('post');
          pumpIdx++;
        } else {
          // no pump at node i, normal node
          p = pressureAtNodeI;
          outDistances.push(distFt[i]);
          outPressures.push(p);
          outKinds.push('normal');
        }
      }

      return { distances: outDistances, pressures: outPressures, kinds: outKinds };
    }

    // --- DOM refs ---
    const elFlowBpm = document.getElementById('flow-bpm');
    const elHoseSize = document.getElementById('hose-size');
    const elSourcePsi = document.getElementById('source-psi');
    const elMidlinePsi = document.getElementById('midline-psi');
    const elMaxHose = document.getElementById('max-hose-psi');
    const elHoseRuns = document.getElementById('hose-runs');

    const lossRadios = document.querySelectorAll('input[name="loss-method"]');
    const elManualWrap = document.getElementById('manual-loss-wrap');
    const elManualPsi100 = document.getElementById('manual-loss-psi100');
    const elHazenWrap = document.getElementById('hazen-williams-wrap');
    const elHazenCFactor = document.getElementById('hazen-c-factor');

    const elKmlFile = document.getElementById('kml-file');
    const pathDirRadios = document.querySelectorAll('input[name="path-dir"]');
    // Back-compat guard in case req-outlet existed in prior state
    try { const stale = document.getElementById('req-outlet-psi'); if (stale) stale.remove(); } catch {}

    const elRun = document.getElementById('run-calc');
    const elReset = document.getElementById('reset-form');

    const elMapSection = document.getElementById('map-section');
    const elResults = document.getElementById('results-section');
    const elOutDist = document.getElementById('out-total-dist');
    const elOutUsedLoss = document.getElementById('out-used-loss');
    const elOutFinalPsi = document.getElementById('out-final-psi');
    const elOutOutletMet = document.getElementById('out-outlet-met');
    const elOutPumpCount = document.getElementById('out-pump-count');
    const elWarningsWrap = document.getElementById('warnings-wrap');
    const elWarningsList = document.getElementById('warnings-list');

    const elChartSection = document.getElementById('chart-section');
    const chartCanvas = document.getElementById('pressureChart');

    // Elevation chart DOM
    const elElevChartSection = document.getElementById('elev-chart-section');
    const elevChartCanvas = document.getElementById('elevationChart');
 
    let chartInstance = null;
    let elevChartInstance = null;
    let mapInstance = null;
    let pathLayer = null;
    let pumpLayer = null;

    // Manual placement state
    let manualMode = false;
    let manualLatLngs = [];  // active path
    let manualDistFt = [];   // cumulative distances for path
    let manualElevFt = [];   // elevation samples for path
    // pumps: { index: i, distanceFt, discharge, pressureBefore (computed), marker }
    let manualPumps = [];

    // --- Elevation cache helpers (reuse elevations if KML path doesn't change) ---
    function pathKeyFromLatLngs(latlngs) {
      // Build a compact, stable string key from the downsampled coords
      // Use 6-decimal precision to match fetch batching precision
      if (!Array.isArray(latlngs) || !latlngs.length) return '';
      const parts = [];
      for (let i = 0; i < latlngs.length; i++) {
        const [lat, lon] = latlngs[i];
        parts.push(lat.toFixed(6) + ',' + lon.toFixed(6));
      }
      return parts.join('|');
    }

    // Simple in-memory cache keyed by pathKey
    window.__elevCache = window.__elevCache || Object.create(null);

    function getCachedElevationsFt(pathKey) {
      try {
        const entry = window.__elevCache[pathKey];
        if (!entry || !Array.isArray(entry.elevFt)) return null;
        return entry.elevFt.slice(); // return a copy
      } catch {
        return null;
      }
    }

    function setCachedElevationsFt(pathKey, elevFt) {
      try {
        window.__elevCache[pathKey] = { elevFt: Array.isArray(elevFt) ? elevFt.slice() : [] };
      } catch {}
    }

    function currentLossMethod() {
      for (const r of lossRadios) if (r.checked) return r.value;
      return 'lookup';
    }
    function currentPathDir() {
      for (const r of pathDirRadios) if (r.checked) return r.value;
      return 'source_to_dest';
    }
    function updateLossInputVisibility() {
      const method = currentLossMethod();
      elManualWrap.style.display = method === 'manual' ? 'block' : 'none';
      elHazenWrap.style.display = method === 'hazen' ? 'block' : 'none';
    }
    lossRadios.forEach(r => r.addEventListener('change', updateLossInputVisibility));
    updateLossInputVisibility();

    function resetForm() {
      // Reset inputs to their initial defaults as in markup
      function valOrAttr(el) {
        if (!el) return;
        const def = el.getAttribute('data-default');
        if (def != null) {
          el.value = def;
        } else if (el.hasAttribute('value')) {
          el.value = el.getAttribute('value');
        }
      }
      valOrAttr(elFlowBpm);
      valOrAttr(elHoseSize);
      valOrAttr(elSourcePsi);
      valOrAttr(elMidlinePsi);
      valOrAttr(elMaxHose);
      valOrAttr(elManualPsi100);
      valOrAttr(elHazenCFactor);
      valOrAttr(elHoseRuns);

      // Reset radios to their original checked state using DOM attributes
      const lossLookup = document.querySelector('input[name="loss-method"][value="lookup"]');
      const lossManual = document.querySelector('input[name="loss-method"][value="manual"]');
      const lossHazen = document.querySelector('input[name="loss-method"][value="hazen"]');
      if (lossLookup) lossLookup.checked = lossLookup.hasAttribute('checked');
      if (lossManual) lossManual.checked = lossManual.hasAttribute('checked');
      if (lossHazen) lossHazen.checked = lossHazen.hasAttribute('checked');

      const pathSrcToDest = document.querySelector('input[name="path-dir"][value="source_to_dest"]');
      const pathDestToSrc = document.querySelector('input[name="path-dir"][value="dest_to_source"]');
      if (pathSrcToDest) pathSrcToDest.checked = pathSrcToDest.hasAttribute('checked');
      if (pathDestToSrc) pathDestToSrc.checked = pathDestToSrc.hasAttribute('checked');

      updateLossInputVisibility();

      // Hide main sections
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';
      elMapSection.style.display = 'none';

      // Destroy pressure chart instance
      if (chartInstance) { chartInstance.destroy(); chartInstance = null; }

      // Destroy elevation chart instance and hide its section; clear the canvas to remove residual drawing
      if (elevChartInstance) { try { elevChartInstance.destroy(); } catch {} elevChartInstance = null; }
      if (elElevChartSection) { elElevChartSection.style.display = 'none'; }
      if (elevChartCanvas && elevChartCanvas.getContext) {
        try {
          const ctx = elevChartCanvas.getContext('2d');
          ctx && ctx.clearRect(0, 0, elevChartCanvas.width, elevChartCanvas.height);
        } catch {}
      }

      // Tear down map and layers
      if (mapInstance) {
        try { mapInstance.remove(); } catch{}
        mapInstance = null; pathLayer = null; pumpLayer = null;
      }

      // Clear file chooser
      elKmlFile.value = '';

      // Reset manual placement mode and state
      manualMode = false;
      manualLatLngs = [];
      manualDistFt = [];
      manualElevFt = [];
      manualPumps = [];

      // Hide manual panel and clear list UI
      const manualPanelEl = document.getElementById('manual-panel');
      if (manualPanelEl) manualPanelEl.style.display = 'none';
      const manualListEl = document.getElementById('manual-pump-list');
      if (manualListEl) manualListEl.innerHTML = '';

      // Disable report/CSV buttons and clear last run/report state
      const reportBtn = document.getElementById('generate-report');
      if (reportBtn) reportBtn.disabled = true;
      const csvBtn = document.getElementById('download-csv');
      if (csvBtn) csvBtn.disabled = true;
      try {
        delete window.__modelerLastRun;
        delete window.__lastPumps;
        delete window.__lastPlacementStrategy;
        delete window.__lastUsedPsiLossPer100;
        delete window.__lastWarnings;
        delete window.__lastDsLatLngs;
        delete window.__lastPathKey;
      } catch {}

      // Hide path status and clear text
      const pathStatus = document.getElementById('path-status');
      if (pathStatus) { pathStatus.style.display = 'none'; pathStatus.textContent = ''; }

      // Hide warnings and clear list
      if (elWarningsWrap) elWarningsWrap.style.display = 'none';
      if (elWarningsList) elWarningsList.innerHTML = '';

      // Hide "Retry Elevations" UI
      const retryWrap = document.getElementById('elev-retry-wrap');
      if (retryWrap) retryWrap.style.display = 'none';

      // Also remove any lingering JSONP script tags (defensive)
      try {
        const heads = document.querySelectorAll('head script[src*="api.allorigins.win/get"]');
        heads.forEach(s => s.parentNode && s.parentNode.removeChild(s));
      } catch {}
    }
    elReset.addEventListener('click', resetForm);

    function ensureMap() {
      if (mapInstance) return mapInstance;
      elMapSection.style.display = 'block';
      mapInstance = L.map('modeler-map', { zoomControl: true }).setView([35.5, -98.5], 6);

      // Base layers
      const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap contributors'
      });

      // Esri World Imagery (satellite)
      const esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Tiles © Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
      });

      // Esri World Boundaries and Places (labels) to create a hybrid overlay
      const esriLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution: 'Labels © Esri'
      });

      // Create a hybrid group (satellite + labels)
      const hybrid = L.layerGroup([esriSat, esriLabels]);

      // Add default base (Satellite with labels - Hybrid)
      // Turn on hybrid (satellite + labels) by default so users see imagery immediately.
      hybrid.addTo(mapInstance);

      // Pump layer lives above basemap(s)
      pumpLayer = L.layerGroup().addTo(mapInstance);

      // Layer control to switch between basemaps
      const baseMaps = {
        'Streets (OSM)': osm,
        'Satellite (Esri World Imagery)': esriSat,
        'Hybrid (Satellite + Labels)': hybrid
      };
      L.control.layers(baseMaps, null, { collapsed: true }).addTo(mapInstance);

      return mapInstance;
    }

    // Small status helper to report path length and points
    function updatePathStatus(latlngs, totalFt) {
      const el = document.getElementById('path-status');
      if (!el) return;
      if (!latlngs || !latlngs.length) { el.style.display = 'none'; return; }
      el.style.display = 'block';
      el.textContent = `Loaded ${latlngs.length} points • Total distance ~ ${totalFt.toFixed(0)} ft`;
    }

    function showBusy(msg = 'Loading…') {
      const ov = document.getElementById('busy-overlay');
      if (!ov) return;
      ov.style.display = 'flex';
      const t = ov.querySelector('.busy-text');
      if (t) t.textContent = msg;
    }
    function hideBusy() {
      const ov = document.getElementById('busy-overlay');
      if (ov) ov.style.display = 'none';
    }

    function nearestPathIndex(latlngs, latlng) {
      // simple nearest vertex search
      let best = 0, bestD = Infinity;
      for (let i=0;i<latlngs.length;i++){
        const dLat = latlngs[i][0] - latlng.lat;
        const dLng = latlngs[i][1] - latlng.lng;
        const d2 = dLat*dLat + dLng*dLng;
        if (d2 < bestD) { bestD = d2; best = i; }
      }
      return best;
    }

    function rebuildManualList() {
      const list = document.getElementById('manual-pump-list');
      if (!list) return;
      if (!manualPumps.length) { list.innerHTML = '<div class="inline-help">No manual pumps yet.</div>'; return; }
      list.innerHTML = '';
      manualPumps
        .sort((a,b) => a.distanceFt - b.distanceFt)
        .forEach((p, idx) => {
          const row = document.createElement('div');
          row.className = 'manual-pump-row';
          row.innerHTML = `
            <div class="mp-col mp-col--id">Pump #${idx+1} @ ${(p.distanceFt/5280).toFixed(2)} mi</div>
            <div class="mp-col mp-col--inlet">
              <span class="mp-label">Inlet (at pump)</span>
              <span class="mp-value">${(Number(p.pressureBefore ?? 0)).toFixed(3)} PSI</span>
            </div>
            <div class="mp-col mp-col--disch">
              <label class="mp-label" for="mp-dis-${idx}">Discharge PSI</label>
              <input id="mp-dis-${idx}" class="mp-input" type="number" step="0.1" inputmode="decimal" value="${Number(p.discharge ?? elMidlinePsi.value)}">
            </div>
            <div class="mp-col mp-col--actions">
              <button class="btn secondary mp-del" data-del="${idx}">Delete</button>
            </div>
          `;
          // wire discharge edit: keep focus and allow continuous typing without re-clicking
          const inp = row.querySelector('.mp-input');
          // prevent update loop from rebuilding list while typing
          let typing = false;
          let rafId = null;
          const liveUpdate = () => {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(() => {
              const v = Number(inp.value);
              p.discharge = isFinite(v) ? v : 0;
              // Update pressures and chart only, avoid rebuilding list to preserve focus
              recomputeManualInlets();
              const prof = computeProfileWithGivenPumps(manualDistFt, manualElevFt, Number(elSourcePsi.value), manualPumps, window.__lastUsedPsiLossPer100 || 0);
              const finalPressure = prof.pressures.length ? prof.pressures[prof.pressures.length-1] : 0;
              renderResults(manualDistFt[manualDistFt.length-1]||0, (window.__lastUsedPsiLossPer100||0), finalPressure, manualPumps.length, (window.__lastWarnings||[]), prof.distances, prof.pressures, 0);
            });
          };
          // On input, do lightweight update without rebuilding list
          inp.addEventListener('input', liveUpdate);
          // On blur or Enter, commit and then rebuild list for any formatting
          const commitAndRebuild = () => {
            const v = Number(inp.value);
            p.discharge = isFinite(v) ? v : 0;
            updateManualProfileAndUI();
            // restore focus to same field index if still present
            requestAnimationFrame(() => {
              const again = document.getElementById('mp-dis-${idx}');
              if (again) { try { again.focus(); again.setSelectionRange(again.value.length, again.value.length); } catch {} }
            });
          };
          inp.addEventListener('change', commitAndRebuild);
          inp.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); commitAndRebuild(); }
          });
          inp.addEventListener('blur', commitAndRebuild);
          // wire delete
          const del = row.querySelector('.mp-del');
          del.addEventListener('click', () => {
            try { pumpLayer.removeLayer(p.marker); } catch {}
            manualPumps.splice(idx,1);
            updateManualProfileAndUI();
          });
          list.appendChild(row);
        });
    }

    function computeProfileWithGivenPumps(distFt, elevFt, sourcePsi, pumps, psiLossPer100) {
      // identical to buildProfileWithPumps but uses provided pumps array; returns {distances, pressures, kinds}
      const lossPerFt = psiLossPer100 / 100.0;
      const outDistances = [];
      const outPressures = [];
      const outKinds = [];
      let p = sourcePsi;
      let pumpIdx = 0;
      outDistances.push(distFt[0]); outPressures.push(p); outKinds.push('normal');

      // Corrected loop: compute segment loss to node i first, then process pump at i
      for (let i = 1; i < distFt.length; i++) {
        const segLen = distFt[i] - distFt[i-1];
        const dhFt = elevFt[i] - elevFt[i-1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        const pressureAtNodeI = p + elevDeltaPsi - frictionPsi;

        if (pumpIdx < pumps.length && pumps[pumpIdx].index === i) {
          // Pre at exact vertex uses inlet pressure computed for node i
          outDistances.push(distFt[i]); outPressures.push(pressureAtNodeI); outKinds.push('pre');

          // Post jump to pump discharge
          p = pumps[pumpIdx].discharge;
          outDistances.push(distFt[i]); outPressures.push(p); outKinds.push('post');
          pumpIdx++;
        } else {
          // Normal node
          p = pressureAtNodeI;
          outDistances.push(distFt[i]); outPressures.push(p); outKinds.push('normal');
        }
      }
      return { distances: outDistances, pressures: outPressures, kinds: outKinds };
    }

    function recomputeManualInlets() {
      // Recompute inlet pressures at pump vertices using corrected ordering:
      // compute segment loss to node i first, then process a pump at i.
      const sourcePsi = Number(elSourcePsi.value);
      const usedPsiLossPer100 = window.__lastUsedPsiLossPer100 || 0;
      const lossPerFt = usedPsiLossPer100 / 100.0;

      // Ensure pumps are processed in path order
      manualPumps.sort((a, b) => a.index - b.index);

      let p = sourcePsi;
      let pumpIdx = 0;

      for (let i = 1; i < manualDistFt.length; i++) {
        // 1) pressure at the end of segment (i-1 -> i)
        const segLen = manualDistFt[i] - manualDistFt[i - 1];
        const dhFt = manualElevFt[i] - manualElevFt[i - 1];
        const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
        const frictionPsi = lossPerFt * segLen;
        const pressureAtNodeI = p + elevDeltaPsi - frictionPsi;

        // 2) if a pump exists at node i, set inlet to pressureAtNodeI, then jump to discharge
        if (pumpIdx < manualPumps.length && manualPumps[pumpIdx].index === i) {
          manualPumps[pumpIdx].pressureBefore = pressureAtNodeI; // true inlet at node i
          p = Number(manualPumps[pumpIdx].discharge || elMidlinePsi.value); // post-pump for next segment
          pumpIdx++;
        } else {
          // No pump: continue with pressure at node i
          p = pressureAtNodeI;
        }
      }
    }

    function updateManualProfileAndUI() {
      // recompute inlets, redraw markers list, refresh chart/results
      recomputeManualInlets();
      rebuildManualList();

      // Build profile from manual pumps
      const prof = computeProfileWithGivenPumps(manualDistFt, manualElevFt, Number(elSourcePsi.value), manualPumps, window.__lastUsedPsiLossPer100 || 0);
      const distancesForChart = prof.distances;
      const pressures = prof.pressures;
      const kinds = prof.kinds;

      // Update map markers popups to show true inlet at pump vertex (matches CSV pre-row)
      pumpLayer.clearLayers();
      manualPumps.forEach((p, idx) => {
        const [lat, lon] = manualLatLngs[p.index];
        const inletAtVertex = Number(p.pressureBefore ?? 0); // computed pre at vertex
        const m = L.marker([lat, lon], { draggable: true })
          .bindPopup(`<b>Manual Pump #${idx+1}</b><br>Distance: ${p.distanceFt.toFixed(0)} ft<br>Inlet (at pump): ${inletAtVertex.toFixed(3)} PSI<br>Discharge: ${Number(p.discharge||0).toFixed(3)} PSI`);
        m.on('dragend', (ev) => {
          const ll = ev.target.getLatLng();
          const i = nearestPathIndex(manualLatLngs, ll);
          p.index = i;
          p.distanceFt = manualDistFt[i];
          p.marker.setLatLng([manualLatLngs[i][0], manualLatLngs[i][1]]);
          updateManualProfileAndUI();
        });
        m.on('click', () => { // delete on click
          try { pumpLayer.removeLayer(m); } catch {}
          const k = manualPumps.indexOf(p);
          if (k>=0) { manualPumps.splice(k,1); updateManualProfileAndUI(); }
        });
        p.marker = m;
        pumpLayer.addLayer(m);
      });

      // Results and chart: pumpCount from manual, final outlet from profile tail
      const finalPressure = pressures.length ? pressures[pressures.length-1] : 0;
      renderResults(manualDistFt[manualDistFt.length-1]||0, (window.__lastUsedPsiLossPer100||0), finalPressure, manualPumps.length, (window.__lastWarnings||[]), distancesForChart, pressures, 0, kinds);

      // Elevation chart update (manual mode)
      renderElevationChart(manualDistFt, manualElevFt, manualPumps);
 
      // Persist last run for report with manual selection
      // Build a fresh, sorted summary for report consistency
      const sortedForReport = manualPumps
        .slice()
        .sort((a,b) => a.distanceFt - b.distanceFt)
        .map(p => ({
          index: p.index,
          distanceFt: p.distanceFt,
          pressureBefore: p.pressureBefore,
          discharge: Number(p.discharge || 0)
        }));

      // Persist last run for report with manual selection
      window.__lastPumps = sortedForReport;
      window.__lastPlacementStrategy = 'manual';

      // Keep __modelerLastRun synchronized for report
      window.__modelerLastRun = window.__modelerLastRun || {};
      window.__modelerLastRun.profile = { distances: distancesForChart, pressures };
      // Also persist the elevation profile (ft) aligned to dist indices for the report
      window.__modelerLastRun.elevationsFt = Array.isArray(manualElevFt) ? manualElevFt.slice() : [];
      window.__modelerLastRun.baseDistancesFt = Array.isArray(manualDistFt) ? manualDistFt.slice() : [];
      window.__modelerLastRun.results = window.__modelerLastRun.results || {};
      window.__modelerLastRun.results.finalPressure = finalPressure;
      window.__modelerLastRun.pumpsSummary = sortedForReport;
      window.__modelerLastRun.placementStrategy = 'manual';
    }

    function renderPathOnMap(latlngs, pumps) {
      const map = ensureMap();
      if (pathLayer) { map.removeLayer(pathLayer); pathLayer = null; }
      pumpLayer.clearLayers();

      if (latlngs && latlngs.length > 1) {
        pathLayer = L.polyline(latlngs, { color: 'red', weight: 5 }).addTo(map);
        map.fitBounds(pathLayer.getBounds().pad(0.1));

        // Manual mode click handler
        if (manualMode) {
          pathLayer.on('click', (ev) => {
            const i = nearestPathIndex(latlngs, ev.latlng);
            const distanceFt = manualDistFt[i] || 0;
            const discharge = Number(elMidlinePsi.value);
            const np = { index:i, distanceFt, discharge, pressureBefore: 0, marker: null };
            manualPumps.push(np);
            updateManualProfileAndUI();
          });
        } else {
          if (pathLayer) pathLayer.off('click');
        }
      }
      if (Array.isArray(pumps)) {
        pumps.forEach((p, idx) => {
          const i = p.index;
          if (i != null && i >= 0 && i < latlngs.length) {
            const [lat, lon] = latlngs[i];
            const rpmInfo = p.rpm ? `<br>RPM: ${p.rpm}` : '';
            const headInfo = p.headAddedFt ? `<br>Head Add: ${p.headAddedFt.toFixed(0)} ft` : '';
            const qInfo = p.qgpm ? `<br>Flow: ${p.qgpm.toFixed(0)} gpm` : '';
            const famInfo = p.family ? `<br>Family: ${p.family}` : '';
            const marker = L.marker([lat, lon]).bindPopup(
              `<b>Midline Pump #${idx+1}</b><br>Distance: ${p.distanceFt.toFixed(0)} ft` +
              `<br>Inlet: ${p.pressureBefore.toFixed(1)} PSI` +
              `<br>Discharge: ${p.discharge.toFixed(1)} PSI` +
              rpmInfo + headInfo + qInfo + famInfo
            );
            pumpLayer.addLayer(marker);
          }
        });
      }
    }

    function renderChart(distances, pressures, minSuction, kinds) {
      if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
      if (!Array.isArray(distances) || !Array.isArray(pressures) || !distances.length || !pressures.length) return;

      const n = Math.min(distances.length, pressures.length);

      // Base dataset (drop 'post' points to avoid duplicate x)
      const basePts = [];
      for (let i = 0; i < n; i++) {
        const k = Array.isArray(kinds) && kinds.length === n ? kinds[i] : 'normal';
        if (k === 'post') continue;
        basePts.push({ x: Number(distances[i]), y: Number(pressures[i]) });
      }

      // Pump scatter (midpoint between pre and post for collision-free marker)
      const pumpMarkers = [];
      if (Array.isArray(kinds) && kinds.length === n) {
        for (let i = 0; i < n - 1; i++) {
          if (kinds[i] === 'pre' && kinds[i + 1] === 'post') {
            const d = Number(distances[i]);
            const preY = Number(pressures[i]);
            const postY = Number(pressures[i + 1]);
            const midY = (preY + postY) / 2;
            pumpMarkers.push({ x: d, y: midY, __pre: preY, __post: postY });
          }
        }
      }

      // Resolve CSS variables to JS for colors
      const css = getComputedStyle(document.documentElement);
      const lineColor = css.getPropertyValue('--chart-line').trim() || '#3b83f7';
      const fillColor = css.getPropertyValue('--chart-fill').trim() || 'rgba(59,131,247,0.12)';
      const pumpColor = css.getPropertyValue('--chart-pump').trim() || '#ff7f0e';
      const gridMajor = css.getPropertyValue('--chart-grid-major').trim() || '#2b3644';
      const gridMinor = css.getPropertyValue('--chart-grid-minor').trim() || '#1e2630';
      const axisText = css.getPropertyValue('--chart-text').trim() || '#9aa3ad';

      chartInstance = new Chart(chartCanvas.getContext('2d'), {
        type: 'line',
        data: {
          datasets: [
            {
              label: 'Pressure (PSI)',
              data: basePts,
              parsing: false,
              borderColor: lineColor,
              backgroundColor: fillColor,
              pointRadius: 0,
              pointHoverRadius: 2,
              tension: 0.15,
              fill: false,
              borderWidth: 3,
              order: 1,                      /* draw the line first (under) */
              segment: { z: 0 },             /* ensure segments are at low z */
              pointStyle: false              /* no points rendered for line */
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          interaction: { intersect: false, mode: 'nearest' },
          scales: {
            x: {
              title: { display: true, text: 'Distance (ft)', color: axisText },
              type: 'linear',
              ticks: { color: axisText, callback: (v) => Number(v).toFixed(1) },
              grid: { color: gridMinor }
            },
            y: {
              title: { display: true, text: 'Pressure (PSI)', color: axisText },
              beginAtZero: true,
              ticks: { color: axisText },
              grid: { color: gridMinor }
            }
          },
          plugins: {
            legend: { display: true, labels: { color: axisText } },
            tooltip: {
              mode: 'nearest',
              itemSort: (a, b) => (a.datasetIndex - b.datasetIndex) || (a.dataIndex - b.dataIndex),
              callbacks: {
                title: (items) => {
                  if (!items || !items.length) return '';
                  const x = Number(items[0].parsed.x);
                  return `Distance: ${Number(x).toFixed(1)} ft`;
                },
                label: (item) => {
                  if (item.datasetIndex === 1) {
                    const raw = item.raw || {};
                    const pre = typeof raw.__pre === 'number' ? raw.__pre : null;
                    const post = typeof raw.__post === 'number' ? raw.__post : null;
                    const lines = [];
                    if (pre != null) lines.push(`Pre (inlet): ${Number(pre).toFixed(3)} PSI`);
                    if (post != null) lines.push(`Post (discharge): ${Number(post).toFixed(3)} PSI`);
                    return lines;
                  }
                  return `Pressure: ${Number(item.parsed.y).toFixed(3)} PSI`;
                }
              }
            }
          },
          elements: { line: { spanGaps: true } }
        }
      });
    }

    // Render Elevation Profile with pump markers
    function renderElevationChart(distFt, elevFt, pumps) {
      // Destroy previous
      if (elevChartInstance) {
        try { elevChartInstance.destroy(); } catch {}
        elevChartInstance = null;
      }
      // If no valid data, hide the section and clear canvas so nothing persists visually
      if (!Array.isArray(distFt) || !Array.isArray(elevFt) || distFt.length === 0 || elevFt.length === 0) {
        if (elElevChartSection) elElevChartSection.style.display = 'none';
        if (elevChartCanvas && elevChartCanvas.getContext) {
          try {
            const ctx = elevChartCanvas.getContext('2d');
            ctx && ctx.clearRect(0, 0, elevChartCanvas.width, elevChartCanvas.height);
          } catch {}
        }
        return;
      }

      // Build data directly in feet to match pressure chart scaling
      const n = Math.min(distFt.length, elevFt.length);
      const lineData = new Array(n).fill(0).map((_, i) => ({ x: Number(distFt[i]), y: Number(elevFt[i]) }));

      // Pump markers positioned in feet on x-axis
      const pumpPoints = Array.isArray(pumps) ? pumps.map(p => {
        const idx = Math.max(0, Math.min(n - 1, Number(p.index) || 0));
        return { x: Number(distFt[idx]), y: Number(elevFt[idx]) };
      }) : [];

      // Ensure section visible
      if (elElevChartSection) elElevChartSection.style.display = 'block';

      const css = getComputedStyle(document.documentElement);
      const lineColor = css.getPropertyValue('--chart-line').trim() || 'rgba(11,95,255,0.85)';
      const fillColor = css.getPropertyValue('--chart-fill').trim() || 'rgba(11,95,255,0.20)';
      const pumpColor = css.getPropertyValue('--chart-pump').trim() || '#000';
      const gridMinor = css.getPropertyValue('--chart-grid-minor').trim() || '#1e2630';
      const axisText = css.getPropertyValue('--chart-text').trim() || '#9aa3ad';

      elevChartInstance = new Chart(elevChartCanvas.getContext('2d'), {
        type: 'line',
        data: {
          datasets: [
            {
              label: 'Elevation (ft)',
              data: lineData,
              borderColor: lineColor,
              backgroundColor: fillColor,
              pointRadius: 0,
              tension: 0.15,
              borderWidth: 3,
              order: 1,                 /* draw the line first (under) */
              segment: { z: 0 },        /* keep segments under */
              pointStyle: false
            },
            {
              label: 'Pump',
              type: 'scatter',
              data: pumpPoints,
              pointStyle: pumpIcon,
              pointBackgroundColor: pumpColor,
              pointBorderColor: pumpColor,
              pointRadius: 7,
              pointHoverRadius: 8,
              showLine: false,
              order: 9999,
              clip: false
              // Drawing is handled by PumpOnTopPlugin to ensure on-top layering
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          parsing: false,
          scales: {
            x: {
              title: { display: true, text: 'Distance (ft)', color: axisText },
              type: 'linear',
              ticks: {
                callback: (value) => Number(value).toFixed(1),
                color: axisText
              },
              grid: { color: gridMinor }
            },
            y: {
              title: { display: true, text: 'Elevation (ft)', color: axisText },
              beginAtZero: false,
              ticks: { color: axisText },
              grid: { color: gridMinor }
            }
          },
          plugins: {
            legend: { display: true, labels: { color: axisText } }
          },
          elements: { line: { spanGaps: true } }
        }
      });
    }

    // [Removed] pump curve helpers and families (manual mode only)

    // Build CSV with detailed hydraulics per your spec.
    // Enhancements:
    // - pump_inlet_psi now uses the exact pre-row pressure at the pump vertex (true inlet at location)
    // - Add constant columns: usedPsiLossPer100 and loss_per_ft
    // - Add pump_index: sequential number for pumps in path order
    //
    // Rows:
    // - One row per base vertex normally
    // - At pump vertices: include two rows (pre, post). Pre row uses upstream segment terms (i-1→i).
    //   Post row has zero seg terms (instantaneous jump).
    function buildHydraulicsCsv(state, distFt, elevFt, pumps, usedPsiLossPer100) {
      try {
        const lossPerFt = Number(usedPsiLossPer100 || 0) / 100.0;
        const n = Math.min(
          Array.isArray(distFt) ? distFt.length : 0,
          Array.isArray(elevFt) ? elevFt.length : 0
        );
        if (!n || n < 1) throw new Error('No profile points available');

        // Build a quick lookup for pump by index (assume at most one per index)
        const pumpByIndex = Object.create(null);
        let pumpCounter = 0;
        const sortedPumps = Array.isArray(pumps)
          ? pumps.slice().sort((a,b) => (a.index||0) - (b.index||0))
          : [];
        sortedPumps.forEach(p => {
          const idx = Number(p.index);
          if (Number.isInteger(idx) && idx >= 0 && idx < n && !pumpByIndex[idx]) {
            pumpCounter += 1;
            pumpByIndex[idx] = {
              discharge: Number(p.discharge || 0),
              // Keep original stored inlet for reference, but CSV will use computed pre-row inlet
              inletStored: (typeof p.pressureBefore === 'number') ? Number(p.pressureBefore) : null,
              pump_index: pumpCounter
            };
          }
        });

        // Recompute pressures across base vertices (same as profile logic without duplicate-x emit)
        let p = Number(state?.sourcePsi || 0);
        const rows = [];
        const toMiles = ft => Number(ft || 0) / 5280;
        const toCsv = v => {
          if (v === null || v === undefined) return '';
          if (typeof v === 'number' && !Number.isFinite(v)) return '';
          return String(v);
        };

        // Header with inputs snapshot (as commented rows) + column header
        const headerLines = [];
        const usedPer100 = Number(state?.results?.usedPsiLossPer100 ?? usedPsiLossPer100 ?? 0);
        headerLines.push(`# flow_bpm,${toCsv(state?.flowBpm)}`);
        headerLines.push(`# hose_in,${toCsv(state?.hoseIn)}`);
        headerLines.push(`# hose_runs,${toCsv(state?.hoseRuns)}`);
        headerLines.push(`# psi_loss_per_100,${toCsv(usedPer100)}`);
        headerLines.push(`# loss_per_ft,${toCsv(lossPerFt)}`);
        headerLines.push(`# path_dir,${toCsv(state?.pathDir)}`);
        headerLines.push('index,distance_ft,distance_miles,elevation_ft,pressure_psi,seg_len_ft,elev_delta_ft,elev_delta_psi,friction_psi,delta_psi,is_pump,pump_inlet_psi,pump_discharge_psi,pump_index,usedPsiLossPer100,loss_per_ft');

        // Seed i=0 row (no segment terms)
        {
          const i = 0;
          const row = {
            index: i,
            distance_ft: Number(distFt[i] || 0),
            distance_miles: toMiles(distFt[i] || 0),
            elevation_ft: Number(elevFt[i] || 0),
            pressure_psi: p,
            seg_len_ft: 0,
            elev_delta_ft: 0,
            elev_delta_psi: 0,
            friction_psi: 0,
            delta_psi: 0,
            is_pump: '',
            pump_inlet_psi: '',
            pump_discharge_psi: '',
            pump_index: '',
            usedPsiLossPer100: usedPer100,
            loss_per_ft: lossPerFt
          };
          // If pump exists exactly at 0, emit pre and post rows
          if (pumpByIndex[i]) {
            // Pre row at i (upstream segment doesn’t exist; keep zeros)
            rows.push(row);
            // Post row at i (jump) — inlet uses pre pressure at vertex (row.pressure_psi)
            rows.push({
              ...row,
              pressure_psi: pumpByIndex[i].discharge,
              is_pump: 'post',
              pump_inlet_psi: toCsv(row.pressure_psi),
              pump_discharge_psi: toCsv(pumpByIndex[i].discharge),
              pump_index: pumpByIndex[i].pump_index,
              usedPsiLossPer100: usedPer100,
              loss_per_ft: lossPerFt
            });
            p = pumpByIndex[i].discharge;
          } else {
            rows.push(row);
          }
        }

        for (let i = 1; i < n; i++) {
          const segLen = Number(distFt[i] - distFt[i-1] || 0);
          const dhFt = Number(elevFt[i] - elevFt[i-1] || 0);
          const elevDeltaPsi = -dhFt * PSI_PER_FOOT_WATER;
          const frictionPsi = lossPerFt * segLen;

          // If a pump exists exactly at i, emit a pre row (upstream segment i-1→i),
          // then a post row (jump with zeros for segment terms), then continue downstream
          if (pumpByIndex[i]) {
            // Pre row at i (before jump): current p includes upstream segment effects
            const pBefore = p + elevDeltaPsi - frictionPsi;
            rows.push({
              index: i,
              distance_ft: Number(distFt[i]),
              distance_miles: toMiles(distFt[i]),
              elevation_ft: Number(elevFt[i]),
              pressure_psi: pBefore,
              seg_len_ft: segLen,
              elev_delta_ft: dhFt,
              elev_delta_psi: elevDeltaPsi,
              friction_psi: frictionPsi,
              delta_psi: (elevDeltaPsi - frictionPsi),
              is_pump: 'pre',
              pump_inlet_psi: toCsv(pBefore), // exact inlet at pump vertex
              pump_discharge_psi: toCsv(pumpByIndex[i].discharge),
              pump_index: pumpByIndex[i].pump_index,
              usedPsiLossPer100: usedPer100,
              loss_per_ft: lossPerFt
            });

            // Post row at i (jump): instantaneous change to discharge; zero segment terms
            const pAfter = Number(pumpByIndex[i].discharge);
            rows.push({
              index: i,
              distance_ft: Number(distFt[i]),
              distance_miles: toMiles(distFt[i]),
              elevation_ft: Number(elevFt[i]),
              pressure_psi: pAfter,
              seg_len_ft: 0,
              elev_delta_ft: 0,
              elev_delta_psi: 0,
              friction_psi: 0,
              delta_psi: 0,
              is_pump: 'post',
              pump_inlet_psi: toCsv(pBefore), // exact inlet at pump vertex
              pump_discharge_psi: toCsv(pumpByIndex[i].discharge),
              pump_index: pumpByIndex[i].pump_index,
              usedPsiLossPer100: usedPer100,
              loss_per_ft: lossPerFt
            });

            // Set p to post value for downstream propagation to i+1
            p = pAfter;
          } else {
            // Normal vertex: apply upstream segment and emit single row
            p = p + elevDeltaPsi - frictionPsi;
            rows.push({
              index: i,
              distance_ft: Number(distFt[i]),
              distance_miles: toMiles(distFt[i]),
              elevation_ft: Number(elevFt[i]),
              pressure_psi: p,
              seg_len_ft: segLen,
              elev_delta_ft: dhFt,
              elev_delta_psi: elevDeltaPsi,
              friction_psi: frictionPsi,
              delta_psi: (elevDeltaPsi - frictionPsi),
              is_pump: '',
              pump_inlet_psi: '',
              pump_discharge_psi: '',
              pump_index: '',
              usedPsiLossPer100: usedPer100,
              loss_per_ft: lossPerFt
            });
          }
        }

        // Serialize to CSV text
        const escape = (s) => {
          const t = String(s);
          if (/[",\n]/.test(t)) return '"' + t.replace(/"/g,'""') + '"';
          return t;
        };
        const lines = headerLines.concat(
          rows.map(r => [
            r.index, r.distance_ft, r.distance_miles, r.elevation_ft, r.pressure_psi,
            r.seg_len_ft, r.elev_delta_ft, r.elev_delta_psi, r.friction_psi, r.delta_psi,
            r.is_pump, r.pump_inlet_psi, r.pump_discharge_psi, r.pump_index, r.usedPsiLossPer100, r.loss_per_ft
          ].map(escape).join(','))
        );
        return lines.join('\n');
      } catch (e) {
        throw e;
      }
    }

    async function readKmlOrKmz(file) {
      const name = (file?.name || '').toLowerCase();
      if (name.endsWith('.kml')) {
        const text = await file.text();
        return text;
      } else if (name.endsWith('.kmz')) {
        throw new Error('Unsupported file type: KMZ is not supported. Please upload a .kml file.');
      } else {
        throw new Error('Unsupported file type. Please upload a .kml file.');
      }
    }

    function collectWarningsInto(list, msg) {
      list.push(msg);
    }

    function determinePsiLossPer100(flowBpm, hoseIn, lossMethod, manualVal, hazenCFactor, warnings, runsCount) {
      const runs = Math.max(1, Number(runsCount) || 1);
      let usedPsiLossPer100 = 0;

      if (lossMethod === 'manual') {
              if (!(manualVal >= 0)) {
                collectWarningsInto(warnings, 'Manual PSI loss per 100 ft must be >= 0.');
                usedPsiLossPer100 = 0;
              } else {
                // Option B:
                // Assume manualVal is the single-run loss at the total flow (PSI/100 ft).
                // For N identical parallel runs sharing flow evenly, scale by runs^-1.85.
                const exponent = 1.85;
                usedPsiLossPer100 = runs > 1 ? manualVal / Math.pow(runs, exponent) : manualVal;
              }
            } else if (lossMethod === 'hazen') {
        const totalGpm = bpmToGpm(flowBpm);
        const perHoseGpm = totalGpm / runs;
        if (!(hazenCFactor > 0)) {
          collectWarningsInto(warnings, 'Hazen-Williams C-Factor must be > 0.');
          usedPsiLossPer100 = 0;
        } else {
          // Calculate loss for a single hose at the per-hose flow rate.
          // For parallel runs, this per-hose loss IS the total system loss.
          const lossPerHose = calculateHazenWilliamsLoss(perHoseGpm, hazenCFactor, hoseIn);
          usedPsiLossPer100 = lossPerHose;
        }
      } else { // 'lookup'
        // Lookup mode: compute loss at per-hose flow when using multiple runs.
        // The total flow is split evenly across runs.
        const totalGpm = bpmToGpm(flowBpm);
        const perHoseGpm = totalGpm / runs;

        const headLoss12_perHose = lookupHeadLoss12in(perHoseGpm);
        if (headLoss12_perHose == null) {
          collectWarningsInto(warnings, 'Flow is outside the 12" lookup table range; cannot interpolate.');
          usedPsiLossPer100 = 0;
        } else {
          const scaledHeadLoss_perHose = scaleHeadLossByDiameter(headLoss12_perHose, hoseIn);
          const psiPerHose = headLossFtToPsi(scaledHeadLoss_perHose);
          // For parallel runs, the calculated loss for a single hose at the reduced flow rate
          // is the correct total system loss. The previous division by `runs` was incorrect.
          usedPsiLossPer100 = psiPerHose;
        }
      }
      return usedPsiLossPer100;
    }

    function renderResults(totalFt, usedPsiLossPer100, finalPressure, pumpCount, warnings, distances, pressures, minSuction, kinds) {
      elResults.style.display = 'block';
      
      // Update both textContent and data-value for mobile table layout
      const distValue = totalFt.toFixed(1);
      const lossValue = usedPsiLossPer100.toFixed(4) + ' PSI/100ft';
      const pressureValue = finalPressure.toFixed(1);
      const pumpValue = String(Math.max(0, Number(pumpCount) || 0));
      
      elOutDist.textContent = distValue;
      elOutDist.parentElement.setAttribute('data-value', distValue);
      
      elOutUsedLoss.textContent = lossValue;
      elOutUsedLoss.parentElement.setAttribute('data-value', lossValue);
      
      elOutFinalPsi.textContent = pressureValue;
      elOutFinalPsi.parentElement.setAttribute('data-value', pressureValue);
      
      elOutPumpCount.textContent = pumpValue;
      elOutPumpCount.parentElement.setAttribute('data-value', pumpValue);

      if (warnings.length) {
        elWarningsWrap.style.display = 'block';
        elWarningsList.innerHTML = '';
        warnings.forEach(w => {
          const li = document.createElement('li');
          li.textContent = w;
          elWarningsList.appendChild(li);
        });
      } else {
        elWarningsWrap.style.display = 'none';
        elWarningsList.innerHTML = '';
      }

      elChartSection.style.display = 'block';
      renderChart(distances, pressures, minSuction, kinds);
  
      // Enable CSV button now that we have a successful run
      const csvBtn = document.getElementById('download-csv');
      if (csvBtn) csvBtn.disabled = false;
 
      // Store the latest run dataset on window for CSV generation
      window.__modelerLastRun = {
        flowBpm: Number(elFlowBpm.value),
        hoseIn: Number(elHoseSize.value),
        hoseRuns: Number(document.getElementById('hose-runs')?.value || 1),
        sourcePsi: Number(elSourcePsi.value),
        midlinePsi: Number(elMidlinePsi.value),
        minSuction: 0,
        maxHose: Number(elMaxHose.value),
        lossMethod: currentLossMethod(),
        manualPsi100: Number(elManualPsi100.value),
        hazenCFactor: Number(elHazenCFactor.value),
        placementStrategy: 'manual',
        pathDir: currentPathDir(),
        results: {
          totalFt,
          usedPsiLossPer100,
          finalPressure,
          pumpCount,
          warnings: [...warnings]
        },
        profile: { distances, pressures, kinds },
        // Elevation series and base distances for the elevation chart in the report
        elevationsFt: Array.isArray(manualElevFt) ? manualElevFt.slice() : [],
        baseDistancesFt: Array.isArray(manualDistFt) ? manualDistFt.slice() : [],
        pumpsSummary: (window.__lastPumps || []),
        placementStrategy: 'manual'
      };
    }

    async function runCalc() {
      const flowBpm = Number(elFlowBpm.value);
      const hoseIn = Number(elHoseSize.value);
      const sourcePsi = Number(elSourcePsi.value);
      const midlinePsi = Number(elMidlinePsi.value);
      // Manual-only: no user min suction; keep zero for compatibility
      const minSuction = 0;
      const maxHose = Number(elMaxHose.value);
      const lossMethod = currentLossMethod();
      const manualPsi100 = Number(elManualPsi100.value);
      const hazenCFactor = Number(elHazenCFactor.value);
      const runsCount = Math.max(1, Number(elHoseRuns && elHoseRuns.value ? elHoseRuns.value : 1));
      const pathDir = currentPathDir();
      const placementStrategy = 'manual';

      const warnings = [];
      if (!(flowBpm >= 0)) warnings.push('Flow rate (BPM) must be >= 0.');
      if (!(sourcePsi > 0)) warnings.push('Source discharge PSI must be > 0.');
      if (!(maxHose > 0)) warnings.push('Max allowable hose PSI must be > 0.');
      if (sourcePsi > maxHose) warnings.push(`Source discharge (${sourcePsi.toFixed(1)} PSI) exceeds hose max (${maxHose.toFixed(1)} PSI).`);

      // Determine friction loss
      const usedPsiLossPer100 = determinePsiLossPer100(flowBpm, hoseIn, lossMethod, manualPsi100, hazenCFactor, warnings, runsCount);

      // Path handling
      let latlngs = [];
      let usingKml = false;
      const file = elKmlFile.files && elKmlFile.files[0] ? elKmlFile.files[0] : null;
      if (file) {
        usingKml = true;
        let kmlText = '';
        try {
          kmlText = await readKmlOrKmz(file);
        } catch (e) {
          warnings.push(`KML/KMZ error: ${e.message}`);
        }
        if (kmlText) {
          const parsed = parseKmlLineStringToLatLngs(kmlText);
          if (!parsed.length) warnings.push('No LineString coordinates found in KML.');
          latlngs = parsed;
        }
      }

      // If no KML path provided, block calculation silently and prompt user in path section
      if (!latlngs.length) {
        delete window.__modelerLastRun;

        elMapSection.style.display = 'none';
        elResults.style.display = 'none';
        elChartSection.style.display = 'none';
        elWarningsWrap.style.display = 'none';
        elWarningsList.innerHTML = '';

        const pathStatus = document.getElementById('path-status');
        if (pathStatus) {
          pathStatus.style.display = 'block';
          pathStatus.textContent = 'No path loaded. Upload a KML to run.';
        }
        return;
      }

      // If we have KML path, optionally reverse
      if (pathDir === 'dest_to_source') latlngs.reverse();

      // Downsample if needed
      const dsLatLngs = downsampleLatLngs(latlngs, MAX_POINTS);

      // Build a path cache key based on the downsampled coordinates
      const pathKey = pathKeyFromLatLngs(dsLatLngs);
      window.__lastPathKey = pathKey; // keep for retries/report if needed

      // Elevations (cache-first)
      let elevationsFt = null;
      const retryWrap = document.getElementById('elev-retry-wrap');

      // Try cache
      const cachedFt = getCachedElevationsFt(pathKey);
      if (cachedFt && cachedFt.length === dsLatLngs.length) {
        elevationsFt = cachedFt;
        if (retryWrap) retryWrap.style.display = 'none';
      } else {
        // Cache miss: fetch from network
        let elevationsM = [];
        try {
          showBusy('Sampling elevation…');
          elevationsM = await fetchElevationsOpenTopo(dsLatLngs);
          if (retryWrap) retryWrap.style.display = 'none';
        } catch (e) {
          if (retryWrap) retryWrap.style.display = 'block';
          warnings.push(`Elevation fetch failed: ${e.message}`);
          elevationsM = dsLatLngs.map(() => 0);
        } finally {
          hideBusy();
          // Clear any pending JSONP script tags that might outlive failures
          try {
            const heads = document.querySelectorAll('head script[src*="api.allorigins.win/get"]');
            heads.forEach(s => s.parentNode && s.parentNode.removeChild(s));
          } catch {}
        }
        elevationsFt = elevationsM.map(m => m * 3.28084);
        // Store in cache if sizes align
        if (Array.isArray(elevationsFt) && elevationsFt.length === dsLatLngs.length) {
          setCachedElevationsFt(pathKey, elevationsFt);
        }
      }

      // Distances
      const distFt = cumulativeDistancesFt(dsLatLngs);
      const totalFt = distFt[distFt.length - 1] || 0;

      // Cache for manual mode recompute
      manualLatLngs = dsLatLngs;
      manualDistFt = distFt;
      manualElevFt = elevationsFt;
      // Persist last dsLatLngs for elevation retry
      window.__lastDsLatLngs = dsLatLngs;

      // Determine friction loss we used (for manual recompute reuse)
      window.__lastUsedPsiLossPer100 = usedPsiLossPer100;
      window.__lastWarnings = warnings;

      // Manual-only: show manual panel, render path, and defer outputs to manual UI recompute
      manualMode = true;
      document.getElementById('manual-panel').style.display = 'block';
      if (!Array.isArray(manualPumps)) manualPumps = [];
      renderPathOnMap(dsLatLngs, []);
      updateManualProfileAndUI();
      return;
    }

    document.getElementById('run-calc').addEventListener('click', runCalc);


    // Render a basic SVG pressure chart without external libraries
    function buildSimplePressureSvg(distances, pressures, minLine) {
      if (!Array.isArray(distances) || !Array.isArray(pressures) || distances.length < 2) {
        return '<div class="center" style="padding:20px;color:#666;">No chart data</div>';
      }
      const width = 900, height = 300, padL = 60, padR = 10, padT = 10, padB = 38;
      const minX = distances[0], maxX = distances[distances.length-1];

      // Only include a solid red Max Hose line; remove the yellow min-suction reference line
      const maxHosePsi = Number(window.__modelerLastRun?.maxHose ?? 0);

      // Determine Y extents considering pressures and max hose reference (omit minLine entirely)
      const valuesForY = [...pressures];
      if (isFinite(maxHosePsi)) valuesForY.push(maxHosePsi);
      let minY = Math.min(...valuesForY);
      let maxY = Math.max(...valuesForY);
      if (!isFinite(minY) || !isFinite(maxY) || minY === maxY) { minY = 0; maxY = 1; }

      // Nice tick generation utilities
      function niceStep(span, maxTicks) {
        const rough = span / Math.max(1, maxTicks);
        const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
        const candidates = [1, 2, 2.5, 5, 10].map(m => m * pow10);
        // choose the step that yields tick count closest to maxTicks
        let best = candidates[0], bestDiff = Infinity;
        for (const s of candidates) {
          const n = Math.ceil(span / s);
          const diff = Math.abs(n - maxTicks);
          if (diff < bestDiff) { bestDiff = diff; best = s; }
        }
        return best;
      }
      function linspaceTicks(minV, maxV, desired) {
        const span = Math.max(1e-9, maxV - minV);
        const step = niceStep(span, desired);
        const start = Math.ceil(minV / step) * step;
        const ticks = [];
        for (let v = start; v <= maxV + 1e-9; v += step) ticks.push(Number(v.toFixed(10)));
        return { ticks, step };
      }

      // Create scales
      const sx = x => padL + (x - minX) * (width - padL - padR) / (maxX - minX || 1);
      const sy = y => height - padB - (y - minY) * (height - padT - padB) / (maxY - minY || 1);

      // Build polyline points
      const pts = distances.map((d,i) => `${sx(d)},${sy(pressures[i])}`).join(' ');

      // Axis ticks (aim ~6 on each axis)
      const yTicksInfo = linspaceTicks(minY, maxY, 6);
      const xTicksInfo = linspaceTicks(minX, maxX, 6);
      const fmtFeet = n => Number(n).toLocaleString(undefined, { maximumFractionDigits: 0 });

      const yTicksSvg = yTicksInfo.ticks.map(v => `
        <line x1="${padL-4}" y1="${sy(v)}" x2="${padL}" y2="${sy(v)}" stroke="#777" stroke-width="1"/>
        <line x1="${padL}" y1="${sy(v)}" x2="${width-padR}" y2="${sy(v)}" stroke="#e9ecff" stroke-width="1"/>
        <text x="${padL-8}" y="${sy(v)+4}" text-anchor="end" font-size="11" fill="#444"
              font-family="'ISOCPEUR', Arial, sans-serif">${Math.round(v)}</text>
      `).join('');

      const xTicksSvg = xTicksInfo.ticks.map(v => `
        <line x1="${sx(v)}" y1="${height-padB}" x2="${sx(v)}" y2="${height-padB+4}" stroke="#777" stroke-width="1"/>
        <line x1="${sx(v)}" y1="${padT}" x2="${sx(v)}" y2="${height-padB}" stroke="#f2f4ff" stroke-width="1"/>
        <text x="${sx(v)}" y="${height-padB+16}" text-anchor="middle" font-size="11" fill="#444"
              font-family="'ISOCPEUR', Arial, sans-serif">${fmtFeet(v)}</text>
      `).join('');

      // Max hose (solid red) + label
      const maxHoseLine = isFinite(maxHosePsi) && maxHosePsi > 0 ? `
        <line x1="${sx(minX)}" y1="${sy(maxHosePsi)}" x2="${sx(maxX)}" y2="${sy(maxHosePsi)}"
              stroke="#dc3545" stroke-width="2" />
        <text x="${sx(maxX) - 8}" y="${sy(maxHosePsi) - 6}" text-anchor="end"
              font-size="12" font-weight="700" fill="#dc3545"
              font-family="'ISOCPEUR', Arial, sans-serif">
          User-defined Max Pressure (PSI)
        </text>
      ` : '';

      return `
        <svg viewBox="0 0 ${width} ${height}" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
          <rect x="0" y="0" width="${width}" height="${height}" fill="white" />
          <!-- Axes base lines -->
          <line x1="${padL}" y1="${padT}" x2="${padL}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <line x1="${padL}" y1="${height-padB}" x2="${width-padR}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <!-- Grid + tick labels -->
          ${yTicksSvg}
          ${xTicksSvg}
          <!-- Axis labels -->
          <text class="axis-label" x="${(padL + (width - padR)) / 2}" y="${height - 4}" text-anchor="middle">Distance (ft)</text>
          <text class="axis-label" transform="translate(16 ${(padT + (height - padB)) / 2}) rotate(-90)" text-anchor="middle">Pressure (PSI)</text>
          <!-- Data -->
          ${maxHoseLine}
          <polyline fill="none" stroke="#0b5fff" stroke-width="2" points="${pts}" />
        </svg>
      `;
    }

    // Render a basic SVG elevation chart with pump markers (inline, no external libs)
    function buildSimpleElevationSvg(distancesFt, elevationsFt, pumpsSummary) {
      if (!Array.isArray(distancesFt) || !Array.isArray(elevationsFt) || distancesFt.length < 2 || elevationsFt.length < 2) {
        return '<div class="center" style="padding:20px;color:#666;">No elevation data</div>';
      }
      const n = Math.min(distancesFt.length, elevationsFt.length);
      const dist = distancesFt.slice(0, n);
      const elev = elevationsFt.slice(0, n);

      // Convert X to miles for labeling/scale
      const miles = dist.map(d => Number(d) / 5280);

      const width = 900, height = 300, padL = 60, padR = 10, padT = 10, padB = 38;
      const minX = miles[0], maxX = miles[miles.length - 1];

      let minY = Math.min(...elev);
      let maxY = Math.max(...elev);
      if (!isFinite(minY) || !isFinite(maxY) || minY === maxY) { minY = 0; maxY = 1; }

      function niceStep(span, maxTicks) {
        const rough = span / Math.max(1, maxTicks);
        const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
        const candidates = [1, 2, 2.5, 5, 10].map(m => m * pow10);
        let best = candidates[0], bestDiff = Infinity;
        for (const s of candidates) {
          const n = Math.ceil(span / s);
          const diff = Math.abs(n - maxTicks);
          if (diff < bestDiff) { bestDiff = diff; best = s; }
        }
        return best;
      }
      function linspaceTicks(minV, maxV, desired) {
        const span = Math.max(1e-9, maxV - minV);
        const step = niceStep(span, desired);
        const start = Math.ceil(minV / step) * step;
        const ticks = [];
        for (let v = start; v <= maxV + 1e-9; v += step) ticks.push(Number(v.toFixed(10)));
        return { ticks, step };
      }

      const sx = x => padL + (x - minX) * (width - padL - padR) / (maxX - minX || 1);
      const sy = y => height - padB - (y - minY) * (height - padT - padB) / (maxY - minY || 1);

      // Line path
      const pts = miles.map((m, i) => `${sx(m)},${sy(elev[i])}`).join(' ');

      // Pump markers: locate by nearest distance in feet against dist array
      const pumpDots = Array.isArray(pumpsSummary) ? pumpsSummary.map((p) => {
        const dFt = Number(p.distanceFt || 0);
        // linear search for nearest index (n is at most 2000 after downsampling)
        let bestI = 0, bestDiff = Infinity;
        for (let i = 0; i < dist.length; i++) {
          const df = Math.abs(dist[i] - dFt);
          if (df < bestDiff) { bestDiff = df; bestI = i; }
        }
        const x = sx(miles[bestI]);
        const y = sy(elev[bestI]);
        return `<circle cx="${x}" cy="${y}" r="4.5" fill="#000" stroke="#000" />`;
      }).join('') : '';

      const yTicksInfo = linspaceTicks(minY, maxY, 6);
      const xTicksInfo = linspaceTicks(minX, maxX, 6);

      const yTicksSvg = yTicksInfo.ticks.map(v => `
        <line x1="${padL-4}" y1="${sy(v)}" x2="${padL}" y2="${sy(v)}" stroke="#777" stroke-width="1"/>
        <line x1="${padL}" y1="${sy(v)}" x2="${width-padR}" y2="${sy(v)}" stroke="#e9ecff" stroke-width="1"/>
        <text x="${padL-8}" y="${sy(v)+4}" text-anchor="end" font-size="11" fill="#444"
              font-family="'ISOCPEUR', Arial, sans-serif">${Math.round(v)}</text>
      `).join('');

      const xTicksSvg = xTicksInfo.ticks.map(v => `
        <line x1="${sx(v)}" y1="${height-padB}" x2="${sx(v)}" y2="${height-padB+4}" stroke="#777" stroke-width="1"/>
        <line x1="${sx(v)}" y1="${padT}" x2="${sx(v)}" y2="${height-padB}" stroke="#f2f4ff" stroke-width="1"/>
        <text x="${sx(v)}" y="${height-padB+16}" text-anchor="middle" font-size="11" fill="#444"
              font-family="'ISOCPEUR', Arial, sans-serif">${Number(v).toFixed(2)}</text>
      `).join('');

      return `
        <svg viewBox="0 0 ${width} ${height}" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
          <rect x="0" y="0" width="${width}" height="${height}" fill="white" />
          <!-- Axes base lines -->
          <line x1="${padL}" y1="${padT}" x2="${padL}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <line x1="${padL}" y1="${height-padB}" x2="${width-padR}" y2="${height-padB}" stroke="#aaa" stroke-width="1"/>
          <!-- Grid + tick labels -->
          ${yTicksSvg}
          ${xTicksSvg}
          <!-- Axis labels -->
          <text class="axis-label" x="${(padL + (width - padR)) / 2}" y="${height - 4}" text-anchor="middle">Distance (miles)</text>
          <text class="axis-label" transform="translate(16 ${(padT + (height - padB)) / 2}) rotate(-90)" text-anchor="middle">Elevation (ft)</text>
          <!-- Data -->
          <polyline fill="none" stroke="rgba(11,95,255,0.85)" stroke-width="2" points="${pts}" />
          ${pumpDots}
        </svg>
      `;
    }

    // --- Download CSV wiring ---
    const csvBtn = document.getElementById('download-csv');
    if (csvBtn) {
      csvBtn.addEventListener('click', () => {
        try {
          if (!window.__modelerLastRun) {
            alert('No run data available. Run a calculation first.');
            return;
          }
          const state = window.__modelerLastRun;
          // Build CSV from the current manual state so it reflects latest edits/drags
          const csv = buildHydraulicsCsv(
            state,
            Array.isArray(window.manualDistFt) ? window.manualDistFt : (state.baseDistancesFt || []),
            Array.isArray(window.manualElevFt) ? window.manualElevFt : (state.elevationsFt || []),
            Array.isArray(window.manualPumps) ? window.manualPumps : (state.pumpsSummary || []),
            Number(state.results?.usedPsiLossPer100 || window.__lastUsedPsiLossPer100 || 0)
          );
          const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          const ts = new Date().toISOString().replace(/[:.]/g,'-');
          a.href = url;
          a.download = `layflat_hydraulics_${ts}.csv`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (e) {
          alert('CSV generation failed: ' + (e?.message || e));
        }
      });
    }
 
    // Wire Retry Elevations button
    const __retryBtn = document.getElementById('retry-elev');
    if (__retryBtn) {
      __retryBtn.addEventListener('click', async () => {
        const coords = window.__lastDsLatLngs;
        if (!Array.isArray(coords) || !coords.length) return;
        try {
          showBusy('Retrying elevation…');
          const m = await fetchElevationsOpenTopo(coords);
          const ft = m.map(v => v * 3.28084);
          manualElevFt = ft;

          // Also update cache for the current pathKey
          const k = window.__lastPathKey || pathKeyFromLatLngs(coords);
          if (k) setCachedElevationsFt(k, ft);

          hideBusy();
          const rw = document.getElementById('elev-retry-wrap');
          if (rw) rw.style.display = 'none';
          updateManualProfileAndUI();
        } catch (e) {
          hideBusy();
          alert('Retry failed: ' + e.message);
        }
      });
    }

    // --- Input-change mechanics: no auto-run; require explicit Run Calculation ---

    // Clear derived UI when inputs change to prevent reading stale values
    function clearDerivedUI() {
      // Hide previous results/chart until the next run completes
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';

      // Elevation: destroy instance, hide section, and clear canvas to avoid ghost rendering
      if (elevChartInstance) { try { elevChartInstance.destroy(); } catch {} elevChartInstance = null; }
      if (elElevChartSection) elElevChartSection.style.display = 'none';
      if (elevChartCanvas && elevChartCanvas.getContext) {
        try {
          const ctx = elevChartCanvas.getContext('2d');
          ctx && ctx.clearRect(0, 0, elevChartCanvas.width, elevChartCanvas.height);
        } catch {}
      }

      // Keep map section visible but clear pumps so user sees path without stale boosts
      if (pumpLayer) { try { pumpLayer.clearLayers(); } catch {} }
      // Disable CSV and clear last run to avoid stale export
      const csvBtn = document.getElementById('download-csv');
      if (csvBtn) csvBtn.disabled = true;
      delete window.__modelerLastRun;
    }

    // Whenever a user changes inputs that affect hydraulics, just clear derived UI (no auto run)
    // Note: elPlacementStrategy no longer exists in this manual-only app.
    const hydraulicInputs = [
      elFlowBpm, elHoseSize, elSourcePsi, elMidlinePsi,
      elMaxHose, elManualPsi100, /* elPlacementStrategy, */ elHoseRuns
    ];
    hydraulicInputs.forEach(inp => {
      if (!inp) return;
      inp.addEventListener('input', () => { clearDerivedUI(); });
      inp.addEventListener('change', () => { clearDerivedUI(); });
    });

    // Friction loss method radios
    lossRadios.forEach(r => {
      r.addEventListener('change', () => { updateLossInputVisibility(); clearDerivedUI(); });
    });

    // Path direction radios (reverse path)
    pathDirRadios.forEach(r => {
      r.addEventListener('change', () => { clearDerivedUI(); });
    });

    // When a new KML/KMZ is selected, clear outputs; user must press Run Calculation
    elKmlFile.addEventListener('change', () => {
      // Clear everything visual so a new file doesn't mix with old output
      elResults.style.display = 'none';
      elChartSection.style.display = 'none';
      const csvBtn = document.getElementById('download-csv');
      if (csvBtn) csvBtn.disabled = true;
      delete window.__modelerLastRun;

      if (chartInstance) { try { chartInstance.destroy(); } catch {} chartInstance = null; }
      if (mapInstance) {
        // Remove old layers/instance to ensure a clean start
        try { mapInstance.remove(); } catch {}
        mapInstance = null; pathLayer = null; pumpLayer = null;
      }
    });

    // Remove previous auto-run blur handler: no-op now
  </script>
</body>
</html>